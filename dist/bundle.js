/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/constants.ts"
/*!**************************!*\
  !*** ./src/constants.ts ***!
  \**************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ABILITY_ARROW_MIN_LENGTH: () => (/* binding */ ABILITY_ARROW_MIN_LENGTH),\n/* harmony export */   ABILITY_BULLET_EFFECT_RADIUS: () => (/* binding */ ABILITY_BULLET_EFFECT_RADIUS),\n/* harmony export */   ABILITY_BULLET_FORCE_MULTIPLIER: () => (/* binding */ ABILITY_BULLET_FORCE_MULTIPLIER),\n/* harmony export */   AIStrategy: () => (/* binding */ AIStrategy),\n/* harmony export */   AI_AGGRESSIVE_HERO_MULTIPLIER: () => (/* binding */ AI_AGGRESSIVE_HERO_MULTIPLIER),\n/* harmony export */   AI_DEFENSE_COMMAND_INTERVAL_SEC: () => (/* binding */ AI_DEFENSE_COMMAND_INTERVAL_SEC),\n/* harmony export */   AI_DEFENSE_RADIUS_PX: () => (/* binding */ AI_DEFENSE_RADIUS_PX),\n/* harmony export */   AI_ECONOMIC_HERO_MULTIPLIER: () => (/* binding */ AI_ECONOMIC_HERO_MULTIPLIER),\n/* harmony export */   AI_HERO_COMMAND_INTERVAL_SEC: () => (/* binding */ AI_HERO_COMMAND_INTERVAL_SEC),\n/* harmony export */   AI_MAX_MIRRORS: () => (/* binding */ AI_MAX_MIRRORS),\n/* harmony export */   AI_MIRROR_ARC_SPACING_RAD: () => (/* binding */ AI_MIRROR_ARC_SPACING_RAD),\n/* harmony export */   AI_MIRROR_COMMAND_INTERVAL_SEC: () => (/* binding */ AI_MIRROR_COMMAND_INTERVAL_SEC),\n/* harmony export */   AI_MIRROR_PURCHASE_INTERVAL_SEC: () => (/* binding */ AI_MIRROR_PURCHASE_INTERVAL_SEC),\n/* harmony export */   AI_MIRROR_REPOSITION_THRESHOLD_PX: () => (/* binding */ AI_MIRROR_REPOSITION_THRESHOLD_PX),\n/* harmony export */   AI_MIRROR_SUN_DISTANCE_PX: () => (/* binding */ AI_MIRROR_SUN_DISTANCE_PX),\n/* harmony export */   AI_STRUCTURE_COMMAND_INTERVAL_SEC: () => (/* binding */ AI_STRUCTURE_COMMAND_INTERVAL_SEC),\n/* harmony export */   AI_STRUCTURE_PLACEMENT_ANGLE_STEP_RAD: () => (/* binding */ AI_STRUCTURE_PLACEMENT_ANGLE_STEP_RAD),\n/* harmony export */   AI_STRUCTURE_PLACEMENT_DISTANCE_PX: () => (/* binding */ AI_STRUCTURE_PLACEMENT_DISTANCE_PX),\n/* harmony export */   AI_WAVES_ATTACK_THRESHOLD: () => (/* binding */ AI_WAVES_ATTACK_THRESHOLD),\n/* harmony export */   AI_WAVES_HERO_MULTIPLIER: () => (/* binding */ AI_WAVES_HERO_MULTIPLIER),\n/* harmony export */   ASTEROID_MAX_SIZE: () => (/* binding */ ASTEROID_MAX_SIZE),\n/* harmony export */   ASTEROID_MIN_SIZE: () => (/* binding */ ASTEROID_MIN_SIZE),\n/* harmony export */   BEAM_ABILITY_BASE_DAMAGE: () => (/* binding */ BEAM_ABILITY_BASE_DAMAGE),\n/* harmony export */   BEAM_ABILITY_COOLDOWN: () => (/* binding */ BEAM_ABILITY_COOLDOWN),\n/* harmony export */   BEAM_ABILITY_DAMAGE_PER_DISTANCE: () => (/* binding */ BEAM_ABILITY_DAMAGE_PER_DISTANCE),\n/* harmony export */   BEAM_ABILITY_MAX_RANGE: () => (/* binding */ BEAM_ABILITY_MAX_RANGE),\n/* harmony export */   BEAM_ALONG_COMPONENT: () => (/* binding */ BEAM_ALONG_COMPONENT),\n/* harmony export */   BEAM_ATTACK_DAMAGE: () => (/* binding */ BEAM_ATTACK_DAMAGE),\n/* harmony export */   BEAM_ATTACK_RANGE: () => (/* binding */ BEAM_ATTACK_RANGE),\n/* harmony export */   BEAM_ATTACK_SPEED: () => (/* binding */ BEAM_ATTACK_SPEED),\n/* harmony export */   BEAM_EFFECT_RADIUS: () => (/* binding */ BEAM_EFFECT_RADIUS),\n/* harmony export */   BEAM_FORCE_STRENGTH: () => (/* binding */ BEAM_FORCE_STRENGTH),\n/* harmony export */   BEAM_MAX_HEALTH: () => (/* binding */ BEAM_MAX_HEALTH),\n/* harmony export */   BEAM_PERPENDICULAR_COMPONENT: () => (/* binding */ BEAM_PERPENDICULAR_COMPONENT),\n/* harmony export */   BORDER_FADE_WIDTH: () => (/* binding */ BORDER_FADE_WIDTH),\n/* harmony export */   BOUNCING_BULLET_LIFETIME: () => (/* binding */ BOUNCING_BULLET_LIFETIME),\n/* harmony export */   BOUNCING_BULLET_SPEED_MAX: () => (/* binding */ BOUNCING_BULLET_SPEED_MAX),\n/* harmony export */   BOUNCING_BULLET_SPEED_MIN: () => (/* binding */ BOUNCING_BULLET_SPEED_MIN),\n/* harmony export */   BUILDING_BUILD_TIME: () => (/* binding */ BUILDING_BUILD_TIME),\n/* harmony export */   BULLET_CASING_LIFETIME: () => (/* binding */ BULLET_CASING_LIFETIME),\n/* harmony export */   BULLET_CASING_SPEED_MAX: () => (/* binding */ BULLET_CASING_SPEED_MAX),\n/* harmony export */   BULLET_CASING_SPEED_MIN: () => (/* binding */ BULLET_CASING_SPEED_MIN),\n/* harmony export */   CASING_COLLISION_DAMPING: () => (/* binding */ CASING_COLLISION_DAMPING),\n/* harmony export */   CASING_SPACEDUST_COLLISION_DISTANCE: () => (/* binding */ CASING_SPACEDUST_COLLISION_DISTANCE),\n/* harmony export */   CASING_SPACEDUST_FORCE: () => (/* binding */ CASING_SPACEDUST_FORCE),\n/* harmony export */   CLICK_DRAG_THRESHOLD: () => (/* binding */ CLICK_DRAG_THRESHOLD),\n/* harmony export */   COUNTDOWN_DURATION: () => (/* binding */ COUNTDOWN_DURATION),\n/* harmony export */   DAGGER_ABILITY_COOLDOWN: () => (/* binding */ DAGGER_ABILITY_COOLDOWN),\n/* harmony export */   DAGGER_ABILITY_DAMAGE: () => (/* binding */ DAGGER_ABILITY_DAMAGE),\n/* harmony export */   DAGGER_ABILITY_RANGE: () => (/* binding */ DAGGER_ABILITY_RANGE),\n/* harmony export */   DAGGER_ATTACK_DAMAGE: () => (/* binding */ DAGGER_ATTACK_DAMAGE),\n/* harmony export */   DAGGER_ATTACK_RANGE: () => (/* binding */ DAGGER_ATTACK_RANGE),\n/* harmony export */   DAGGER_ATTACK_SPEED: () => (/* binding */ DAGGER_ATTACK_SPEED),\n/* harmony export */   DAGGER_CLOAK_OPACITY: () => (/* binding */ DAGGER_CLOAK_OPACITY),\n/* harmony export */   DAGGER_MAX_HEALTH: () => (/* binding */ DAGGER_MAX_HEALTH),\n/* harmony export */   DAGGER_VISIBILITY_DURATION: () => (/* binding */ DAGGER_VISIBILITY_DURATION),\n/* harmony export */   DEPLOYED_TURRET_ANIMATION_DURATION: () => (/* binding */ DEPLOYED_TURRET_ANIMATION_DURATION),\n/* harmony export */   DEPLOYED_TURRET_ANIMATION_FRAME_COUNT: () => (/* binding */ DEPLOYED_TURRET_ANIMATION_FRAME_COUNT),\n/* harmony export */   DEPLOYED_TURRET_ATTACK_DAMAGE: () => (/* binding */ DEPLOYED_TURRET_ATTACK_DAMAGE),\n/* harmony export */   DEPLOYED_TURRET_ATTACK_RANGE: () => (/* binding */ DEPLOYED_TURRET_ATTACK_RANGE),\n/* harmony export */   DEPLOYED_TURRET_ATTACK_SPEED: () => (/* binding */ DEPLOYED_TURRET_ATTACK_SPEED),\n/* harmony export */   DEPLOYED_TURRET_HEALTH_BAR_SIZE: () => (/* binding */ DEPLOYED_TURRET_HEALTH_BAR_SIZE),\n/* harmony export */   DEPLOYED_TURRET_MAX_HEALTH: () => (/* binding */ DEPLOYED_TURRET_MAX_HEALTH),\n/* harmony export */   DEPLOYED_TURRET_PIVOT_FROM_BOTTOM_PX: () => (/* binding */ DEPLOYED_TURRET_PIVOT_FROM_BOTTOM_PX),\n/* harmony export */   DEPLOYED_TURRET_SPRITE_HEIGHT_PX: () => (/* binding */ DEPLOYED_TURRET_SPRITE_HEIGHT_PX),\n/* harmony export */   DEPLOYED_TURRET_SPRITE_SCALE: () => (/* binding */ DEPLOYED_TURRET_SPRITE_SCALE),\n/* harmony export */   DRILLER_ABILITY_COOLDOWN: () => (/* binding */ DRILLER_ABILITY_COOLDOWN),\n/* harmony export */   DRILLER_ATTACK_DAMAGE: () => (/* binding */ DRILLER_ATTACK_DAMAGE),\n/* harmony export */   DRILLER_ATTACK_RANGE: () => (/* binding */ DRILLER_ATTACK_RANGE),\n/* harmony export */   DRILLER_ATTACK_SPEED: () => (/* binding */ DRILLER_ATTACK_SPEED),\n/* harmony export */   DRILLER_BUILDING_DAMAGE_MULTIPLIER: () => (/* binding */ DRILLER_BUILDING_DAMAGE_MULTIPLIER),\n/* harmony export */   DRILLER_DECELERATION: () => (/* binding */ DRILLER_DECELERATION),\n/* harmony export */   DRILLER_DRILL_DAMAGE: () => (/* binding */ DRILLER_DRILL_DAMAGE),\n/* harmony export */   DRILLER_DRILL_SPEED: () => (/* binding */ DRILLER_DRILL_SPEED),\n/* harmony export */   DRILLER_MAX_HEALTH: () => (/* binding */ DRILLER_MAX_HEALTH),\n/* harmony export */   DUST_FADE_TO_NORMAL_DELAY_MS: () => (/* binding */ DUST_FADE_TO_NORMAL_DELAY_MS),\n/* harmony export */   DUST_FADE_TO_SLIGHT_DELAY_MS: () => (/* binding */ DUST_FADE_TO_SLIGHT_DELAY_MS),\n/* harmony export */   DUST_FAST_MOVEMENT_THRESHOLD: () => (/* binding */ DUST_FAST_MOVEMENT_THRESHOLD),\n/* harmony export */   DUST_GLOW_STATE_FULL: () => (/* binding */ DUST_GLOW_STATE_FULL),\n/* harmony export */   DUST_GLOW_STATE_NORMAL: () => (/* binding */ DUST_GLOW_STATE_NORMAL),\n/* harmony export */   DUST_GLOW_STATE_SLIGHT: () => (/* binding */ DUST_GLOW_STATE_SLIGHT),\n/* harmony export */   DUST_GLOW_TRANSITION_SPEED_DOWN: () => (/* binding */ DUST_GLOW_TRANSITION_SPEED_DOWN),\n/* harmony export */   DUST_GLOW_TRANSITION_SPEED_UP: () => (/* binding */ DUST_GLOW_TRANSITION_SPEED_UP),\n/* harmony export */   DUST_MIN_VELOCITY: () => (/* binding */ DUST_MIN_VELOCITY),\n/* harmony export */   DUST_PARTICLE_SIZE: () => (/* binding */ DUST_PARTICLE_SIZE),\n/* harmony export */   DUST_PUSH_MIN_EFFECTIVE_SPEED_PX_PER_SEC: () => (/* binding */ DUST_PUSH_MIN_EFFECTIVE_SPEED_PX_PER_SEC),\n/* harmony export */   DUST_REPULSION_CELL_SIZE_PX: () => (/* binding */ DUST_REPULSION_CELL_SIZE_PX),\n/* harmony export */   DUST_REPULSION_RADIUS_PX: () => (/* binding */ DUST_REPULSION_RADIUS_PX),\n/* harmony export */   DUST_REPULSION_STRENGTH: () => (/* binding */ DUST_REPULSION_STRENGTH),\n/* harmony export */   DUST_SLOW_MOVEMENT_THRESHOLD: () => (/* binding */ DUST_SLOW_MOVEMENT_THRESHOLD),\n/* harmony export */   DUST_SPRITE_SCALE_FACTOR: () => (/* binding */ DUST_SPRITE_SCALE_FACTOR),\n/* harmony export */   FLUID_FORWARD_COMPONENT: () => (/* binding */ FLUID_FORWARD_COMPONENT),\n/* harmony export */   FLUID_MIN_DISTANCE: () => (/* binding */ FLUID_MIN_DISTANCE),\n/* harmony export */   FLUID_RADIAL_COMPONENT: () => (/* binding */ FLUID_RADIAL_COMPONENT),\n/* harmony export */   FORGE_CRUNCH_INTERVAL: () => (/* binding */ FORGE_CRUNCH_INTERVAL),\n/* harmony export */   FORGE_CRUNCH_SUCK_DURATION: () => (/* binding */ FORGE_CRUNCH_SUCK_DURATION),\n/* harmony export */   FORGE_CRUNCH_SUCK_FORCE: () => (/* binding */ FORGE_CRUNCH_SUCK_FORCE),\n/* harmony export */   FORGE_CRUNCH_SUCK_RADIUS: () => (/* binding */ FORGE_CRUNCH_SUCK_RADIUS),\n/* harmony export */   FORGE_CRUNCH_WAVE_DURATION: () => (/* binding */ FORGE_CRUNCH_WAVE_DURATION),\n/* harmony export */   FORGE_CRUNCH_WAVE_FORCE: () => (/* binding */ FORGE_CRUNCH_WAVE_FORCE),\n/* harmony export */   FORGE_CRUNCH_WAVE_RADIUS: () => (/* binding */ FORGE_CRUNCH_WAVE_RADIUS),\n/* harmony export */   FORGE_DUST_PUSH_FORCE_MULTIPLIER: () => (/* binding */ FORGE_DUST_PUSH_FORCE_MULTIPLIER),\n/* harmony export */   FORGE_DUST_PUSH_RADIUS_PX: () => (/* binding */ FORGE_DUST_PUSH_RADIUS_PX),\n/* harmony export */   FORGE_FLAME_ALPHA: () => (/* binding */ FORGE_FLAME_ALPHA),\n/* harmony export */   FORGE_FLAME_OFFSET_MULTIPLIER: () => (/* binding */ FORGE_FLAME_OFFSET_MULTIPLIER),\n/* harmony export */   FORGE_FLAME_ROTATION_SPEED_RAD_PER_SEC: () => (/* binding */ FORGE_FLAME_ROTATION_SPEED_RAD_PER_SEC),\n/* harmony export */   FORGE_FLAME_SIZE_MULTIPLIER: () => (/* binding */ FORGE_FLAME_SIZE_MULTIPLIER),\n/* harmony export */   FORGE_FLAME_WARMTH_FADE_PER_SEC: () => (/* binding */ FORGE_FLAME_WARMTH_FADE_PER_SEC),\n/* harmony export */   GRAVE_ATTACK_DAMAGE: () => (/* binding */ GRAVE_ATTACK_DAMAGE),\n/* harmony export */   GRAVE_ATTACK_RANGE: () => (/* binding */ GRAVE_ATTACK_RANGE),\n/* harmony export */   GRAVE_ATTACK_SPEED: () => (/* binding */ GRAVE_ATTACK_SPEED),\n/* harmony export */   GRAVE_HERO_ATTACK_RANGE_MULTIPLIER: () => (/* binding */ GRAVE_HERO_ATTACK_RANGE_MULTIPLIER),\n/* harmony export */   GRAVE_MAX_HEALTH: () => (/* binding */ GRAVE_MAX_HEALTH),\n/* harmony export */   GRAVE_NUM_PROJECTILES: () => (/* binding */ GRAVE_NUM_PROJECTILES),\n/* harmony export */   GRAVE_PROJECTILE_ATTRACTION_FORCE: () => (/* binding */ GRAVE_PROJECTILE_ATTRACTION_FORCE),\n/* harmony export */   GRAVE_PROJECTILE_EFFECT_RADIUS: () => (/* binding */ GRAVE_PROJECTILE_EFFECT_RADIUS),\n/* harmony export */   GRAVE_PROJECTILE_FORCE_MULTIPLIER: () => (/* binding */ GRAVE_PROJECTILE_FORCE_MULTIPLIER),\n/* harmony export */   GRAVE_PROJECTILE_HIT_DISTANCE: () => (/* binding */ GRAVE_PROJECTILE_HIT_DISTANCE),\n/* harmony export */   GRAVE_PROJECTILE_LAUNCH_SPEED: () => (/* binding */ GRAVE_PROJECTILE_LAUNCH_SPEED),\n/* harmony export */   GRAVE_PROJECTILE_MIN_SPEED: () => (/* binding */ GRAVE_PROJECTILE_MIN_SPEED),\n/* harmony export */   GRAVE_PROJECTILE_ORBIT_RADIUS: () => (/* binding */ GRAVE_PROJECTILE_ORBIT_RADIUS),\n/* harmony export */   GRAVE_PROJECTILE_TRAIL_LENGTH: () => (/* binding */ GRAVE_PROJECTILE_TRAIL_LENGTH),\n/* harmony export */   HERO_ATTACK_RANGE_ALPHA: () => (/* binding */ HERO_ATTACK_RANGE_ALPHA),\n/* harmony export */   HERO_BUTTON_DISTANCE_PX: () => (/* binding */ HERO_BUTTON_DISTANCE_PX),\n/* harmony export */   HERO_BUTTON_RADIUS_PX: () => (/* binding */ HERO_BUTTON_RADIUS_PX),\n/* harmony export */   HERO_PRODUCTION_TIME_SEC: () => (/* binding */ HERO_PRODUCTION_TIME_SEC),\n/* harmony export */   HERO_UNIT_COST: () => (/* binding */ HERO_UNIT_COST),\n/* harmony export */   INFLUENCE_BALL_ABILITY_COOLDOWN: () => (/* binding */ INFLUENCE_BALL_ABILITY_COOLDOWN),\n/* harmony export */   INFLUENCE_BALL_ATTACK_DAMAGE: () => (/* binding */ INFLUENCE_BALL_ATTACK_DAMAGE),\n/* harmony export */   INFLUENCE_BALL_ATTACK_RANGE: () => (/* binding */ INFLUENCE_BALL_ATTACK_RANGE),\n/* harmony export */   INFLUENCE_BALL_ATTACK_SPEED: () => (/* binding */ INFLUENCE_BALL_ATTACK_SPEED),\n/* harmony export */   INFLUENCE_BALL_DURATION: () => (/* binding */ INFLUENCE_BALL_DURATION),\n/* harmony export */   INFLUENCE_BALL_EFFECT_RADIUS: () => (/* binding */ INFLUENCE_BALL_EFFECT_RADIUS),\n/* harmony export */   INFLUENCE_BALL_EXPLOSION_RADIUS: () => (/* binding */ INFLUENCE_BALL_EXPLOSION_RADIUS),\n/* harmony export */   INFLUENCE_BALL_FORCE_MULTIPLIER: () => (/* binding */ INFLUENCE_BALL_FORCE_MULTIPLIER),\n/* harmony export */   INFLUENCE_BALL_MAX_HEALTH: () => (/* binding */ INFLUENCE_BALL_MAX_HEALTH),\n/* harmony export */   INFLUENCE_BALL_PROJECTILE_SPEED: () => (/* binding */ INFLUENCE_BALL_PROJECTILE_SPEED),\n/* harmony export */   INFLUENCE_RADIUS: () => (/* binding */ INFLUENCE_RADIUS),\n/* harmony export */   MAP_PLAYABLE_BOUNDARY: () => (/* binding */ MAP_PLAYABLE_BOUNDARY),\n/* harmony export */   MAP_SIZE: () => (/* binding */ MAP_SIZE),\n/* harmony export */   MARINE_ABILITY_BULLET_COUNT: () => (/* binding */ MARINE_ABILITY_BULLET_COUNT),\n/* harmony export */   MARINE_ABILITY_BULLET_DAMAGE: () => (/* binding */ MARINE_ABILITY_BULLET_DAMAGE),\n/* harmony export */   MARINE_ABILITY_BULLET_LIFETIME: () => (/* binding */ MARINE_ABILITY_BULLET_LIFETIME),\n/* harmony export */   MARINE_ABILITY_BULLET_SPEED: () => (/* binding */ MARINE_ABILITY_BULLET_SPEED),\n/* harmony export */   MARINE_ABILITY_COOLDOWN: () => (/* binding */ MARINE_ABILITY_COOLDOWN),\n/* harmony export */   MARINE_ABILITY_SPREAD_ANGLE: () => (/* binding */ MARINE_ABILITY_SPREAD_ANGLE),\n/* harmony export */   MARINE_ATTACK_DAMAGE: () => (/* binding */ MARINE_ATTACK_DAMAGE),\n/* harmony export */   MARINE_ATTACK_RANGE: () => (/* binding */ MARINE_ATTACK_RANGE),\n/* harmony export */   MARINE_ATTACK_SPEED: () => (/* binding */ MARINE_ATTACK_SPEED),\n/* harmony export */   MARINE_MAX_HEALTH: () => (/* binding */ MARINE_MAX_HEALTH),\n/* harmony export */   MAX_RAY_DISTANCE: () => (/* binding */ MAX_RAY_DISTANCE),\n/* harmony export */   MINIGUN_ATTACK_DAMAGE: () => (/* binding */ MINIGUN_ATTACK_DAMAGE),\n/* harmony export */   MINIGUN_ATTACK_RANGE: () => (/* binding */ MINIGUN_ATTACK_RANGE),\n/* harmony export */   MINIGUN_ATTACK_SPEED: () => (/* binding */ MINIGUN_ATTACK_SPEED),\n/* harmony export */   MINIGUN_COST: () => (/* binding */ MINIGUN_COST),\n/* harmony export */   MINIGUN_MAX_HEALTH: () => (/* binding */ MINIGUN_MAX_HEALTH),\n/* harmony export */   MINIGUN_RADIUS: () => (/* binding */ MINIGUN_RADIUS),\n/* harmony export */   MINION_PROJECTILE_EFFECT_RADIUS: () => (/* binding */ MINION_PROJECTILE_EFFECT_RADIUS),\n/* harmony export */   MINION_PROJECTILE_FORCE_MULTIPLIER: () => (/* binding */ MINION_PROJECTILE_FORCE_MULTIPLIER),\n/* harmony export */   MIN_WAYPOINT_DISTANCE: () => (/* binding */ MIN_WAYPOINT_DISTANCE),\n/* harmony export */   MIRROR_ACTIVE_GLOW_RADIUS: () => (/* binding */ MIRROR_ACTIVE_GLOW_RADIUS),\n/* harmony export */   MIRROR_COUNTDOWN_DEPLOY_DISTANCE: () => (/* binding */ MIRROR_COUNTDOWN_DEPLOY_DISTANCE),\n/* harmony export */   MIRROR_DUST_PUSH_FORCE_MULTIPLIER: () => (/* binding */ MIRROR_DUST_PUSH_FORCE_MULTIPLIER),\n/* harmony export */   MIRROR_DUST_PUSH_RADIUS_PX: () => (/* binding */ MIRROR_DUST_PUSH_RADIUS_PX),\n/* harmony export */   MIRROR_MAX_GLOW_DISTANCE: () => (/* binding */ MIRROR_MAX_GLOW_DISTANCE),\n/* harmony export */   MIRROR_MAX_HEALTH: () => (/* binding */ MIRROR_MAX_HEALTH),\n/* harmony export */   MIRROR_PROXIMITY_MULTIPLIER: () => (/* binding */ MIRROR_PROXIMITY_MULTIPLIER),\n/* harmony export */   MIRROR_REGEN_PER_SEC: () => (/* binding */ MIRROR_REGEN_PER_SEC),\n/* harmony export */   MORTAR_ABILITY_COOLDOWN: () => (/* binding */ MORTAR_ABILITY_COOLDOWN),\n/* harmony export */   MORTAR_ATTACK_DAMAGE: () => (/* binding */ MORTAR_ATTACK_DAMAGE),\n/* harmony export */   MORTAR_ATTACK_RANGE: () => (/* binding */ MORTAR_ATTACK_RANGE),\n/* harmony export */   MORTAR_ATTACK_SPEED: () => (/* binding */ MORTAR_ATTACK_SPEED),\n/* harmony export */   MORTAR_DETECTION_CONE_ANGLE: () => (/* binding */ MORTAR_DETECTION_CONE_ANGLE),\n/* harmony export */   MORTAR_MAX_HEALTH: () => (/* binding */ MORTAR_MAX_HEALTH),\n/* harmony export */   MORTAR_PROJECTILE_SPEED: () => (/* binding */ MORTAR_PROJECTILE_SPEED),\n/* harmony export */   MORTAR_SPLASH_DAMAGE_FALLOFF: () => (/* binding */ MORTAR_SPLASH_DAMAGE_FALLOFF),\n/* harmony export */   MORTAR_SPLASH_RADIUS: () => (/* binding */ MORTAR_SPLASH_RADIUS),\n/* harmony export */   MUZZLE_FLASH_DURATION: () => (/* binding */ MUZZLE_FLASH_DURATION),\n/* harmony export */   PARTICLE_SCATTER_FORCE: () => (/* binding */ PARTICLE_SCATTER_FORCE),\n/* harmony export */   PARTICLE_SCATTER_RADIUS: () => (/* binding */ PARTICLE_SCATTER_RADIUS),\n/* harmony export */   PATH_WAYPOINT_ARRIVAL_MULTIPLIER: () => (/* binding */ PATH_WAYPOINT_ARRIVAL_MULTIPLIER),\n/* harmony export */   PLAYER_1_COLOR: () => (/* binding */ PLAYER_1_COLOR),\n/* harmony export */   PLAYER_2_COLOR: () => (/* binding */ PLAYER_2_COLOR),\n/* harmony export */   PREIST_ABILITY_COOLDOWN: () => (/* binding */ PREIST_ABILITY_COOLDOWN),\n/* harmony export */   PREIST_ATTACK_DAMAGE: () => (/* binding */ PREIST_ATTACK_DAMAGE),\n/* harmony export */   PREIST_ATTACK_RANGE: () => (/* binding */ PREIST_ATTACK_RANGE),\n/* harmony export */   PREIST_ATTACK_SPEED: () => (/* binding */ PREIST_ATTACK_SPEED),\n/* harmony export */   PREIST_HEALING_BOMB_EXPLOSION_RADIUS: () => (/* binding */ PREIST_HEALING_BOMB_EXPLOSION_RADIUS),\n/* harmony export */   PREIST_HEALING_BOMB_MAX_RANGE: () => (/* binding */ PREIST_HEALING_BOMB_MAX_RANGE),\n/* harmony export */   PREIST_HEALING_BOMB_PARTICLE_COUNT: () => (/* binding */ PREIST_HEALING_BOMB_PARTICLE_COUNT),\n/* harmony export */   PREIST_HEALING_BOMB_PARTICLE_HEALING: () => (/* binding */ PREIST_HEALING_BOMB_PARTICLE_HEALING),\n/* harmony export */   PREIST_HEALING_BOMB_PARTICLE_LIFETIME: () => (/* binding */ PREIST_HEALING_BOMB_PARTICLE_LIFETIME),\n/* harmony export */   PREIST_HEALING_BOMB_PARTICLE_SPEED: () => (/* binding */ PREIST_HEALING_BOMB_PARTICLE_SPEED),\n/* harmony export */   PREIST_HEALING_BOMB_SPEED: () => (/* binding */ PREIST_HEALING_BOMB_SPEED),\n/* harmony export */   PREIST_HEALING_PER_SECOND: () => (/* binding */ PREIST_HEALING_PER_SECOND),\n/* harmony export */   PREIST_HEALING_RANGE: () => (/* binding */ PREIST_HEALING_RANGE),\n/* harmony export */   PREIST_MAX_HEALTH: () => (/* binding */ PREIST_MAX_HEALTH),\n/* harmony export */   PREIST_NUM_BEAMS: () => (/* binding */ PREIST_NUM_BEAMS),\n/* harmony export */   PREIST_TARGET_LOCK_DURATION: () => (/* binding */ PREIST_TARGET_LOCK_DURATION),\n/* harmony export */   PRODUCTION_BUTTON_WAVE_MAX_RADIUS_PX: () => (/* binding */ PRODUCTION_BUTTON_WAVE_MAX_RADIUS_PX),\n/* harmony export */   PRODUCTION_BUTTON_WAVE_PROGRESS_PER_FRAME: () => (/* binding */ PRODUCTION_BUTTON_WAVE_PROGRESS_PER_FRAME),\n/* harmony export */   RAYTRACING_NUM_RAYS: () => (/* binding */ RAYTRACING_NUM_RAYS),\n/* harmony export */   RAY_ABILITY_COOLDOWN: () => (/* binding */ RAY_ABILITY_COOLDOWN),\n/* harmony export */   RAY_ATTACK_DAMAGE: () => (/* binding */ RAY_ATTACK_DAMAGE),\n/* harmony export */   RAY_ATTACK_RANGE: () => (/* binding */ RAY_ATTACK_RANGE),\n/* harmony export */   RAY_ATTACK_SPEED: () => (/* binding */ RAY_ATTACK_SPEED),\n/* harmony export */   RAY_BEAM_DAMAGE: () => (/* binding */ RAY_BEAM_DAMAGE),\n/* harmony export */   RAY_BEAM_MAX_BOUNCES: () => (/* binding */ RAY_BEAM_MAX_BOUNCES),\n/* harmony export */   RAY_BEAM_WIDTH: () => (/* binding */ RAY_BEAM_WIDTH),\n/* harmony export */   RAY_MAX_HEALTH: () => (/* binding */ RAY_MAX_HEALTH),\n/* harmony export */   SHADE_OPACITY: () => (/* binding */ SHADE_OPACITY),\n/* harmony export */   SHADOW_LENGTH: () => (/* binding */ SHADOW_LENGTH),\n/* harmony export */   SOLAR_MIRROR_COST: () => (/* binding */ SOLAR_MIRROR_COST),\n/* harmony export */   SPACE_DUST_PARTICLE_COUNT: () => (/* binding */ SPACE_DUST_PARTICLE_COUNT),\n/* harmony export */   STARLING_ATTACK_DAMAGE: () => (/* binding */ STARLING_ATTACK_DAMAGE),\n/* harmony export */   STARLING_ATTACK_RANGE: () => (/* binding */ STARLING_ATTACK_RANGE),\n/* harmony export */   STARLING_ATTACK_SPEED: () => (/* binding */ STARLING_ATTACK_SPEED),\n/* harmony export */   STARLING_COLLISION_RADIUS_PX: () => (/* binding */ STARLING_COLLISION_RADIUS_PX),\n/* harmony export */   STARLING_COST_PER_ENERGY: () => (/* binding */ STARLING_COST_PER_ENERGY),\n/* harmony export */   STARLING_DUST_PUSH_FORCE_MULTIPLIER: () => (/* binding */ STARLING_DUST_PUSH_FORCE_MULTIPLIER),\n/* harmony export */   STARLING_DUST_PUSH_RADIUS_PX: () => (/* binding */ STARLING_DUST_PUSH_RADIUS_PX),\n/* harmony export */   STARLING_EXPLORATION_CHANGE_INTERVAL: () => (/* binding */ STARLING_EXPLORATION_CHANGE_INTERVAL),\n/* harmony export */   STARLING_LASER_IMPACT_PARTICLES: () => (/* binding */ STARLING_LASER_IMPACT_PARTICLES),\n/* harmony export */   STARLING_LASER_PARTICLE_LIFETIME: () => (/* binding */ STARLING_LASER_PARTICLE_LIFETIME),\n/* harmony export */   STARLING_LASER_PARTICLE_SPEED: () => (/* binding */ STARLING_LASER_PARTICLE_SPEED),\n/* harmony export */   STARLING_MAX_HEALTH: () => (/* binding */ STARLING_MAX_HEALTH),\n/* harmony export */   STARLING_MOVE_SPEED: () => (/* binding */ STARLING_MOVE_SPEED),\n/* harmony export */   STARLING_PROJECTILE_HIT_RADIUS_PX: () => (/* binding */ STARLING_PROJECTILE_HIT_RADIUS_PX),\n/* harmony export */   STARLING_PROJECTILE_MAX_RANGE_PX: () => (/* binding */ STARLING_PROJECTILE_MAX_RANGE_PX),\n/* harmony export */   STARLING_PROJECTILE_SPEED: () => (/* binding */ STARLING_PROJECTILE_SPEED),\n/* harmony export */   STARLING_SPAWN_INTERVAL: () => (/* binding */ STARLING_SPAWN_INTERVAL),\n/* harmony export */   STARLING_SPRITE_ROTATION_OFFSET_RAD: () => (/* binding */ STARLING_SPRITE_ROTATION_OFFSET_RAD),\n/* harmony export */   STARLING_SPRITE_SCALE_FACTOR: () => (/* binding */ STARLING_SPRITE_SCALE_FACTOR),\n/* harmony export */   STAR_LAYER_CONFIGS: () => (/* binding */ STAR_LAYER_CONFIGS),\n/* harmony export */   STAR_WRAP_SIZE: () => (/* binding */ STAR_WRAP_SIZE),\n/* harmony export */   STATE_HASH_TICK_INTERVAL: () => (/* binding */ STATE_HASH_TICK_INTERVAL),\n/* harmony export */   STELLAR_FORGE_MAX_HEALTH: () => (/* binding */ STELLAR_FORGE_MAX_HEALTH),\n/* harmony export */   STRATEGIC_ASTEROID_DISTANCE: () => (/* binding */ STRATEGIC_ASTEROID_DISTANCE),\n/* harmony export */   STRATEGIC_ASTEROID_SIZE: () => (/* binding */ STRATEGIC_ASTEROID_SIZE),\n/* harmony export */   SUBSIDIARY_FACTORY_ATTACK_DAMAGE: () => (/* binding */ SUBSIDIARY_FACTORY_ATTACK_DAMAGE),\n/* harmony export */   SUBSIDIARY_FACTORY_ATTACK_RANGE: () => (/* binding */ SUBSIDIARY_FACTORY_ATTACK_RANGE),\n/* harmony export */   SUBSIDIARY_FACTORY_ATTACK_SPEED: () => (/* binding */ SUBSIDIARY_FACTORY_ATTACK_SPEED),\n/* harmony export */   SUBSIDIARY_FACTORY_COST: () => (/* binding */ SUBSIDIARY_FACTORY_COST),\n/* harmony export */   SUBSIDIARY_FACTORY_MAX_HEALTH: () => (/* binding */ SUBSIDIARY_FACTORY_MAX_HEALTH),\n/* harmony export */   SUBSIDIARY_FACTORY_PRODUCTION_INTERVAL: () => (/* binding */ SUBSIDIARY_FACTORY_PRODUCTION_INTERVAL),\n/* harmony export */   SUBSIDIARY_FACTORY_RADIUS: () => (/* binding */ SUBSIDIARY_FACTORY_RADIUS),\n/* harmony export */   SWIPE_ARROW_SIZE: () => (/* binding */ SWIPE_ARROW_SIZE),\n/* harmony export */   SWIPE_EFFECT_SPEED: () => (/* binding */ SWIPE_EFFECT_SPEED),\n/* harmony export */   SWIRLER_ATTACK_DAMAGE: () => (/* binding */ SWIRLER_ATTACK_DAMAGE),\n/* harmony export */   SWIRLER_ATTACK_RANGE: () => (/* binding */ SWIRLER_ATTACK_RANGE),\n/* harmony export */   SWIRLER_ATTACK_SPEED: () => (/* binding */ SWIRLER_ATTACK_SPEED),\n/* harmony export */   SWIRLER_COST: () => (/* binding */ SWIRLER_COST),\n/* harmony export */   SWIRLER_DUST_ORBIT_SPEED_BASE: () => (/* binding */ SWIRLER_DUST_ORBIT_SPEED_BASE),\n/* harmony export */   SWIRLER_DUST_SPEED_MULTIPLIER: () => (/* binding */ SWIRLER_DUST_SPEED_MULTIPLIER),\n/* harmony export */   SWIRLER_GROWTH_RATE_PER_SEC: () => (/* binding */ SWIRLER_GROWTH_RATE_PER_SEC),\n/* harmony export */   SWIRLER_INFLUENCE_RADIUS: () => (/* binding */ SWIRLER_INFLUENCE_RADIUS),\n/* harmony export */   SWIRLER_INITIAL_RADIUS_MULTIPLIER: () => (/* binding */ SWIRLER_INITIAL_RADIUS_MULTIPLIER),\n/* harmony export */   SWIRLER_MAX_HEALTH: () => (/* binding */ SWIRLER_MAX_HEALTH),\n/* harmony export */   SWIRLER_MIN_INFLUENCE_RADIUS: () => (/* binding */ SWIRLER_MIN_INFLUENCE_RADIUS),\n/* harmony export */   SWIRLER_RADIUS: () => (/* binding */ SWIRLER_RADIUS),\n/* harmony export */   SWIRLER_SHRINK_BASE_RATE: () => (/* binding */ SWIRLER_SHRINK_BASE_RATE),\n/* harmony export */   SWIRLER_SHRINK_DAMAGE_MULTIPLIER: () => (/* binding */ SWIRLER_SHRINK_DAMAGE_MULTIPLIER),\n/* harmony export */   TANK_ABILITY_COOLDOWN: () => (/* binding */ TANK_ABILITY_COOLDOWN),\n/* harmony export */   TANK_ATTACK_DAMAGE: () => (/* binding */ TANK_ATTACK_DAMAGE),\n/* harmony export */   TANK_ATTACK_RANGE: () => (/* binding */ TANK_ATTACK_RANGE),\n/* harmony export */   TANK_ATTACK_SPEED: () => (/* binding */ TANK_ATTACK_SPEED),\n/* harmony export */   TANK_COLLISION_RADIUS_PX: () => (/* binding */ TANK_COLLISION_RADIUS_PX),\n/* harmony export */   TANK_DEFENSE: () => (/* binding */ TANK_DEFENSE),\n/* harmony export */   TANK_MAX_HEALTH: () => (/* binding */ TANK_MAX_HEALTH),\n/* harmony export */   TANK_SHIELD_RADIUS: () => (/* binding */ TANK_SHIELD_RADIUS),\n/* harmony export */   TANK_STUN_DURATION: () => (/* binding */ TANK_STUN_DURATION),\n/* harmony export */   TANK_WAVE_ANGLE: () => (/* binding */ TANK_WAVE_ANGLE),\n/* harmony export */   TANK_WAVE_RANGE: () => (/* binding */ TANK_WAVE_RANGE),\n/* harmony export */   TANK_WAVE_SPEED: () => (/* binding */ TANK_WAVE_SPEED),\n/* harmony export */   TANK_WAVE_WIDTH: () => (/* binding */ TANK_WAVE_WIDTH),\n/* harmony export */   TAP_EFFECT_MAX_RADIUS: () => (/* binding */ TAP_EFFECT_MAX_RADIUS),\n/* harmony export */   TAP_EFFECT_SPEED: () => (/* binding */ TAP_EFFECT_SPEED),\n/* harmony export */   TURRET_DEPLOYER_ABILITY_COOLDOWN: () => (/* binding */ TURRET_DEPLOYER_ABILITY_COOLDOWN),\n/* harmony export */   TURRET_DEPLOYER_ATTACK_DAMAGE: () => (/* binding */ TURRET_DEPLOYER_ATTACK_DAMAGE),\n/* harmony export */   TURRET_DEPLOYER_ATTACK_RANGE: () => (/* binding */ TURRET_DEPLOYER_ATTACK_RANGE),\n/* harmony export */   TURRET_DEPLOYER_ATTACK_SPEED: () => (/* binding */ TURRET_DEPLOYER_ATTACK_SPEED),\n/* harmony export */   TURRET_DEPLOYER_MAX_HEALTH: () => (/* binding */ TURRET_DEPLOYER_MAX_HEALTH),\n/* harmony export */   TURRET_PROJECTILE_SPEED: () => (/* binding */ TURRET_PROJECTILE_SPEED),\n/* harmony export */   UI_BACKGROUND_COLOR: () => (/* binding */ UI_BACKGROUND_COLOR),\n/* harmony export */   UNIT_ARRIVAL_THRESHOLD: () => (/* binding */ UNIT_ARRIVAL_THRESHOLD),\n/* harmony export */   UNIT_ASTEROID_AVOIDANCE_BUFFER_PX: () => (/* binding */ UNIT_ASTEROID_AVOIDANCE_BUFFER_PX),\n/* harmony export */   UNIT_ASTEROID_AVOIDANCE_LOOKAHEAD_PX: () => (/* binding */ UNIT_ASTEROID_AVOIDANCE_LOOKAHEAD_PX),\n/* harmony export */   UNIT_ASTEROID_AVOIDANCE_STRENGTH: () => (/* binding */ UNIT_ASTEROID_AVOIDANCE_STRENGTH),\n/* harmony export */   UNIT_AVOIDANCE_RANGE_PX: () => (/* binding */ UNIT_AVOIDANCE_RANGE_PX),\n/* harmony export */   UNIT_AVOIDANCE_STRENGTH: () => (/* binding */ UNIT_AVOIDANCE_STRENGTH),\n/* harmony export */   UNIT_HERO_AVOIDANCE_MULTIPLIER: () => (/* binding */ UNIT_HERO_AVOIDANCE_MULTIPLIER),\n/* harmony export */   UNIT_MINION_YIELD_MULTIPLIER: () => (/* binding */ UNIT_MINION_YIELD_MULTIPLIER),\n/* harmony export */   UNIT_MOVE_SPEED: () => (/* binding */ UNIT_MOVE_SPEED),\n/* harmony export */   UNIT_PATH_DRAW_RADIUS: () => (/* binding */ UNIT_PATH_DRAW_RADIUS),\n/* harmony export */   UNIT_RADIUS_PX: () => (/* binding */ UNIT_RADIUS_PX),\n/* harmony export */   UNIT_STRUCTURE_STANDOFF_PX: () => (/* binding */ UNIT_STRUCTURE_STANDOFF_PX),\n/* harmony export */   UNIT_TURN_SPEED_RAD_PER_SEC: () => (/* binding */ UNIT_TURN_SPEED_RAD_PER_SEC),\n/* harmony export */   VISIBILITY_PROXIMITY_RANGE: () => (/* binding */ VISIBILITY_PROXIMITY_RANGE),\n/* harmony export */   WARP_GATE_BUTTON_HIT_RADIUS_PX: () => (/* binding */ WARP_GATE_BUTTON_HIT_RADIUS_PX),\n/* harmony export */   WARP_GATE_BUTTON_OFFSET: () => (/* binding */ WARP_GATE_BUTTON_OFFSET),\n/* harmony export */   WARP_GATE_BUTTON_RADIUS: () => (/* binding */ WARP_GATE_BUTTON_RADIUS),\n/* harmony export */   WARP_GATE_CHARGE_TIME: () => (/* binding */ WARP_GATE_CHARGE_TIME),\n/* harmony export */   WARP_GATE_INITIAL_DELAY: () => (/* binding */ WARP_GATE_INITIAL_DELAY),\n/* harmony export */   WARP_GATE_RADIUS: () => (/* binding */ WARP_GATE_RADIUS),\n/* harmony export */   WARP_GATE_SHOCKWAVE_MAX_RADIUS_PX: () => (/* binding */ WARP_GATE_SHOCKWAVE_MAX_RADIUS_PX),\n/* harmony export */   WARP_GATE_SHOCKWAVE_PROGRESS_PER_FRAME: () => (/* binding */ WARP_GATE_SHOCKWAVE_PROGRESS_PER_FRAME),\n/* harmony export */   WARP_GATE_SPIRAL_FORCE_RADIAL: () => (/* binding */ WARP_GATE_SPIRAL_FORCE_RADIAL),\n/* harmony export */   WARP_GATE_SPIRAL_FORCE_TANGENT: () => (/* binding */ WARP_GATE_SPIRAL_FORCE_TANGENT),\n/* harmony export */   WARP_GATE_SPIRAL_MIN_DISTANCE: () => (/* binding */ WARP_GATE_SPIRAL_MIN_DISTANCE),\n/* harmony export */   WARP_GATE_SPIRAL_RADIUS: () => (/* binding */ WARP_GATE_SPIRAL_RADIUS)\n/* harmony export */ });\n/**\n * Game constants shared across modules\n */\n// Influence and particle constants\nconst INFLUENCE_RADIUS = 300;\nconst PLAYER_1_COLOR = '#0066FF';\nconst PLAYER_2_COLOR = '#FF0000';\n// Warp gate constants\nconst WARP_GATE_CHARGE_TIME = 6.0; // Total seconds to complete\nconst WARP_GATE_INITIAL_DELAY = 1.0; // Seconds before warp gate starts\nconst WARP_GATE_SPIRAL_RADIUS = 200;\nconst WARP_GATE_SPIRAL_MIN_DISTANCE = 5;\nconst WARP_GATE_SPIRAL_FORCE_RADIAL = 50;\nconst WARP_GATE_SPIRAL_FORCE_TANGENT = 20;\nconst WARP_GATE_RADIUS = 50;\nconst WARP_GATE_BUTTON_RADIUS = 28; // Match hero button size\nconst WARP_GATE_BUTTON_OFFSET = 30;\nconst WARP_GATE_BUTTON_HIT_RADIUS_PX = 40;\nconst WARP_GATE_SHOCKWAVE_MAX_RADIUS_PX = 220;\nconst WARP_GATE_SHOCKWAVE_PROGRESS_PER_FRAME = 0.06;\n// Particle scatter constants\nconst PARTICLE_SCATTER_RADIUS = 150;\nconst PARTICLE_SCATTER_FORCE = 200;\n// Fluid simulation constants for particle displacement\nconst ABILITY_BULLET_EFFECT_RADIUS = 30;\nconst ABILITY_BULLET_FORCE_MULTIPLIER = 0.5;\nconst MINION_PROJECTILE_EFFECT_RADIUS = 25;\nconst MINION_PROJECTILE_FORCE_MULTIPLIER = 0.4;\nconst GRAVE_PROJECTILE_EFFECT_RADIUS = 20;\nconst GRAVE_PROJECTILE_FORCE_MULTIPLIER = 0.4;\nconst INFLUENCE_BALL_EFFECT_RADIUS = 35;\nconst INFLUENCE_BALL_FORCE_MULTIPLIER = 0.5;\nconst BEAM_EFFECT_RADIUS = 40;\nconst BEAM_FORCE_STRENGTH = 300;\nconst FLUID_FORWARD_COMPONENT = 0.6; // Forward push component for moving objects\nconst FLUID_RADIAL_COMPONENT = 0.4; // Radial displacement component for moving objects\nconst BEAM_ALONG_COMPONENT = 0.7; // Along beam direction component\nconst BEAM_PERPENDICULAR_COMPONENT = 0.3; // Perpendicular push component for beams\nconst FLUID_MIN_DISTANCE = 0.1; // Minimum distance to avoid division by zero in fluid calculations\n// Rendering constants\nconst DUST_PARTICLE_SIZE = 1;\nconst SPACE_DUST_PARTICLE_COUNT = 3000;\nconst DUST_MIN_VELOCITY = 0.08;\nconst DUST_REPULSION_RADIUS_PX = 28;\nconst DUST_REPULSION_CELL_SIZE_PX = 32;\nconst DUST_REPULSION_STRENGTH = 14;\nconst DUST_PUSH_MIN_EFFECTIVE_SPEED_PX_PER_SEC = 3;\nconst MIRROR_DUST_PUSH_RADIUS_PX = 110;\nconst MIRROR_DUST_PUSH_FORCE_MULTIPLIER = 1.1;\nconst FORGE_DUST_PUSH_RADIUS_PX = 160;\nconst FORGE_DUST_PUSH_FORCE_MULTIPLIER = 0.9;\nconst STARLING_DUST_PUSH_RADIUS_PX = 50;\nconst STARLING_DUST_PUSH_FORCE_MULTIPLIER = 0.5;\n// Sprite scaling constants\nconst DUST_SPRITE_SCALE_FACTOR = 3;\nconst STARLING_SPRITE_SCALE_FACTOR = 6;\nconst STARLING_SPRITE_ROTATION_OFFSET_RAD = Math.PI / 2;\n// Space dust glow constants\nconst DUST_GLOW_STATE_NORMAL = 0;\nconst DUST_GLOW_STATE_SLIGHT = 1;\nconst DUST_GLOW_STATE_FULL = 2;\nconst DUST_FAST_MOVEMENT_THRESHOLD = 5;\nconst DUST_SLOW_MOVEMENT_THRESHOLD = 1;\nconst DUST_FADE_TO_NORMAL_DELAY_MS = 2000;\nconst DUST_FADE_TO_SLIGHT_DELAY_MS = 1000;\nconst DUST_GLOW_TRANSITION_SPEED_UP = 3.0;\nconst DUST_GLOW_TRANSITION_SPEED_DOWN = 0.5;\n// Star background parallax constants\nconst STAR_WRAP_SIZE = 4000; // Size of the star field wrapping area\nconst STAR_LAYER_CONFIGS = [\n    { count: 200, parallaxFactor: 0.1, sizeRange: [0.5, 1.0] }, // Far background\n    { count: 150, parallaxFactor: 0.2, sizeRange: [0.8, 1.5] }, // Mid-far\n    { count: 100, parallaxFactor: 0.35, sizeRange: [1.0, 2.0] }, // Mid-near\n    { count: 50, parallaxFactor: 0.5, sizeRange: [1.5, 2.5] } // Near foreground\n];\n// Raytracing constants\nconst RAYTRACING_NUM_RAYS = 64; // Number of rays to cast per sun\nconst MAX_RAY_DISTANCE = 2000; // Maximum distance for ray casting\nconst SHADOW_LENGTH = 1500; // Length of shadows cast by asteroids (increased for strategic asteroids)\n// Visibility system constants\nconst VISIBILITY_PROXIMITY_RANGE = 150; // Range at which units can see enemies in shade\nconst SHADE_OPACITY = 0.3; // Opacity for rendering objects in shade (0-1)\nconst STRATEGIC_ASTEROID_SIZE = 120; // Size of strategic asteroids that block visibility\nconst STRATEGIC_ASTEROID_DISTANCE = 250; // Distance from sun center for strategic asteroids\nconst ASTEROID_MIN_SIZE = 30;\nconst ASTEROID_MAX_SIZE = STRATEGIC_ASTEROID_SIZE;\n// Map boundary constants\nconst MAP_SIZE = 2000; // Total map size in world units (centered at 0,0)\nconst BORDER_FADE_WIDTH = 150; // Width of dark border fade zone\nconst MAP_PLAYABLE_BOUNDARY = (MAP_SIZE / 2) - BORDER_FADE_WIDTH; // Units cannot move beyond this boundary\n// Countdown and mirror constants\nconst COUNTDOWN_DURATION = 3.0; // Countdown duration in seconds\nconst MIRROR_COUNTDOWN_DEPLOY_DISTANCE = 150; // Distance mirrors move from base during countdown\nconst MIRROR_MAX_HEALTH = 100;\nconst MIRROR_REGEN_PER_SEC = 2;\n// Marine unit constants\nconst MARINE_MAX_HEALTH = 100;\nconst MARINE_ATTACK_RANGE = 300;\nconst MARINE_ATTACK_DAMAGE = 10;\nconst MARINE_ATTACK_SPEED = 5; // Attacks per second (fast shooting)\n// Grave unit constants\nconst GRAVE_MAX_HEALTH = 150;\nconst GRAVE_ATTACK_RANGE = 400;\nconst GRAVE_HERO_ATTACK_RANGE_MULTIPLIER = 0.25; // Hero Grave units have 75% reduced attack range\nconst GRAVE_ATTACK_DAMAGE = 15;\nconst GRAVE_ATTACK_SPEED = 2; // Attacks per second (projectile launch rate)\nconst GRAVE_NUM_PROJECTILES = 5;\nconst GRAVE_PROJECTILE_ORBIT_RADIUS = 50;\nconst GRAVE_PROJECTILE_MIN_SPEED = 80; // Minimum speed to keep orbiting\nconst GRAVE_PROJECTILE_ATTRACTION_FORCE = 300;\nconst GRAVE_PROJECTILE_LAUNCH_SPEED = 400;\nconst GRAVE_PROJECTILE_TRAIL_LENGTH = 15; // Number of trail particles\nconst GRAVE_PROJECTILE_HIT_DISTANCE = 10; // Distance at which projectile hits target\n// Starling unit constants (minions from stellar forge)\nconst STARLING_MAX_HEALTH = 50;\nconst STARLING_ATTACK_RANGE = 120;\nconst STARLING_ATTACK_DAMAGE = 5;\nconst STARLING_ATTACK_SPEED = 2; // Attacks per second\nconst STARLING_MOVE_SPEED = 50; // Pixels per second (slower than regular units)\nconst STARLING_SPAWN_INTERVAL = 10.0; // Seconds between spawns\nconst STARLING_EXPLORATION_CHANGE_INTERVAL = 5.0; // Change random direction every 5 seconds\nconst STARLING_PROJECTILE_SPEED = 320; // Pixels per second\nconst STARLING_PROJECTILE_MAX_RANGE_PX = 140; // Maximum travel distance\nconst STARLING_PROJECTILE_HIT_RADIUS_PX = 8; // Hit radius for starling projectiles\nconst STARLING_COLLISION_RADIUS_PX = 3; // Collision radius for minion starlings\nconst STARLING_LASER_IMPACT_PARTICLES = 3; // Number of particles spawned at laser impact\nconst STARLING_LASER_PARTICLE_SPEED = 30; // Speed of impact particles in pixels per second\nconst STARLING_LASER_PARTICLE_LIFETIME = 0.3; // Lifetime of impact particles in seconds\nconst FORGE_FLAME_ALPHA = 0.3;\nconst FORGE_FLAME_SIZE_MULTIPLIER = 0.3;\nconst FORGE_FLAME_ROTATION_SPEED_RAD_PER_SEC = Math.PI;\nconst FORGE_FLAME_WARMTH_FADE_PER_SEC = 2.0;\nconst FORGE_FLAME_OFFSET_MULTIPLIER = 0.35;\n// Stellar Forge constants (main base structure)\nconst STELLAR_FORGE_MAX_HEALTH = 1000;\n// Forge crunch constants (periodic event that spawns minions)\nconst FORGE_CRUNCH_INTERVAL = 10.0; // Seconds between crunches\nconst FORGE_CRUNCH_SUCK_DURATION = 0.8; // Duration of dust suction phase\nconst FORGE_CRUNCH_WAVE_DURATION = 1.2; // Duration of wave push phase\nconst FORGE_CRUNCH_SUCK_RADIUS = 250; // Radius of dust suction effect\nconst FORGE_CRUNCH_WAVE_RADIUS = 300; // Radius of wave push effect\nconst FORGE_CRUNCH_SUCK_FORCE = 150; // Force magnitude pulling dust in\nconst FORGE_CRUNCH_WAVE_FORCE = 100; // Force magnitude pushing dust out\nconst STARLING_COST_PER_ENERGY = 50; // Energy needed per starling spawned\n// Cannon building constants (offensive building for Radiant faction)\nconst MINIGUN_MAX_HEALTH = 200;\nconst MINIGUN_ATTACK_RANGE = 350;\nconst MINIGUN_ATTACK_DAMAGE = 12;\nconst MINIGUN_ATTACK_SPEED = 6; // Attacks per second (very fast)\nconst MINIGUN_RADIUS = 30; // Building size\n// Space Dust Swirler building constants (defensive building for Radiant faction)\nconst SWIRLER_MAX_HEALTH = 250;\nconst SWIRLER_ATTACK_RANGE = 0; // No direct attack\nconst SWIRLER_ATTACK_DAMAGE = 0; // Defensive building\nconst SWIRLER_ATTACK_SPEED = 0; // No direct attack\nconst SWIRLER_RADIUS = 35; // Building size\nconst SWIRLER_INFLUENCE_RADIUS = 400; // Range of space dust swirl effect (max radius)\nconst SWIRLER_INITIAL_RADIUS_MULTIPLIER = 0.5; // Start at 50% of max radius\nconst SWIRLER_GROWTH_RATE_PER_SEC = 30; // Radius growth rate in pixels per second\nconst SWIRLER_SHRINK_BASE_RATE = 20; // Base shrink amount per absorbed projectile\nconst SWIRLER_SHRINK_DAMAGE_MULTIPLIER = 0.5; // Additional shrink per point of damage\nconst SWIRLER_MIN_INFLUENCE_RADIUS = 50; // Minimum radius the swirler can shrink to\nconst SWIRLER_DUST_ORBIT_SPEED_BASE = 80; // Base orbital speed at edge\nconst SWIRLER_DUST_SPEED_MULTIPLIER = 2.5; // Speed multiplier at center (faster closer)\n// Foundry building constants\nconst SUBSIDIARY_FACTORY_MAX_HEALTH = 500;\nconst SUBSIDIARY_FACTORY_ATTACK_RANGE = 0; // No direct attack\nconst SUBSIDIARY_FACTORY_ATTACK_DAMAGE = 0; // Production building\nconst SUBSIDIARY_FACTORY_ATTACK_SPEED = 0; // No direct attack\nconst SUBSIDIARY_FACTORY_RADIUS = 40; // Building size\nconst SUBSIDIARY_FACTORY_PRODUCTION_INTERVAL = 15.0; // Seconds between unit productions\n// Building costs\nconst MINIGUN_COST = 150;\nconst SWIRLER_COST = 200;\nconst SUBSIDIARY_FACTORY_COST = 400;\nconst HERO_UNIT_COST = 300;\nconst SOLAR_MIRROR_COST = 50; // Cost to build additional solar mirrors\n// AI control intervals and placement tuning\nconst AI_MIRROR_COMMAND_INTERVAL_SEC = 2.0;\nconst AI_DEFENSE_COMMAND_INTERVAL_SEC = 1.0;\nconst AI_HERO_COMMAND_INTERVAL_SEC = 3.0;\nconst AI_STRUCTURE_COMMAND_INTERVAL_SEC = 5.0;\nconst AI_MIRROR_PURCHASE_INTERVAL_SEC = 8.0; // Interval to check for buying mirrors\nconst AI_MAX_MIRRORS = 6; // Maximum mirrors AI will build\nconst AI_WAVES_ATTACK_THRESHOLD = 8; // Min unit count for wave attack\nconst AI_AGGRESSIVE_HERO_MULTIPLIER = 0.7; // Faster hero production\nconst AI_ECONOMIC_HERO_MULTIPLIER = 1.5; // Slower hero production\nconst AI_WAVES_HERO_MULTIPLIER = 1.2; // Slightly slower hero production\nconst AI_MIRROR_SUN_DISTANCE_PX = 220;\nconst AI_MIRROR_ARC_SPACING_RAD = 0.6;\nconst AI_MIRROR_REPOSITION_THRESHOLD_PX = 40;\nconst AI_DEFENSE_RADIUS_PX = 350;\nconst AI_STRUCTURE_PLACEMENT_DISTANCE_PX = 140;\nconst AI_STRUCTURE_PLACEMENT_ANGLE_STEP_RAD = Math.PI / 4;\nconst HERO_PRODUCTION_TIME_SEC = 8;\nconst HERO_BUTTON_RADIUS_PX = 28;\nconst HERO_BUTTON_DISTANCE_PX = 100;\nconst BUILDING_BUILD_TIME = 5.0; // Base build time in seconds\n// Weapon effect constants\nconst MUZZLE_FLASH_DURATION = 0.05; // 50ms - very brief\nconst BULLET_CASING_LIFETIME = 2.0; // 2 seconds\nconst BULLET_CASING_SPEED_MIN = 100;\nconst BULLET_CASING_SPEED_MAX = 150;\nconst BOUNCING_BULLET_LIFETIME = 0.5; // 0.5 seconds\nconst BOUNCING_BULLET_SPEED_MIN = 150;\nconst BOUNCING_BULLET_SPEED_MAX = 250;\nconst CASING_SPACEDUST_COLLISION_DISTANCE = 5;\nconst CASING_SPACEDUST_FORCE = 50;\nconst CASING_COLLISION_DAMPING = 0.3;\n// Unit movement constants\nconst UNIT_MOVE_SPEED = 100; // Pixels per second\nconst UNIT_TURN_SPEED_RAD_PER_SEC = 8.0; // Radians per second - quick turning\nconst UNIT_ARRIVAL_THRESHOLD = 5; // Distance to consider unit arrived at destination\nconst UNIT_RADIUS_PX = 10; // Approximate unit radius for collisions\nconst UNIT_AVOIDANCE_RANGE_PX = 40; // Range for unit avoidance steering\nconst UNIT_AVOIDANCE_STRENGTH = 0.7; // Blend factor for avoidance steering (unitless)\nconst UNIT_ASTEROID_AVOIDANCE_LOOKAHEAD_PX = 140; // Distance ahead to check for asteroids\nconst UNIT_ASTEROID_AVOIDANCE_BUFFER_PX = 12; // Buffer distance around asteroids\nconst UNIT_ASTEROID_AVOIDANCE_STRENGTH = 1.1; // Blend factor for asteroid avoidance\nconst UNIT_HERO_AVOIDANCE_MULTIPLIER = 0.3; // Heroes ignore some avoidance (unitless)\nconst UNIT_MINION_YIELD_MULTIPLIER = 1.4; // Minions yield more to heroes (unitless)\nconst UNIT_STRUCTURE_STANDOFF_PX = 4; // Extra spacing to keep units outside structures\nconst PATH_WAYPOINT_ARRIVAL_MULTIPLIER = 2; // Multiplier for waypoint arrival detection\nconst MIN_WAYPOINT_DISTANCE = 50; // Minimum distance between path waypoints in pixels\nconst UNIT_PATH_DRAW_RADIUS = 50; // Maximum distance from unit to initiate path drawing (pixels)\n// Deterministic state hash cadence\nconst STATE_HASH_TICK_INTERVAL = 30; // Update state hash every 30 ticks\n// Solar mirror visual constants\nconst MIRROR_ACTIVE_GLOW_RADIUS = 15; // Radius of yellow glow when mirror is active\nconst MIRROR_MAX_GLOW_DISTANCE = 1000; // Maximum distance for glow and efficiency calculations\nconst MIRROR_PROXIMITY_MULTIPLIER = 2.0; // Maximum energy generation multiplier at close range\n// Ability constants\nconst MARINE_ABILITY_COOLDOWN = 5.0; // 5 seconds\nconst MARINE_ABILITY_BULLET_COUNT = 15; // Number of bullets in storm\nconst MARINE_ABILITY_BULLET_SPEED = 500; // Speed of ability bullets\nconst MARINE_ABILITY_BULLET_LIFETIME = 1.0; // Lifetime of ability bullets\nconst MARINE_ABILITY_SPREAD_ANGLE = (10 * Math.PI) / 180; // 10 degrees in radians\nconst MARINE_ABILITY_BULLET_DAMAGE = 5; // Damage per ability bullet\n// UI constants\nconst UI_BACKGROUND_COLOR = '#000011'; // Dark blue-black background for UI\nconst CLICK_DRAG_THRESHOLD = 10; // Pixels of movement to distinguish click from drag (increased for better tap/drag distinction)\nconst HERO_ATTACK_RANGE_ALPHA = 0.2; // Opacity for hero unit attack range circles\nconst ABILITY_ARROW_MIN_LENGTH = 10; // Minimum pixel length to display ability arrow (prevents tiny arrows on accidental drags)\n// Visual effect constants\nconst TAP_EFFECT_SPEED = 0.05; // Progress increment per frame for tap effect\nconst TAP_EFFECT_MAX_RADIUS = 40; // Maximum radius of tap ripple effect\nconst SWIPE_EFFECT_SPEED = 0.08; // Progress increment per frame for swipe effect\nconst PRODUCTION_BUTTON_WAVE_MAX_RADIUS_PX = 48; // Max radius for hero/building button waves\nconst PRODUCTION_BUTTON_WAVE_PROGRESS_PER_FRAME = 0.12; // Progress increment per frame for production button wave\nconst SWIPE_ARROW_SIZE = 15; // Size of the arrow head in swipe effect\n// Ray unit constants (Solari hero)\nconst RAY_MAX_HEALTH = 120;\nconst RAY_ATTACK_RANGE = 250;\nconst RAY_ATTACK_DAMAGE = 8;\nconst RAY_ATTACK_SPEED = 3; // Attacks per second\nconst RAY_ABILITY_COOLDOWN = 8.0; // 8 seconds\nconst RAY_BEAM_DAMAGE = 25; // Damage per beam hit\nconst RAY_BEAM_MAX_BOUNCES = 5; // Maximum number of bounces\nconst RAY_BEAM_WIDTH = 3; // Visual width of the beam\n// Influence Ball unit constants (Solari hero)\nconst INFLUENCE_BALL_MAX_HEALTH = 100;\nconst INFLUENCE_BALL_ATTACK_RANGE = 200;\nconst INFLUENCE_BALL_ATTACK_DAMAGE = 5;\nconst INFLUENCE_BALL_ATTACK_SPEED = 1.5; // Attacks per second\nconst INFLUENCE_BALL_ABILITY_COOLDOWN = 15.0; // 15 seconds\nconst INFLUENCE_BALL_PROJECTILE_SPEED = 300;\nconst INFLUENCE_BALL_EXPLOSION_RADIUS = 150; // Radius of influence zone\nconst INFLUENCE_BALL_DURATION = 10.0; // 10 seconds influence duration\n// Turret Deployer unit constants (Solari hero)\nconst TURRET_DEPLOYER_MAX_HEALTH = 90;\nconst TURRET_DEPLOYER_ATTACK_RANGE = 180;\nconst TURRET_DEPLOYER_ATTACK_DAMAGE = 6;\nconst TURRET_DEPLOYER_ATTACK_SPEED = 2; // Attacks per second\nconst TURRET_DEPLOYER_ABILITY_COOLDOWN = 12.0; // 12 seconds\nconst DEPLOYED_TURRET_MAX_HEALTH = 150;\nconst DEPLOYED_TURRET_ATTACK_RANGE = 300;\nconst DEPLOYED_TURRET_ATTACK_DAMAGE = 12;\nconst DEPLOYED_TURRET_ATTACK_SPEED = 2; // Attacks per second (fires 2 times per second)\nconst TURRET_PROJECTILE_SPEED = 400;\nconst DEPLOYED_TURRET_ANIMATION_DURATION = 0.1; // Animation duration in seconds\nconst DEPLOYED_TURRET_SPRITE_SCALE = 0.08; // Base scale factor for turret sprites\nconst DEPLOYED_TURRET_ANIMATION_FRAME_COUNT = 28; // Number of firing animation frames\nconst DEPLOYED_TURRET_PIVOT_FROM_BOTTOM_PX = 200; // Pivot point distance from bottom of sprite (in sprite pixels)\nconst DEPLOYED_TURRET_SPRITE_HEIGHT_PX = 1100; // Height of turret top sprite in pixels\nconst DEPLOYED_TURRET_HEALTH_BAR_SIZE = 40; // Size for health bar positioning\n// Driller unit constants (Aurum hero)\nconst DRILLER_MAX_HEALTH = 140;\nconst DRILLER_ATTACK_RANGE = 0; // No normal attack, only ability\nconst DRILLER_ATTACK_DAMAGE = 0; // No normal attack\nconst DRILLER_ATTACK_SPEED = 0; // No normal attack\nconst DRILLER_ABILITY_COOLDOWN = 5.0; // 5 seconds after collision\nconst DRILLER_DRILL_SPEED = 500; // Speed when drilling\nconst DRILLER_DRILL_DAMAGE = 30; // Damage to units\nconst DRILLER_BUILDING_DAMAGE_MULTIPLIER = 2.0; // Double damage to buildings\nconst DRILLER_DECELERATION = 200; // Deceleration rate at edge\n// Dagger unit constants (Radiant hero - cloaked assassin)\nconst DAGGER_MAX_HEALTH = 80;\nconst DAGGER_ATTACK_RANGE = 100; // Very short range\nconst DAGGER_ATTACK_DAMAGE = 35; // High damage for close range\nconst DAGGER_ATTACK_SPEED = 1.5; // Attacks per second\nconst DAGGER_ABILITY_COOLDOWN = 6.0; // 6 seconds\nconst DAGGER_ABILITY_RANGE = 150; // Very short range for ability attack\nconst DAGGER_ABILITY_DAMAGE = 50; // High burst damage\nconst DAGGER_VISIBILITY_DURATION = 8.0; // 8 seconds visible after using ability\nconst DAGGER_CLOAK_OPACITY = 0.4; // Opacity when cloaked to own player\n// Beam unit constants (Radiant hero - sniper with distance-based damage)\nconst BEAM_MAX_HEALTH = 70;\nconst BEAM_ATTACK_RANGE = 150;\nconst BEAM_ATTACK_DAMAGE = 20;\nconst BEAM_ATTACK_SPEED = 1.0; // Attacks per second\nconst BEAM_ABILITY_COOLDOWN = 8.0; // 8 seconds\nconst BEAM_ABILITY_BASE_DAMAGE = 30; // Base damage for ability\nconst BEAM_ABILITY_MAX_RANGE = 600; // Maximum beam range\nconst BEAM_ABILITY_DAMAGE_PER_DISTANCE = 0.1; // Damage multiplier per unit of distance\n// Mortar unit constants (Radiant hero - stationary artillery with cone detection)\nconst MORTAR_MAX_HEALTH = 120;\nconst MORTAR_ATTACK_RANGE = 450; // Long range artillery\nconst MORTAR_ATTACK_DAMAGE = 40; // High damage per shot\nconst MORTAR_ATTACK_SPEED = 0.5; // Low fire rate (0.5 attacks per second = 2 seconds between shots)\nconst MORTAR_ABILITY_COOLDOWN = 0; // No cooldown, setup is the ability\nconst MORTAR_DETECTION_CONE_ANGLE = (150 * Math.PI) / 180; // 150 degrees detection cone\nconst MORTAR_SPLASH_RADIUS = 80; // Radius of splash damage\nconst MORTAR_SPLASH_DAMAGE_FALLOFF = 0.5; // 50% damage at edge of splash radius\nconst MORTAR_PROJECTILE_SPEED = 300; // Speed of mortar shells\n// Preist unit constants (healing support hero)\nconst PREIST_MAX_HEALTH = 110;\nconst PREIST_ATTACK_RANGE = 0; // No attack\nconst PREIST_ATTACK_DAMAGE = 0; // No damage\nconst PREIST_ATTACK_SPEED = 0; // No attack\nconst PREIST_ABILITY_COOLDOWN = 10.0; // 10 seconds\nconst PREIST_HEALING_RANGE = 350; // Range for healing beams\nconst PREIST_HEALING_PER_SECOND = 0.02; // 2% of max health per second per beam\nconst PREIST_TARGET_LOCK_DURATION = 0.5; // Stay on target for at least 0.5 seconds\nconst PREIST_NUM_BEAMS = 2; // Number of healing beams\nconst PREIST_HEALING_BOMB_SPEED = 400; // Speed of healing bomb projectile\nconst PREIST_HEALING_BOMB_MAX_RANGE = 500; // Maximum range for healing bomb\nconst PREIST_HEALING_BOMB_PARTICLE_COUNT = 50; // Number of wild particles\nconst PREIST_HEALING_BOMB_PARTICLE_HEALING = 0.01; // 1% of max health per particle\nconst PREIST_HEALING_BOMB_EXPLOSION_RADIUS = 120; // Radius of particle explosion area\nconst PREIST_HEALING_BOMB_PARTICLE_SPEED = 200; // Speed of wild particles\nconst PREIST_HEALING_BOMB_PARTICLE_LIFETIME = 0.5; // Lifetime of wild particles\n// Tank hero constants (defensive tank with shield and crescent wave ability)\nconst TANK_MAX_HEALTH = 300; // Very high health (3x Marine)\nconst TANK_ATTACK_RANGE = 0; // Doesn't attack\nconst TANK_ATTACK_DAMAGE = 0; // No damage\nconst TANK_ATTACK_SPEED = 0; // No attack\nconst TANK_DEFENSE = 50; // 50% damage reduction (armor)\nconst TANK_ABILITY_COOLDOWN = 12.0; // 12 seconds\nconst TANK_SHIELD_RADIUS = 60; // Radius of shield around tank that blocks projectiles\nconst TANK_WAVE_ANGLE = Math.PI / 2; // 90 degrees crescent wave\nconst TANK_WAVE_RANGE = 400; // Maximum range of wave\nconst TANK_WAVE_SPEED = 150; // Slow moving wave (pixels per second)\nconst TANK_WAVE_WIDTH = 40; // Width of the wave\nconst TANK_STUN_DURATION = 2.0; // Stuns for 2 seconds\nconst TANK_COLLISION_RADIUS_PX = 20; // Slightly larger collision radius\n// AI Strategy types\nvar AIStrategy;\n(function (AIStrategy) {\n    AIStrategy[\"ECONOMIC\"] = \"economic\";\n    AIStrategy[\"DEFENSIVE\"] = \"defensive\";\n    AIStrategy[\"AGGRESSIVE\"] = \"aggressive\";\n    AIStrategy[\"WAVES\"] = \"waves\"; // Build up then attack in waves\n})(AIStrategy || (AIStrategy = {}));\n\n\n//# sourceURL=webpack://sol/./src/constants.ts?\n}");

/***/ },

/***/ "./src/game-core.ts"
/*!**************************!*\
  !*** ./src/game-core.ts ***!
  \**************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbilityBullet: () => (/* binding */ AbilityBullet),\n/* harmony export */   Asteroid: () => (/* binding */ Asteroid),\n/* harmony export */   Beam: () => (/* binding */ Beam),\n/* harmony export */   BouncingBullet: () => (/* binding */ BouncingBullet),\n/* harmony export */   Building: () => (/* binding */ Building),\n/* harmony export */   BulletCasing: () => (/* binding */ BulletCasing),\n/* harmony export */   CrescentWave: () => (/* binding */ CrescentWave),\n/* harmony export */   Dagger: () => (/* binding */ Dagger),\n/* harmony export */   DamageNumber: () => (/* binding */ DamageNumber),\n/* harmony export */   DeployedTurret: () => (/* binding */ DeployedTurret),\n/* harmony export */   Driller: () => (/* binding */ Driller),\n/* harmony export */   Faction: () => (/* binding */ Faction),\n/* harmony export */   ForgeCrunch: () => (/* binding */ ForgeCrunch),\n/* harmony export */   GameState: () => (/* binding */ GameState),\n/* harmony export */   Grave: () => (/* binding */ Grave),\n/* harmony export */   GraveProjectile: () => (/* binding */ GraveProjectile),\n/* harmony export */   HealingBombParticle: () => (/* binding */ HealingBombParticle),\n/* harmony export */   ImpactParticle: () => (/* binding */ ImpactParticle),\n/* harmony export */   InfluenceBall: () => (/* binding */ InfluenceBall),\n/* harmony export */   InfluenceBallProjectile: () => (/* binding */ InfluenceBallProjectile),\n/* harmony export */   InfluenceZone: () => (/* binding */ InfluenceZone),\n/* harmony export */   LaserBeam: () => (/* binding */ LaserBeam),\n/* harmony export */   LightRay: () => (/* binding */ LightRay),\n/* harmony export */   Marine: () => (/* binding */ Marine),\n/* harmony export */   Minigun: () => (/* binding */ Minigun),\n/* harmony export */   MinionProjectile: () => (/* binding */ MinionProjectile),\n/* harmony export */   Mortar: () => (/* binding */ Mortar),\n/* harmony export */   MortarProjectile: () => (/* binding */ MortarProjectile),\n/* harmony export */   MuzzleFlash: () => (/* binding */ MuzzleFlash),\n/* harmony export */   Player: () => (/* binding */ Player),\n/* harmony export */   Preist: () => (/* binding */ Preist),\n/* harmony export */   Ray: () => (/* binding */ Ray),\n/* harmony export */   RayBeamSegment: () => (/* binding */ RayBeamSegment),\n/* harmony export */   SolarMirror: () => (/* binding */ SolarMirror),\n/* harmony export */   SpaceDustParticle: () => (/* binding */ SpaceDustParticle),\n/* harmony export */   SpaceDustSwirler: () => (/* binding */ SpaceDustSwirler),\n/* harmony export */   Starling: () => (/* binding */ Starling),\n/* harmony export */   StellarForge: () => (/* binding */ StellarForge),\n/* harmony export */   SubsidiaryFactory: () => (/* binding */ SubsidiaryFactory),\n/* harmony export */   Sun: () => (/* binding */ Sun),\n/* harmony export */   Tank: () => (/* binding */ Tank),\n/* harmony export */   TurretDeployer: () => (/* binding */ TurretDeployer),\n/* harmony export */   Unit: () => (/* binding */ Unit),\n/* harmony export */   Vector2D: () => (/* binding */ Vector2D),\n/* harmony export */   WarpGate: () => (/* binding */ WarpGate),\n/* harmony export */   createStandardGame: () => (/* binding */ createStandardGame)\n/* harmony export */ });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"./src/constants.ts\");\n/* harmony import */ var _network__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./network */ \"./src/network.ts\");\n/* harmony import */ var _heroes_beam__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./heroes/beam */ \"./src/heroes/beam.ts\");\n/* harmony import */ var _heroes_dagger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./heroes/dagger */ \"./src/heroes/dagger.ts\");\n/* harmony import */ var _heroes_driller__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./heroes/driller */ \"./src/heroes/driller.ts\");\n/* harmony import */ var _heroes_grave__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./heroes/grave */ \"./src/heroes/grave.ts\");\n/* harmony import */ var _heroes_influence_ball__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./heroes/influence-ball */ \"./src/heroes/influence-ball.ts\");\n/* harmony import */ var _heroes_marine__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./heroes/marine */ \"./src/heroes/marine.ts\");\n/* harmony import */ var _heroes_mortar__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./heroes/mortar */ \"./src/heroes/mortar.ts\");\n/* harmony import */ var _heroes_preist__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./heroes/preist */ \"./src/heroes/preist.ts\");\n/* harmony import */ var _heroes_ray__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./heroes/ray */ \"./src/heroes/ray.ts\");\n/* harmony import */ var _heroes_tank__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./heroes/tank */ \"./src/heroes/tank.ts\");\n/* harmony import */ var _heroes_turret_deployer__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./heroes/turret-deployer */ \"./src/heroes/turret-deployer.ts\");\n/**\n * SoL (Speed of Light) - Core Game Module\n * A 2D real-time strategy game with light-based mechanics\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Three playable factions in the game\n */\nvar Faction;\n(function (Faction) {\n    Faction[\"RADIANT\"] = \"Radiant\";\n    Faction[\"AURUM\"] = \"Aurum\";\n    Faction[\"SOLARI\"] = \"Solari\";\n})(Faction || (Faction = {}));\n/**\n * 2D position/direction vector\n */\nclass Vector2D {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    /**\n     * Calculate distance to another vector\n     */\n    distanceTo(other) {\n        return Math.sqrt(Math.pow((this.x - other.x), 2) + Math.pow((this.y - other.y), 2));\n    }\n    /**\n     * Return normalized vector\n     */\n    normalize() {\n        const magnitude = Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2));\n        if (magnitude === 0) {\n            return new Vector2D(0, 0);\n        }\n        return new Vector2D(this.x / magnitude, this.y / magnitude);\n    }\n}\n/**\n * Represents a ray of light for ray tracing\n */\nclass LightRay {\n    constructor(origin, direction, intensity = 1.0) {\n        this.origin = origin;\n        this.direction = direction;\n        this.intensity = intensity;\n    }\n    /**\n     * Check if ray intersects with a circular object\n     */\n    intersects(position, radius) {\n        // Ray-circle intersection using vector math\n        const oc = new Vector2D(this.origin.x - position.x, this.origin.y - position.y);\n        const a = this.direction.x * this.direction.x + this.direction.y * this.direction.y;\n        const b = 2.0 * (oc.x * this.direction.x + oc.y * this.direction.y);\n        const c = oc.x * oc.x + oc.y * oc.y - radius * radius;\n        const discriminant = b * b - 4 * a * c;\n        return discriminant >= 0;\n    }\n    /**\n     * Check if ray intersects with a polygon and return the distance to the closest intersection\n     */\n    intersectsPolygon(vertices) {\n        // Check each edge of the polygon\n        for (let i = 0; i < vertices.length; i++) {\n            const v1 = vertices[i];\n            const v2 = vertices[(i + 1) % vertices.length];\n            if (this.intersectsLineSegment(v1, v2) !== null) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Get the distance to the closest intersection with a polygon, or null if no intersection\n     */\n    getIntersectionDistance(vertices) {\n        let closestDistance = null;\n        // Check each edge of the polygon\n        for (let i = 0; i < vertices.length; i++) {\n            const v1 = vertices[i];\n            const v2 = vertices[(i + 1) % vertices.length];\n            const distance = this.intersectsLineSegment(v1, v2);\n            if (distance !== null) {\n                if (closestDistance === null || distance < closestDistance) {\n                    closestDistance = distance;\n                }\n            }\n        }\n        return closestDistance;\n    }\n    /**\n     * Check if ray intersects with a line segment and return the distance, or null if no intersection\n     */\n    intersectsLineSegment(p1, p2) {\n        const v1 = new Vector2D(p2.x - p1.x, p2.y - p1.y);\n        const v2 = new Vector2D(p1.x - this.origin.x, p1.y - this.origin.y);\n        const cross1 = this.direction.x * v1.y - this.direction.y * v1.x;\n        if (Math.abs(cross1) < 0.0001)\n            return null; // Parallel\n        const t1 = (v2.x * v1.y - v2.y * v1.x) / cross1;\n        const t2 = (v2.x * this.direction.y - v2.y * this.direction.x) / cross1;\n        if (t1 >= 0 && t2 >= 0 && t2 <= 1) {\n            return t1; // Return the distance along the ray\n        }\n        return null;\n    }\n}\n/**\n * Asteroid - Polygon obstacle that blocks light and casts shadows\n */\nclass Asteroid {\n    constructor(position, sides, // 3-9 sides (triangle to nonagon)\n    size) {\n        this.position = position;\n        this.sides = sides;\n        this.size = size;\n        this.vertices = [];\n        this.rotation = 0;\n        this.generateVertices();\n        this.rotationSpeed = (Math.random() - 0.5) * 0.5; // Random rotation speed\n    }\n    /**\n     * Generate polygon vertices\n     */\n    generateVertices() {\n        this.vertices = [];\n        for (let i = 0; i < this.sides; i++) {\n            const angle = (Math.PI * 2 * i) / this.sides;\n            // Add some randomness to make asteroids less uniform\n            const radiusVariation = 0.8 + Math.random() * 0.4;\n            const radius = this.size * radiusVariation;\n            this.vertices.push(new Vector2D(Math.cos(angle) * radius, Math.sin(angle) * radius));\n        }\n    }\n    /**\n     * Get world-space vertices (with position and rotation)\n     */\n    getWorldVertices() {\n        return this.vertices.map(v => {\n            const cos = Math.cos(this.rotation);\n            const sin = Math.sin(this.rotation);\n            return new Vector2D(this.position.x + v.x * cos - v.y * sin, this.position.y + v.x * sin + v.y * cos);\n        });\n    }\n    /**\n     * Update asteroid rotation\n     */\n    update(deltaTime) {\n        this.rotation += this.rotationSpeed * deltaTime;\n    }\n    /**\n     * Check if a point is inside the asteroid (for collision detection)\n     */\n    containsPoint(point) {\n        const worldVertices = this.getWorldVertices();\n        let inside = false;\n        for (let i = 0, j = worldVertices.length - 1; i < worldVertices.length; j = i++) {\n            const xi = worldVertices[i].x, yi = worldVertices[i].y;\n            const xj = worldVertices[j].x, yj = worldVertices[j].y;\n            const intersect = ((yi > point.y) !== (yj > point.y))\n                && (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);\n            if (intersect)\n                inside = !inside;\n        }\n        return inside;\n    }\n}\n/**\n * Solar Mirror - reflects light to generate Energy\n */\nclass SolarMirror {\n    constructor(position, owner) {\n        this.position = position;\n        this.owner = owner;\n        this.health = _constants__WEBPACK_IMPORTED_MODULE_0__.MIRROR_MAX_HEALTH;\n        this.efficiency = 1.0; // 0.0 to 1.0\n        this.isSelected = false;\n        this.targetPosition = null;\n        this.velocity = new Vector2D(0, 0);\n        this.reflectionAngle = 0; // Angle in radians for the flat surface rotation\n        this.closestSunDistance = Infinity; // Distance to closest visible sun\n        this.moveOrder = 0; // Movement order indicator (0 = no order)\n        // Movement constants for mirrors (slower than Stellar Forge)\n        this.MAX_SPEED = 50; // Pixels per second - slower than forge\n        this.ACCELERATION = 25; // Pixels per second squared\n        this.DECELERATION = 50; // Pixels per second squared\n        this.ARRIVAL_THRESHOLD = 2; // Distance to consider arrived at target\n        this.SLOW_RADIUS_PX = 60; // Distance to begin slow approach\n        this.AVOIDANCE_BLEND_FACTOR = 0.6; // How much to blend avoidance with direct path\n        this.ROTATION_SPEED_RAD_PER_SEC = Math.PI; // Radians per second\n        this.ROTATION_SNAP_THRESHOLD_RAD = 0.01; // Snap when nearly aligned\n    }\n    /**\n     * Check if ray from mirror to target is blocked by asteroids\n     * Helper method to avoid code duplication\n     */\n    isPathClear(target, asteroids = []) {\n        const direction = new Vector2D(target.x - this.position.x, target.y - this.position.y).normalize();\n        const ray = new LightRay(this.position, direction);\n        const distance = this.position.distanceTo(target);\n        for (const asteroid of asteroids) {\n            const intersectionDist = ray.getIntersectionDistance(asteroid.getWorldVertices());\n            if (intersectionDist !== null && intersectionDist < distance) {\n                return false; // Path is blocked\n            }\n        }\n        return true; // Path is clear\n    }\n    isCircleBlockingRay(direction, distanceToTarget, circlePosition, circleRadius) {\n        const toCircleX = circlePosition.x - this.position.x;\n        const toCircleY = circlePosition.y - this.position.y;\n        const projection = toCircleX * direction.x + toCircleY * direction.y;\n        if (projection <= 0 || projection >= distanceToTarget) {\n            return false;\n        }\n        const closestX = this.position.x + direction.x * projection;\n        const closestY = this.position.y + direction.y * projection;\n        const offsetX = circlePosition.x - closestX;\n        const offsetY = circlePosition.y - closestY;\n        const distanceSq = offsetX * offsetX + offsetY * offsetY;\n        return distanceSq <= circleRadius * circleRadius;\n    }\n    /**\n     * Check if mirror has clear view of any light source\n     * Returns true if at least one sun is visible\n     */\n    hasLineOfSightToLight(lightSources, asteroids = []) {\n        for (const sun of lightSources) {\n            if (this.isPathClear(sun.position, asteroids)) {\n                return true; // Found at least one clear path to a sun\n            }\n        }\n        return false;\n    }\n    /**\n     * Check if mirror has clear path to Stellar Forge\n     * Returns true if path is not blocked by asteroids\n     */\n    hasLineOfSightToForge(forge, asteroids = [], players = []) {\n        const direction = new Vector2D(forge.position.x - this.position.x, forge.position.y - this.position.y).normalize();\n        const distanceToForge = this.position.distanceTo(forge.position);\n        const ray = new LightRay(this.position, direction);\n        for (const asteroid of asteroids) {\n            const intersectionDist = ray.getIntersectionDistance(asteroid.getWorldVertices());\n            if (intersectionDist !== null && intersectionDist < distanceToForge) {\n                return false;\n            }\n        }\n        const mirrorRadiusPx = 20;\n        for (const player of players) {\n            for (const mirror of player.solarMirrors) {\n                if (mirror === this)\n                    continue;\n                if (this.isCircleBlockingRay(direction, distanceToForge, mirror.position, mirrorRadiusPx)) {\n                    return false;\n                }\n            }\n            for (const building of player.buildings) {\n                if (this.isCircleBlockingRay(direction, distanceToForge, building.position, building.radius)) {\n                    return false;\n                }\n            }\n            if (player.stellarForge && player.stellarForge !== forge) {\n                if (this.isCircleBlockingRay(direction, distanceToForge, player.stellarForge.position, player.stellarForge.radius)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    /**\n     * Get the closest visible sun (for visual indicators)\n     */\n    getClosestVisibleSun(lightSources, asteroids = []) {\n        let closestSun = null;\n        let closestDistance = Infinity;\n        for (const sun of lightSources) {\n            if (this.isPathClear(sun.position, asteroids)) {\n                const distance = this.position.distanceTo(sun.position);\n                if (distance < closestDistance) {\n                    closestSun = sun;\n                    closestDistance = distance;\n                }\n            }\n        }\n        return closestSun;\n    }\n    /**\n     * Get the closest sun regardless of line of sight\n     */\n    getClosestSun(lightSources) {\n        let closestSun = null;\n        let closestDistance = Infinity;\n        for (const sun of lightSources) {\n            const distance = this.position.distanceTo(sun.position);\n            if (distance < closestDistance) {\n                closestSun = sun;\n                closestDistance = distance;\n            }\n        }\n        return closestSun;\n    }\n    /**\n     * Generate Energy based on light received and distance to closest sun\n     */\n    generateEnergy(deltaTime) {\n        return this.getEnergyRatePerSec() * deltaTime;\n    }\n    /**\n     * Get energy generation rate per second\n     */\n    getEnergyRatePerSec() {\n        const baseGenerationRatePerSec = 10.0;\n        // Apply distance-based multiplier (closer = more efficient)\n        // At distance 0: MIRROR_PROXIMITY_MULTIPLIER, at MIRROR_MAX_GLOW_DISTANCE: 1x multiplier\n        const distanceMultiplier = Math.max(1.0, _constants__WEBPACK_IMPORTED_MODULE_0__.MIRROR_PROXIMITY_MULTIPLIER - (this.closestSunDistance / _constants__WEBPACK_IMPORTED_MODULE_0__.MIRROR_MAX_GLOW_DISTANCE));\n        return baseGenerationRatePerSec * this.efficiency * distanceMultiplier;\n    }\n    /**\n     * Set target position for mirror movement\n     */\n    setTarget(target) {\n        this.targetPosition = target;\n    }\n    /**\n     * Update mirror reflection angle based on closest sun and forge\n     */\n    updateReflectionAngle(forge, suns, asteroids = [], deltaTime) {\n        if (!forge)\n            return;\n        const closestSun = this.getClosestVisibleSun(suns, asteroids);\n        if (!closestSun) {\n            this.closestSunDistance = Infinity;\n            return;\n        }\n        // Store distance to closest sun for brightness and generation calculations\n        this.closestSunDistance = this.position.distanceTo(closestSun.position);\n        // Calculate the reflection angle as if reflecting light from sun to forge\n        // The mirror surface should be perpendicular to the bisector of sun-mirror-forge angle\n        const sunDirection = new Vector2D(closestSun.position.x - this.position.x, closestSun.position.y - this.position.y).normalize();\n        const forgeDirection = new Vector2D(forge.position.x - this.position.x, forge.position.y - this.position.y).normalize();\n        // The bisector direction (average of both directions)\n        const bisectorX = sunDirection.x + forgeDirection.x;\n        const bisectorY = sunDirection.y + forgeDirection.y;\n        // The mirror surface should be perpendicular to the bisector\n        // So we rotate by 90 degrees\n        const bisectorLength = Math.sqrt(bisectorX * bisectorX + bisectorY * bisectorY);\n        const bisectorAngle = bisectorLength > 0\n            ? Math.atan2(bisectorY, bisectorX)\n            : Math.atan2(sunDirection.y, sunDirection.x);\n        const targetReflectionAngle = bisectorAngle + Math.PI / 2;\n        const angleDelta = this.getShortestAngleDelta(this.reflectionAngle, targetReflectionAngle);\n        const maxStep = this.ROTATION_SPEED_RAD_PER_SEC * deltaTime;\n        if (Math.abs(angleDelta) <= Math.max(this.ROTATION_SNAP_THRESHOLD_RAD, maxStep)) {\n            this.reflectionAngle = targetReflectionAngle;\n        }\n        else {\n            this.reflectionAngle += Math.sign(angleDelta) * maxStep;\n        }\n    }\n    getShortestAngleDelta(currentAngle, targetAngle) {\n        let delta = targetAngle - currentAngle;\n        while (delta > Math.PI) {\n            delta -= Math.PI * 2;\n        }\n        while (delta < -Math.PI) {\n            delta += Math.PI * 2;\n        }\n        return delta;\n    }\n    /**\n     * Update mirror position based on target and velocity with obstacle avoidance\n     */\n    update(deltaTime, gameState = null) {\n        if (!this.targetPosition)\n            return;\n        const dx = this.targetPosition.x - this.position.x;\n        const dy = this.targetPosition.y - this.position.y;\n        const distanceToTarget = Math.sqrt(dx * dx + dy * dy);\n        // If we're close enough to target, stop smoothly\n        if (distanceToTarget < this.ARRIVAL_THRESHOLD) {\n            this.position = this.targetPosition;\n            this.targetPosition = null;\n            this.velocity = new Vector2D(0, 0);\n            return;\n        }\n        // Calculate desired direction\n        let directionX = dx / distanceToTarget;\n        let directionY = dy / distanceToTarget;\n        // Add obstacle avoidance if gameState is provided\n        if (gameState) {\n            const avoidanceDir = this.calculateObstacleAvoidance(gameState);\n            if (avoidanceDir) {\n                directionX += avoidanceDir.x * this.AVOIDANCE_BLEND_FACTOR;\n                directionY += avoidanceDir.y * this.AVOIDANCE_BLEND_FACTOR;\n                const length = Math.sqrt(directionX * directionX + directionY * directionY);\n                if (length > 0) {\n                    directionX /= length;\n                    directionY /= length;\n                }\n            }\n        }\n        if (distanceToTarget <= this.SLOW_RADIUS_PX) {\n            const slowFactor = Math.max(0, distanceToTarget / this.SLOW_RADIUS_PX);\n            const desiredSpeed = this.MAX_SPEED * slowFactor;\n            this.velocity.x = directionX * desiredSpeed;\n            this.velocity.y = directionY * desiredSpeed;\n        }\n        else {\n            // Calculate distance needed to decelerate to stop\n            const currentSpeed = Math.sqrt(Math.pow(this.velocity.x, 2) + Math.pow(this.velocity.y, 2));\n            const decelerationDistance = (currentSpeed * currentSpeed) / (2 * this.DECELERATION);\n            // Should we accelerate or decelerate?\n            if (distanceToTarget > decelerationDistance && currentSpeed < this.MAX_SPEED) {\n                // Accelerate toward target\n                this.velocity.x += directionX * this.ACCELERATION * deltaTime;\n                this.velocity.y += directionY * this.ACCELERATION * deltaTime;\n            }\n            else {\n                // Decelerate - improved deceleration to prevent overshooting\n                if (currentSpeed > 0.1) {\n                    const decelerationAmount = this.DECELERATION * deltaTime;\n                    const decelerationFactor = Math.max(0, (currentSpeed - decelerationAmount) / currentSpeed);\n                    this.velocity.x *= decelerationFactor;\n                    this.velocity.y *= decelerationFactor;\n                }\n                else {\n                    this.velocity.x = 0;\n                    this.velocity.y = 0;\n                }\n            }\n            // Cap speed at MAX_SPEED\n            const speed = Math.sqrt(Math.pow(this.velocity.x, 2) + Math.pow(this.velocity.y, 2));\n            if (speed > this.MAX_SPEED) {\n                this.velocity.x = (this.velocity.x / speed) * this.MAX_SPEED;\n                this.velocity.y = (this.velocity.y / speed) * this.MAX_SPEED;\n            }\n        }\n        // Update position\n        this.position.x += this.velocity.x * deltaTime;\n        this.position.y += this.velocity.y * deltaTime;\n    }\n    /**\n     * Calculate obstacle avoidance direction for smooth pathfinding\n     */\n    calculateObstacleAvoidance(gameState) {\n        let avoidX = 0;\n        let avoidY = 0;\n        let avoidCount = 0;\n        const avoidanceRange = 60; // Look ahead distance\n        // Check nearby obstacles\n        for (const sun of gameState.suns) {\n            const dx = this.position.x - sun.position.x;\n            const dy = this.position.y - sun.position.y;\n            const dist = Math.sqrt(dx * dx + dy * dy);\n            const minDist = sun.radius + 30;\n            if (dist < minDist + avoidanceRange) {\n                const avoidStrength = (minDist + avoidanceRange - dist) / avoidanceRange;\n                avoidX += (dx / dist) * avoidStrength;\n                avoidY += (dy / dist) * avoidStrength;\n                avoidCount++;\n            }\n        }\n        // Check other mirrors (avoid colliding with friendly mirrors)\n        for (const player of gameState.players) {\n            for (const mirror of player.solarMirrors) {\n                if (mirror === this)\n                    continue;\n                const dx = this.position.x - mirror.position.x;\n                const dy = this.position.y - mirror.position.y;\n                const dist = Math.sqrt(dx * dx + dy * dy);\n                const minDist = 40; // 20 + 20 for two mirrors\n                if (dist < minDist + avoidanceRange && dist > 0) {\n                    const avoidStrength = (minDist + avoidanceRange - dist) / avoidanceRange;\n                    avoidX += (dx / dist) * avoidStrength;\n                    avoidY += (dy / dist) * avoidStrength;\n                    avoidCount++;\n                }\n            }\n            // Check stellar forges\n            if (player.stellarForge) {\n                const forge = player.stellarForge;\n                const dx = this.position.x - forge.position.x;\n                const dy = this.position.y - forge.position.y;\n                const dist = Math.sqrt(dx * dx + dy * dy);\n                const minDist = forge.radius + 30;\n                if (dist < minDist + avoidanceRange) {\n                    const avoidStrength = (minDist + avoidanceRange - dist) / avoidanceRange;\n                    avoidX += (dx / dist) * avoidStrength;\n                    avoidY += (dy / dist) * avoidStrength;\n                    avoidCount++;\n                }\n            }\n        }\n        if (avoidCount > 0) {\n            const length = Math.sqrt(avoidX * avoidX + avoidY * avoidY);\n            if (length > 0) {\n                return new Vector2D(avoidX / length, avoidY / length);\n            }\n        }\n        return null;\n    }\n    /**\n     * Check if a point is within the mirror's clickable area\n     */\n    containsPoint(point) {\n        const distance = this.position.distanceTo(point);\n        return distance < 20; // Match the rendering size\n    }\n}\n/**\n * Stellar Forge - Main base that produces units\n */\nclass StellarForge {\n    constructor(position, owner) {\n        this.position = position;\n        this.owner = owner;\n        this.health = 1000.0;\n        this.isReceivingLight = false;\n        this.unitQueue = [];\n        this.heroProductionUnitType = null;\n        this.heroProductionRemainingSec = 0;\n        this.heroProductionDurationSec = 0;\n        this.isSelected = false;\n        this.targetPosition = null;\n        this.velocity = new Vector2D(0, 0);\n        this.maxSpeed = 50; // pixels per second\n        this.acceleration = 30; // pixels per second^2\n        this.deceleration = 50; // pixels per second^2\n        this.slowRadiusPx = 80; // Distance to begin slow approach\n        this.AVOIDANCE_BLEND_FACTOR = 0.6; // How much to blend avoidance with direct path\n        this.radius = 40; // For rendering and selection\n        this.crunchTimer = 0; // Timer until next crunch\n        this.currentCrunch = null; // Active crunch effect\n        this.pendingEnergy = 0; // Energy accumulated since last crunch\n        this.minionPath = []; // Path that minions will follow\n        this.moveOrder = 0; // Movement order indicator (0 = no order)\n        this.rotation = 0; // Current rotation angle in radians\n        // Initialize crunch timer with random offset to stagger crunches\n        this.crunchTimer = Math.random() * _constants__WEBPACK_IMPORTED_MODULE_0__.FORGE_CRUNCH_INTERVAL;\n    }\n    /**\n     * Set the path for minions to follow\n     */\n    setMinionPath(waypoints) {\n        this.minionPath = waypoints.map((waypoint) => new Vector2D(waypoint.x, waypoint.y));\n    }\n    /**\n     * Initialize default path to enemy base position\n     */\n    initializeDefaultPath(enemyBasePosition) {\n        // Create a path from this base to the enemy base\n        this.minionPath = [new Vector2D(enemyBasePosition.x, enemyBasePosition.y)];\n    }\n    /**\n     * Check if forge can produce units (needs light)\n     */\n    canProduceUnits() {\n        return this.isReceivingLight && this.health > 0;\n    }\n    /**\n     * Attempt to produce a unit\n     */\n    produceUnit(unitType, cost, playerEnergy) {\n        // Allow queuing even without sunlight (removed canProduceUnits check)\n        if (this.health <= 0) {\n            return false;\n        }\n        if (playerEnergy < cost) {\n            return false;\n        }\n        this.unitQueue.push(unitType);\n        return true;\n    }\n    enqueueHeroUnit(unitType) {\n        this.unitQueue.push(unitType);\n    }\n    startHeroProductionIfIdle() {\n        if (this.heroProductionUnitType || this.unitQueue.length === 0) {\n            return;\n        }\n        const nextUnitType = this.unitQueue.shift();\n        if (!nextUnitType) {\n            return;\n        }\n        this.heroProductionUnitType = nextUnitType;\n        this.heroProductionDurationSec = _constants__WEBPACK_IMPORTED_MODULE_0__.HERO_PRODUCTION_TIME_SEC;\n        this.heroProductionRemainingSec = _constants__WEBPACK_IMPORTED_MODULE_0__.HERO_PRODUCTION_TIME_SEC;\n    }\n    advanceHeroProduction(deltaTime) {\n        this.startHeroProductionIfIdle();\n        if (!this.heroProductionUnitType) {\n            return null;\n        }\n        if (!this.canProduceUnits()) {\n            return null;\n        }\n        this.heroProductionRemainingSec = Math.max(0, this.heroProductionRemainingSec - deltaTime);\n        if (this.heroProductionRemainingSec > 0) {\n            return null;\n        }\n        const completedUnitType = this.heroProductionUnitType;\n        this.heroProductionUnitType = null;\n        this.heroProductionDurationSec = 0;\n        this.heroProductionRemainingSec = 0;\n        return completedUnitType;\n    }\n    /**\n     * Update whether forge is receiving light from mirrors\n     */\n    updateLightStatus(mirrors, suns, asteroids = [], players = []) {\n        this.isReceivingLight = false;\n        for (const mirror of mirrors) {\n            if (mirror.hasLineOfSightToLight(suns, asteroids) &&\n                mirror.hasLineOfSightToForge(this, asteroids, players)) {\n                this.isReceivingLight = true;\n                break;\n            }\n        }\n    }\n    /**\n     * Update forge movement and crunch effects with obstacle avoidance\n     */\n    update(deltaTime, gameState = null) {\n        // Update crunch timer\n        if (this.health > 0 && this.isReceivingLight) {\n            this.crunchTimer -= deltaTime;\n        }\n        // Update active crunch effect\n        if (this.currentCrunch) {\n            this.currentCrunch.update(deltaTime);\n            if (!this.currentCrunch.isActive()) {\n                this.currentCrunch = null;\n            }\n        }\n        if (!this.targetPosition) {\n            // No target, apply deceleration\n            const speed = Math.sqrt(Math.pow(this.velocity.x, 2) + Math.pow(this.velocity.y, 2));\n            if (speed > 0.1) {\n                const decelAmount = this.deceleration * deltaTime;\n                const factor = Math.max(0, (speed - decelAmount) / speed);\n                this.velocity.x *= factor;\n                this.velocity.y *= factor;\n            }\n            else {\n                this.velocity.x = 0;\n                this.velocity.y = 0;\n            }\n        }\n        else {\n            // Moving toward target\n            const dx = this.targetPosition.x - this.position.x;\n            const dy = this.targetPosition.y - this.position.y;\n            const distanceToTarget = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n            if (distanceToTarget < 5) {\n                // Reached target\n                this.position.x = this.targetPosition.x;\n                this.position.y = this.targetPosition.y;\n                this.velocity.x = 0;\n                this.velocity.y = 0;\n                this.targetPosition = null;\n            }\n            else {\n                // Calculate desired velocity direction\n                let directionX = dx / distanceToTarget;\n                let directionY = dy / distanceToTarget;\n                // Add obstacle avoidance if gameState is provided\n                if (gameState) {\n                    const avoidanceDir = this.calculateObstacleAvoidance(gameState);\n                    if (avoidanceDir) {\n                        directionX += avoidanceDir.x * this.AVOIDANCE_BLEND_FACTOR;\n                        directionY += avoidanceDir.y * this.AVOIDANCE_BLEND_FACTOR;\n                        const length = Math.sqrt(directionX * directionX + directionY * directionY);\n                        if (length > 0) {\n                            directionX /= length;\n                            directionY /= length;\n                        }\n                    }\n                }\n                if (distanceToTarget <= this.slowRadiusPx) {\n                    const slowFactor = Math.max(0, distanceToTarget / this.slowRadiusPx);\n                    const desiredSpeed = this.maxSpeed * slowFactor;\n                    this.velocity.x = directionX * desiredSpeed;\n                    this.velocity.y = directionY * desiredSpeed;\n                }\n                else {\n                    // Apply acceleration toward target\n                    this.velocity.x += directionX * this.acceleration * deltaTime;\n                    this.velocity.y += directionY * this.acceleration * deltaTime;\n                    // Clamp to max speed\n                    const currentSpeed = Math.sqrt(Math.pow(this.velocity.x, 2) + Math.pow(this.velocity.y, 2));\n                    if (currentSpeed > this.maxSpeed) {\n                        this.velocity.x = (this.velocity.x / currentSpeed) * this.maxSpeed;\n                        this.velocity.y = (this.velocity.y / currentSpeed) * this.maxSpeed;\n                    }\n                }\n            }\n        }\n        // Update position\n        this.position.x += this.velocity.x * deltaTime;\n        this.position.y += this.velocity.y * deltaTime;\n    }\n    /**\n     * Calculate obstacle avoidance direction for smooth pathfinding\n     */\n    calculateObstacleAvoidance(gameState) {\n        let avoidX = 0;\n        let avoidY = 0;\n        let avoidCount = 0;\n        const avoidanceRange = 80; // Look ahead distance\n        // Check nearby obstacles\n        for (const sun of gameState.suns) {\n            const dx = this.position.x - sun.position.x;\n            const dy = this.position.y - sun.position.y;\n            const dist = Math.sqrt(dx * dx + dy * dy);\n            const minDist = sun.radius + this.radius + 10;\n            if (dist < minDist + avoidanceRange) {\n                const avoidStrength = (minDist + avoidanceRange - dist) / avoidanceRange;\n                avoidX += (dx / dist) * avoidStrength;\n                avoidY += (dy / dist) * avoidStrength;\n                avoidCount++;\n            }\n        }\n        // Check other forges and mirrors\n        for (const player of gameState.players) {\n            // Check other stellar forges\n            if (player.stellarForge && player.stellarForge !== this) {\n                const forge = player.stellarForge;\n                const dx = this.position.x - forge.position.x;\n                const dy = this.position.y - forge.position.y;\n                const dist = Math.sqrt(dx * dx + dy * dy);\n                const minDist = this.radius + forge.radius + 10;\n                if (dist < minDist + avoidanceRange && dist > 0) {\n                    const avoidStrength = (minDist + avoidanceRange - dist) / avoidanceRange;\n                    avoidX += (dx / dist) * avoidStrength;\n                    avoidY += (dy / dist) * avoidStrength;\n                    avoidCount++;\n                }\n            }\n            // Check mirrors\n            for (const mirror of player.solarMirrors) {\n                const dx = this.position.x - mirror.position.x;\n                const dy = this.position.y - mirror.position.y;\n                const dist = Math.sqrt(dx * dx + dy * dy);\n                const minDist = this.radius + 30;\n                if (dist < minDist + avoidanceRange) {\n                    const avoidStrength = (minDist + avoidanceRange - dist) / avoidanceRange;\n                    avoidX += (dx / dist) * avoidStrength;\n                    avoidY += (dy / dist) * avoidStrength;\n                    avoidCount++;\n                }\n            }\n        }\n        if (avoidCount > 0) {\n            const length = Math.sqrt(avoidX * avoidX + avoidY * avoidY);\n            if (length > 0) {\n                return new Vector2D(avoidX / length, avoidY / length);\n            }\n        }\n        return null;\n    }\n    /**\n     * Check if a crunch should happen and trigger it if ready\n     * Returns the amount of energy to use for spawning minions\n     */\n    shouldCrunch() {\n        if (this.crunchTimer <= 0 && this.health > 0 && this.isReceivingLight) {\n            this.crunchTimer = _constants__WEBPACK_IMPORTED_MODULE_0__.FORGE_CRUNCH_INTERVAL;\n            this.currentCrunch = new ForgeCrunch(new Vector2D(this.position.x, this.position.y));\n            this.currentCrunch.start();\n            // Rotate forge by 1/6 turn (60 degrees = /3 radians)\n            this.rotation += Math.PI / 3;\n            // Keep rotation within 0 to 2\n            if (this.rotation >= Math.PI * 2) {\n                this.rotation -= Math.PI * 2;\n            }\n            // Return the pending energy for minion spawning\n            const energyForMinions = this.pendingEnergy;\n            this.pendingEnergy = 0;\n            return energyForMinions;\n        }\n        return 0;\n    }\n    /**\n     * Add energy to pending amount (called when mirrors generate energy)\n     */\n    addPendingEnergy(amount) {\n        this.pendingEnergy += amount;\n    }\n    /**\n     * Get the current crunch effect if active\n     */\n    getCurrentCrunch() {\n        return this.currentCrunch;\n    }\n    /**\n     * Set movement target\n     */\n    setTarget(target) {\n        this.targetPosition = new Vector2D(target.x, target.y);\n    }\n    /**\n     * Toggle selection state\n     */\n    toggleSelection() {\n        this.isSelected = !this.isSelected;\n    }\n    /**\n     * Check if a point is inside the forge (for click detection)\n     */\n    containsPoint(point) {\n        const distance = this.position.distanceTo(point);\n        return distance <= this.radius;\n    }\n}\n/**\n * Base class for all buildings\n */\nclass Building {\n    constructor(position, owner, maxHealth, radius, attackRange, attackDamage, attackSpeed // attacks per second\n    ) {\n        this.position = position;\n        this.owner = owner;\n        this.radius = radius;\n        this.attackRange = attackRange;\n        this.attackDamage = attackDamage;\n        this.attackSpeed = attackSpeed;\n        this.attackCooldown = 0;\n        this.target = null;\n        this.buildProgress = 0; // 0 to 1, building is complete at 1\n        this.isComplete = false;\n        this.isSelected = false;\n        this.health = maxHealth;\n        this.maxHealth = maxHealth;\n    }\n    /**\n     * Update building logic\n     */\n    update(deltaTime, enemies, allUnits, asteroids = []) {\n        // Update attack cooldown\n        if (this.attackCooldown > 0) {\n            this.attackCooldown -= deltaTime;\n        }\n        // Only attack if building is complete\n        if (!this.isComplete) {\n            return;\n        }\n        // Find target if don't have one or current target is dead\n        if (!this.target || this.isTargetDead(this.target)) {\n            this.target = this.findNearestEnemy(enemies);\n        }\n        // Attack if target in range and cooldown ready\n        if (this.target && this.attackCooldown <= 0) {\n            const distance = this.position.distanceTo(this.target.position);\n            if (distance <= this.attackRange) {\n                this.attack(this.target);\n                this.attackCooldown = 1.0 / this.attackSpeed;\n            }\n        }\n    }\n    /**\n     * Check if target is dead\n     */\n    isTargetDead(target) {\n        if ('health' in target) {\n            return target.health <= 0;\n        }\n        return false;\n    }\n    /**\n     * Find nearest enemy\n     */\n    findNearestEnemy(enemies) {\n        let nearest = null;\n        let minDistance = Infinity;\n        for (const enemy of enemies) {\n            if ('health' in enemy && enemy.health <= 0)\n                continue;\n            const distance = this.position.distanceTo(enemy.position);\n            if (distance < minDistance) {\n                minDistance = distance;\n                nearest = enemy;\n            }\n        }\n        return nearest;\n    }\n    /**\n     * Attack target (to be overridden by subclasses)\n     */\n    attack(target) {\n        // Base implementation\n        if ('health' in target) {\n            target.health -= this.attackDamage;\n        }\n    }\n    /**\n     * Take damage\n     */\n    takeDamage(amount) {\n        this.health -= amount;\n    }\n    /**\n     * Check if building is destroyed\n     */\n    isDestroyed() {\n        return this.health <= 0;\n    }\n    /**\n     * Add build progress (from energy or mirror light)\n     */\n    addBuildProgress(amount) {\n        if (this.isComplete)\n            return;\n        this.buildProgress += amount;\n        if (this.buildProgress >= 1.0) {\n            this.buildProgress = 1.0;\n            this.isComplete = true;\n        }\n    }\n    /**\n     * Check if a point is within the building's radius\n     */\n    containsPoint(point) {\n        const distance = this.position.distanceTo(point);\n        return distance <= this.radius;\n    }\n    /**\n     * Check if this building can shoot (has a gun)\n     */\n    canShoot() {\n        // Only buildings with attack range and damage can shoot\n        return this.attackRange > 0 && this.attackDamage > 0;\n    }\n}\n/**\n * Cannon Building - Offensive building for Radiant faction\n * Fast-shooting defensive turret with visual effects like Marine\n */\nclass Minigun extends Building {\n    constructor(position, owner) {\n        super(position, owner, _constants__WEBPACK_IMPORTED_MODULE_0__.MINIGUN_MAX_HEALTH, _constants__WEBPACK_IMPORTED_MODULE_0__.MINIGUN_RADIUS, _constants__WEBPACK_IMPORTED_MODULE_0__.MINIGUN_ATTACK_RANGE, _constants__WEBPACK_IMPORTED_MODULE_0__.MINIGUN_ATTACK_DAMAGE, _constants__WEBPACK_IMPORTED_MODULE_0__.MINIGUN_ATTACK_SPEED);\n        this.lastShotEffects = {};\n    }\n    /**\n     * Attack with visual effects like Marine\n     */\n    attack(target) {\n        // Apply damage\n        super.attack(target);\n        // Calculate angle to target\n        const dx = target.position.x - this.position.x;\n        const dy = target.position.y - this.position.y;\n        const angle = Math.atan2(dy, dx);\n        // Create muzzle flash\n        this.lastShotEffects.muzzleFlash = new MuzzleFlash(new Vector2D(this.position.x, this.position.y), angle);\n        // Create bullet casing with slight angle deviation\n        const casingAngle = angle + Math.PI / 2 + (Math.random() - 0.5) * 0.5;\n        const casingSpeed = _constants__WEBPACK_IMPORTED_MODULE_0__.BULLET_CASING_SPEED_MIN +\n            Math.random() * (_constants__WEBPACK_IMPORTED_MODULE_0__.BULLET_CASING_SPEED_MAX - _constants__WEBPACK_IMPORTED_MODULE_0__.BULLET_CASING_SPEED_MIN);\n        this.lastShotEffects.casing = new BulletCasing(new Vector2D(this.position.x, this.position.y), new Vector2D(Math.cos(casingAngle) * casingSpeed, Math.sin(casingAngle) * casingSpeed));\n        // Create bouncing bullet at target position\n        const bounceAngle = angle + Math.PI + (Math.random() - 0.5) * 1.0;\n        const bounceSpeed = _constants__WEBPACK_IMPORTED_MODULE_0__.BOUNCING_BULLET_SPEED_MIN +\n            Math.random() * (_constants__WEBPACK_IMPORTED_MODULE_0__.BOUNCING_BULLET_SPEED_MAX - _constants__WEBPACK_IMPORTED_MODULE_0__.BOUNCING_BULLET_SPEED_MIN);\n        this.lastShotEffects.bouncingBullet = new BouncingBullet(new Vector2D(target.position.x, target.position.y), new Vector2D(Math.cos(bounceAngle) * bounceSpeed, Math.sin(bounceAngle) * bounceSpeed));\n    }\n    /**\n     * Get effects from last shot (for game state to manage)\n     */\n    getAndClearLastShotEffects() {\n        const effects = this.lastShotEffects;\n        this.lastShotEffects = {};\n        return effects;\n    }\n}\n/**\n * Space Dust Swirler Building - Defensive building for Radiant faction\n * Swirls space dust in counter-clockwise orbits and deflects non-melee projectiles\n */\n/**\n * Space Dust Swirler Building - Defensive building that absorbs projectiles\n * Swirls space dust in counter-clockwise orbits and absorbs projectiles within its influence radius.\n * The radius starts at half the max and grows over time, but shrinks when projectiles are absorbed.\n */\nclass SpaceDustSwirler extends Building {\n    constructor(position, owner) {\n        super(position, owner, _constants__WEBPACK_IMPORTED_MODULE_0__.SWIRLER_MAX_HEALTH, _constants__WEBPACK_IMPORTED_MODULE_0__.SWIRLER_RADIUS, _constants__WEBPACK_IMPORTED_MODULE_0__.SWIRLER_ATTACK_RANGE, _constants__WEBPACK_IMPORTED_MODULE_0__.SWIRLER_ATTACK_DAMAGE, _constants__WEBPACK_IMPORTED_MODULE_0__.SWIRLER_ATTACK_SPEED);\n        // Start with half the max radius\n        const initialRadius = _constants__WEBPACK_IMPORTED_MODULE_0__.SWIRLER_INFLUENCE_RADIUS * _constants__WEBPACK_IMPORTED_MODULE_0__.SWIRLER_INITIAL_RADIUS_MULTIPLIER;\n        this.currentInfluenceRadius = initialRadius;\n        this.targetInfluenceRadius = initialRadius;\n    }\n    /**\n     * Update swirler state (called each frame)\n     */\n    update(deltaTime, enemies, allUnits, asteroids = []) {\n        super.update(deltaTime, enemies, allUnits, asteroids);\n        // Only grow radius if building is complete\n        if (this.isComplete) {\n            // Grow target radius towards max over time\n            if (this.targetInfluenceRadius < _constants__WEBPACK_IMPORTED_MODULE_0__.SWIRLER_INFLUENCE_RADIUS) {\n                this.targetInfluenceRadius = Math.min(this.targetInfluenceRadius + _constants__WEBPACK_IMPORTED_MODULE_0__.SWIRLER_GROWTH_RATE_PER_SEC * deltaTime, _constants__WEBPACK_IMPORTED_MODULE_0__.SWIRLER_INFLUENCE_RADIUS);\n            }\n            // Smoothly interpolate current radius towards target radius\n            const radiusDiff = this.targetInfluenceRadius - this.currentInfluenceRadius;\n            if (Math.abs(radiusDiff) > 0.1) {\n                // Smooth transition: move 20% of the way to target each frame (exponential smoothing)\n                this.currentInfluenceRadius += radiusDiff * 0.2;\n            }\n            else {\n                this.currentInfluenceRadius = this.targetInfluenceRadius;\n            }\n        }\n    }\n    /**\n     * Apply swirling force to space dust particles within influence radius\n     */\n    applyDustSwirl(particles, deltaTime) {\n        if (!this.isComplete)\n            return;\n        for (const particle of particles) {\n            const dx = particle.position.x - this.position.x;\n            const dy = particle.position.y - this.position.y;\n            const distance = Math.sqrt(dx * dx + dy * dy);\n            // Only affect particles within current influence radius\n            if (distance > this.currentInfluenceRadius || distance < 1)\n                continue;\n            // Calculate tangential (counter-clockwise) direction\n            // Counter-clockwise perpendicular: (dy, -dx) normalized\n            const tangentX = dy / distance;\n            const tangentY = -dx / distance;\n            // Calculate speed based on distance (faster closer to tower)\n            const normalizedDistance = distance / this.currentInfluenceRadius;\n            const speedMultiplier = _constants__WEBPACK_IMPORTED_MODULE_0__.SWIRLER_DUST_SPEED_MULTIPLIER * (1 - normalizedDistance);\n            const orbitSpeed = _constants__WEBPACK_IMPORTED_MODULE_0__.SWIRLER_DUST_ORBIT_SPEED_BASE * (1 + speedMultiplier);\n            // Apply tangential velocity (straight orbit, not spiral)\n            particle.velocity.x = tangentX * orbitSpeed;\n            particle.velocity.y = tangentY * orbitSpeed;\n        }\n    }\n    /**\n     * Check if a projectile should be absorbed\n     * Returns true if projectile was absorbed (should be removed from game)\n     */\n    absorbProjectile(projectile) {\n        if (!this.isComplete)\n            return false;\n        const dx = projectile.position.x - this.position.x;\n        const dy = projectile.position.y - this.position.y;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        // Only absorb projectiles within current influence radius\n        if (distance > this.currentInfluenceRadius)\n            return false;\n        // Shrink the target radius based on projectile damage\n        // Different projectile types store damage differently\n        let projectileDamage = 5; // Default damage\n        if ('damage' in projectile && typeof projectile.damage === 'number') {\n            projectileDamage = projectile.damage;\n        }\n        else if (projectile.constructor.name === 'GraveProjectile') {\n            // Grave projectiles use GRAVE_ATTACK_DAMAGE\n            projectileDamage = _constants__WEBPACK_IMPORTED_MODULE_0__.GRAVE_ATTACK_DAMAGE;\n        }\n        else if (projectile.constructor.name === 'InfluenceBallProjectile') {\n            // Influence ball projectiles don't do direct damage, use a default value\n            projectileDamage = 10;\n        }\n        const shrinkAmount = _constants__WEBPACK_IMPORTED_MODULE_0__.SWIRLER_SHRINK_BASE_RATE + (projectileDamage * _constants__WEBPACK_IMPORTED_MODULE_0__.SWIRLER_SHRINK_DAMAGE_MULTIPLIER);\n        this.targetInfluenceRadius = Math.max(this.targetInfluenceRadius - shrinkAmount, _constants__WEBPACK_IMPORTED_MODULE_0__.SWIRLER_MIN_INFLUENCE_RADIUS);\n        return true; // Projectile absorbed\n    }\n    /**\n     * Legacy method for backward compatibility - now calls absorbProjectile\n     */\n    deflectProjectile(projectile) {\n        return this.absorbProjectile(projectile);\n    }\n}\n/**\n * Foundry Building - Production building\n * Can produce solar mirrors and special units. Only one can exist at a time.\n */\nclass SubsidiaryFactory extends Building {\n    constructor(position, owner) {\n        super(position, owner, _constants__WEBPACK_IMPORTED_MODULE_0__.SUBSIDIARY_FACTORY_MAX_HEALTH, _constants__WEBPACK_IMPORTED_MODULE_0__.SUBSIDIARY_FACTORY_RADIUS, _constants__WEBPACK_IMPORTED_MODULE_0__.SUBSIDIARY_FACTORY_ATTACK_RANGE, _constants__WEBPACK_IMPORTED_MODULE_0__.SUBSIDIARY_FACTORY_ATTACK_DAMAGE, _constants__WEBPACK_IMPORTED_MODULE_0__.SUBSIDIARY_FACTORY_ATTACK_SPEED);\n        this.productionTimer = 0;\n        this.productionQueue = []; // Queue of items to produce\n        this.currentProduction = null; // Currently producing item\n        this.productionProgress = 0; // Progress of current production (0-1)\n    }\n    /**\n     * Update production timer\n     * Note: SubsidiaryFactory is a production building with no attack capability,\n     * so we don't call super.update() which handles attack logic.\n     */\n    update(deltaTime, enemies, allUnits) {\n        // Only produce when complete\n        if (!this.isComplete)\n            return;\n        // Start production if idle\n        if (!this.currentProduction && this.productionQueue.length > 0) {\n            this.currentProduction = this.productionQueue.shift() || null;\n            this.productionProgress = 0;\n        }\n        // Advance production\n        if (this.currentProduction) {\n            const productionTime = this.getProductionTime(this.currentProduction);\n            this.productionProgress += deltaTime / productionTime;\n            if (this.productionProgress >= 1.0) {\n                // Production complete\n                this.productionProgress = 0;\n                this.currentProduction = null;\n            }\n        }\n    }\n    /**\n     * Enqueue an item for production\n     */\n    enqueueProduction(itemType) {\n        this.productionQueue.push(itemType);\n    }\n    /**\n     * Get the completed item and clear it\n     */\n    getCompletedProduction() {\n        if (this.currentProduction && this.productionProgress >= 1.0) {\n            const completed = this.currentProduction;\n            this.currentProduction = null;\n            this.productionProgress = 0;\n            return completed;\n        }\n        return null;\n    }\n    /**\n     * Get production time for an item type\n     */\n    getProductionTime(itemType) {\n        if (itemType === 'solar-mirror') {\n            return _constants__WEBPACK_IMPORTED_MODULE_0__.BUILDING_BUILD_TIME;\n        }\n        return _constants__WEBPACK_IMPORTED_MODULE_0__.SUBSIDIARY_FACTORY_PRODUCTION_INTERVAL;\n    }\n}\n/**\n * Sun/Star - Light source\n */\nclass Sun {\n    constructor(position, intensity = 1.0, radius = 100.0) {\n        this.position = position;\n        this.intensity = intensity;\n        this.radius = radius;\n    }\n    /**\n     * Emit a light ray in specified direction\n     */\n    emitLight(direction) {\n        return new LightRay(this.position, direction, this.intensity);\n    }\n}\n/**\n * Player in the game\n */\nclass Player {\n    constructor(name, faction) {\n        this.name = name;\n        this.faction = faction;\n        this.energy = 100.0; // Starting currency\n        this.stellarForge = null;\n        this.solarMirrors = [];\n        this.units = [];\n        this.buildings = []; // Offensive and defensive buildings\n        this.isAi = false;\n        this.aiNextMirrorCommandSec = 0;\n        this.aiNextDefenseCommandSec = 0;\n        this.aiNextHeroCommandSec = 0;\n        this.aiNextStructureCommandSec = 0;\n        this.aiNextMirrorPurchaseCommandSec = 0;\n        this.aiStrategy = _constants__WEBPACK_IMPORTED_MODULE_0__.AIStrategy.ECONOMIC; // AI build strategy (randomly assigned in createStandardGame for AI players)\n        // Statistics tracking\n        this.unitsCreated = 0;\n        this.unitsLost = 0;\n        this.energyGathered = 0;\n    }\n    /**\n     * Check if player is defeated\n     */\n    isDefeated() {\n        return this.stellarForge === null || this.stellarForge.health <= 0;\n    }\n    /**\n     * Add Energy to player's resources\n     */\n    addEnergy(amount) {\n        this.energy += amount;\n        this.energyGathered += amount;\n    }\n    /**\n     * Attempt to spend Energy\n     */\n    spendEnergy(amount) {\n        if (this.energy >= amount) {\n            this.energy -= amount;\n            return true;\n        }\n        return false;\n    }\n}\nclass SpaceDustParticle {\n    constructor(position, velocity, palette) {\n        this.position = position;\n        this.glowState = _constants__WEBPACK_IMPORTED_MODULE_0__.DUST_GLOW_STATE_NORMAL;\n        this.glowTransition = 0; // 0-1 transition between states\n        this.targetGlowState = _constants__WEBPACK_IMPORTED_MODULE_0__.DUST_GLOW_STATE_NORMAL;\n        this.lastMovementTime = 0; // Time since last significant movement\n        this.baseColor = SpaceDustParticle.generateBaseColor(palette);\n        this.currentColor = this.baseColor;\n        // Initialize with very slow random velocity\n        if (velocity) {\n            this.velocity = velocity;\n        }\n        else {\n            this.velocity = new Vector2D((Math.random() - 0.5) * 2, // -1 to 1\n            (Math.random() - 0.5) * 2);\n        }\n    }\n    /**\n     * Update particle position based on velocity\n     */\n    update(deltaTime) {\n        this.position.x += this.velocity.x * deltaTime;\n        this.position.y += this.velocity.y * deltaTime;\n        // Check if particle is moving significantly\n        const speed = Math.sqrt(Math.pow(this.velocity.x, 2) + Math.pow(this.velocity.y, 2));\n        if (speed > _constants__WEBPACK_IMPORTED_MODULE_0__.DUST_FAST_MOVEMENT_THRESHOLD) {\n            // Fast movement - trigger full glow\n            this.targetGlowState = _constants__WEBPACK_IMPORTED_MODULE_0__.DUST_GLOW_STATE_FULL;\n            this.lastMovementTime = Date.now();\n        }\n        else if (speed > _constants__WEBPACK_IMPORTED_MODULE_0__.DUST_SLOW_MOVEMENT_THRESHOLD) {\n            // Some movement - maintain current glow or go to slight glow\n            if (this.glowState < _constants__WEBPACK_IMPORTED_MODULE_0__.DUST_GLOW_STATE_SLIGHT) {\n                this.targetGlowState = _constants__WEBPACK_IMPORTED_MODULE_0__.DUST_GLOW_STATE_SLIGHT;\n            }\n            this.lastMovementTime = Date.now();\n        }\n        else {\n            // Slow/no movement - fade back to normal based on time since last movement\n            const timeSinceMovement = Date.now() - this.lastMovementTime;\n            if (timeSinceMovement > _constants__WEBPACK_IMPORTED_MODULE_0__.DUST_FADE_TO_NORMAL_DELAY_MS) {\n                // After 2 seconds of slow movement, start fading to normal\n                this.targetGlowState = _constants__WEBPACK_IMPORTED_MODULE_0__.DUST_GLOW_STATE_NORMAL;\n            }\n            else if (timeSinceMovement > _constants__WEBPACK_IMPORTED_MODULE_0__.DUST_FADE_TO_SLIGHT_DELAY_MS && this.glowState === _constants__WEBPACK_IMPORTED_MODULE_0__.DUST_GLOW_STATE_FULL) {\n                // After 1 second, fade from full glow to slight glow\n                this.targetGlowState = _constants__WEBPACK_IMPORTED_MODULE_0__.DUST_GLOW_STATE_SLIGHT;\n            }\n        }\n        // Smooth transition between glow states\n        const transitionSpeed = this.glowState < this.targetGlowState ? _constants__WEBPACK_IMPORTED_MODULE_0__.DUST_GLOW_TRANSITION_SPEED_UP : _constants__WEBPACK_IMPORTED_MODULE_0__.DUST_GLOW_TRANSITION_SPEED_DOWN;\n        if (this.glowState < this.targetGlowState) {\n            this.glowTransition += deltaTime * transitionSpeed;\n            if (this.glowTransition >= 1.0) {\n                this.glowState = this.targetGlowState;\n                this.glowTransition = 0;\n            }\n        }\n        else if (this.glowState > this.targetGlowState) {\n            this.glowTransition += deltaTime * transitionSpeed;\n            if (this.glowTransition >= 1.0) {\n                this.glowState = this.targetGlowState;\n                this.glowTransition = 0;\n            }\n        }\n        // Apply friction to gradually slow down\n        this.velocity.x *= 0.98;\n        this.velocity.y *= 0.98;\n        const driftSpeed = Math.sqrt(Math.pow(this.velocity.x, 2) + Math.pow(this.velocity.y, 2));\n        if (driftSpeed < _constants__WEBPACK_IMPORTED_MODULE_0__.DUST_MIN_VELOCITY) {\n            if (driftSpeed === 0) {\n                this.velocity.x = _constants__WEBPACK_IMPORTED_MODULE_0__.DUST_MIN_VELOCITY;\n                this.velocity.y = 0;\n            }\n            else {\n                const driftScale = _constants__WEBPACK_IMPORTED_MODULE_0__.DUST_MIN_VELOCITY / driftSpeed;\n                this.velocity.x *= driftScale;\n                this.velocity.y *= driftScale;\n            }\n        }\n    }\n    /**\n     * Apply force to particle (from units or attacks)\n     */\n    applyForce(force) {\n        this.velocity.x += force.x;\n        this.velocity.y += force.y;\n    }\n    /**\n     * Update color based on influence\n     */\n    updateColor(influenceColor, blendFactor) {\n        if (influenceColor && blendFactor > 0) {\n            // Blend from gray to influence color\n            this.currentColor = this.blendColors(this.baseColor, influenceColor, blendFactor);\n        }\n        else {\n            this.currentColor = this.baseColor;\n        }\n    }\n    /**\n     * Blend two hex colors\n     */\n    blendColors(color1, color2, factor) {\n        // Validate hex color format\n        if (!color1 || !color2 || !color1.startsWith('#') || !color2.startsWith('#')) {\n            return this.baseColor;\n        }\n        // Simple hex color blending\n        const c1 = parseInt(color1.slice(1), 16);\n        const c2 = parseInt(color2.slice(1), 16);\n        if (isNaN(c1) || isNaN(c2)) {\n            return this.baseColor;\n        }\n        const r1 = (c1 >> 16) & 0xff;\n        const g1 = (c1 >> 8) & 0xff;\n        const b1 = c1 & 0xff;\n        const r2 = (c2 >> 16) & 0xff;\n        const g2 = (c2 >> 8) & 0xff;\n        const b2 = c2 & 0xff;\n        const r = Math.round(r1 + (r2 - r1) * factor);\n        const g = Math.round(g1 + (g2 - g1) * factor);\n        const b = Math.round(b1 + (b2 - b1) * factor);\n        return `#${((r << 16) | (g << 8) | b).toString(16).padStart(6, '0')}`;\n    }\n    static generateBaseColor(palette) {\n        if (palette && palette.neutral.length > 0) {\n            const paletteRoll = Math.random();\n            const useAccent = paletteRoll > 0.7 && palette.accent.length > 0;\n            const selection = useAccent ? palette.accent : palette.neutral;\n            const colorIndex = Math.floor(Math.random() * selection.length);\n            return selection[colorIndex];\n        }\n        const baseShade = 85 + Math.random() * 110;\n        let r = baseShade;\n        let g = baseShade;\n        let b = baseShade;\n        const tintRoll = Math.random();\n        if (tintRoll < 0.18) {\n            r = baseShade - 8;\n            g = baseShade - 4;\n            b = baseShade + 14;\n        }\n        else if (tintRoll < 0.28) {\n            r = baseShade + 10;\n            g = baseShade - 10;\n            b = baseShade + 12;\n        }\n        const clamp = (value) => Math.max(0, Math.min(255, Math.round(value)));\n        const red = clamp(r);\n        const green = clamp(g);\n        const blue = clamp(b);\n        return `#${((red << 16) | (green << 8) | blue).toString(16).padStart(6, '0')}`;\n    }\n}\n/**\n * Forge crunch effect - periodic event that sucks in dust then pushes it out\n * Used when the forge \"crunches\" to spawn minions\n */\nclass ForgeCrunch {\n    constructor(position) {\n        this.position = position;\n        this.phase = 'idle';\n        this.phaseTimer = 0;\n    }\n    /**\n     * Start a new crunch cycle\n     */\n    start() {\n        this.phase = 'suck';\n        this.phaseTimer = _constants__WEBPACK_IMPORTED_MODULE_0__.FORGE_CRUNCH_SUCK_DURATION;\n    }\n    /**\n     * Update crunch phase timers\n     */\n    update(deltaTime) {\n        if (this.phase === 'idle')\n            return;\n        this.phaseTimer -= deltaTime;\n        if (this.phaseTimer <= 0) {\n            if (this.phase === 'suck') {\n                // Transition from suck to wave\n                this.phase = 'wave';\n                this.phaseTimer = _constants__WEBPACK_IMPORTED_MODULE_0__.FORGE_CRUNCH_WAVE_DURATION;\n            }\n            else if (this.phase === 'wave') {\n                // Crunch complete\n                this.phase = 'idle';\n                this.phaseTimer = 0;\n            }\n        }\n    }\n    /**\n     * Check if crunch is active\n     */\n    isActive() {\n        return this.phase !== 'idle';\n    }\n    /**\n     * Get current phase progress (0-1)\n     */\n    getPhaseProgress() {\n        if (this.phase === 'idle')\n            return 0;\n        const totalDuration = this.phase === 'suck'\n            ? _constants__WEBPACK_IMPORTED_MODULE_0__.FORGE_CRUNCH_SUCK_DURATION\n            : _constants__WEBPACK_IMPORTED_MODULE_0__.FORGE_CRUNCH_WAVE_DURATION;\n        return 1.0 - (this.phaseTimer / totalDuration);\n    }\n}\n/**\n * Bullet casing that ejects from weapons and interacts with space dust\n */\nclass BulletCasing {\n    constructor(position, velocity) {\n        this.position = position;\n        this.rotation = 0;\n        this.lifetime = 0;\n        this.maxLifetime = _constants__WEBPACK_IMPORTED_MODULE_0__.BULLET_CASING_LIFETIME;\n        this.velocity = velocity;\n        this.rotationSpeed = (Math.random() - 0.5) * 10; // Random spin\n    }\n    /**\n     * Update casing position and physics\n     */\n    update(deltaTime) {\n        this.position.x += this.velocity.x * deltaTime;\n        this.position.y += this.velocity.y * deltaTime;\n        this.rotation += this.rotationSpeed * deltaTime;\n        // Apply friction\n        this.velocity.x *= 0.95;\n        this.velocity.y *= 0.95;\n        this.lifetime += deltaTime;\n    }\n    /**\n     * Check if casing should be removed\n     */\n    shouldDespawn() {\n        return this.lifetime >= this.maxLifetime;\n    }\n    /**\n     * Apply collision response when hitting spacedust\n     */\n    applyCollision(force) {\n        this.velocity.x += force.x * _constants__WEBPACK_IMPORTED_MODULE_0__.CASING_COLLISION_DAMPING;\n        this.velocity.y += force.y * _constants__WEBPACK_IMPORTED_MODULE_0__.CASING_COLLISION_DAMPING;\n    }\n}\n/**\n * Muzzle flash effect when firing\n */\nclass MuzzleFlash {\n    constructor(position, angle) {\n        this.position = position;\n        this.angle = angle;\n        this.lifetime = 0;\n        this.maxLifetime = _constants__WEBPACK_IMPORTED_MODULE_0__.MUZZLE_FLASH_DURATION;\n    }\n    /**\n     * Update flash lifetime\n     */\n    update(deltaTime) {\n        this.lifetime += deltaTime;\n    }\n    /**\n     * Check if flash should be removed\n     */\n    shouldDespawn() {\n        return this.lifetime >= this.maxLifetime;\n    }\n}\n/**\n * Bouncing bullet that appears when hitting an enemy\n */\nclass BouncingBullet {\n    constructor(position, velocity) {\n        this.position = position;\n        this.lifetime = 0;\n        this.maxLifetime = _constants__WEBPACK_IMPORTED_MODULE_0__.BOUNCING_BULLET_LIFETIME;\n        this.velocity = velocity;\n    }\n    /**\n     * Update bullet position\n     */\n    update(deltaTime) {\n        this.position.x += this.velocity.x * deltaTime;\n        this.position.y += this.velocity.y * deltaTime;\n        // Apply gravity-like effect\n        this.velocity.y += 100 * deltaTime;\n        // Apply friction\n        this.velocity.x *= 0.98;\n        this.velocity.y *= 0.98;\n        this.lifetime += deltaTime;\n    }\n    /**\n     * Check if bullet should be removed\n     */\n    shouldDespawn() {\n        return this.lifetime >= this.maxLifetime;\n    }\n}\n/**\n * Ability bullet for special attacks\n */\nclass AbilityBullet {\n    constructor(position, velocity, owner, damage = _constants__WEBPACK_IMPORTED_MODULE_0__.MARINE_ABILITY_BULLET_DAMAGE) {\n        this.position = position;\n        this.owner = owner;\n        this.damage = damage;\n        this.lifetime = 0;\n        this.maxLifetime = _constants__WEBPACK_IMPORTED_MODULE_0__.MARINE_ABILITY_BULLET_LIFETIME;\n        this.maxRange = Infinity; // Optional max range in pixels (default: no limit)\n        this.velocity = velocity;\n        this.startPosition = new Vector2D(position.x, position.y);\n    }\n    /**\n     * Update bullet position\n     */\n    update(deltaTime) {\n        this.position.x += this.velocity.x * deltaTime;\n        this.position.y += this.velocity.y * deltaTime;\n        this.lifetime += deltaTime;\n    }\n    /**\n     * Check if bullet should be removed\n     */\n    shouldDespawn() {\n        // Check lifetime\n        if (this.lifetime >= this.maxLifetime) {\n            return true;\n        }\n        // Check max range\n        const distanceTraveled = this.startPosition.distanceTo(this.position);\n        if (distanceTraveled >= this.maxRange) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Check if bullet hits a target\n     */\n    checkHit(target) {\n        const distance = this.position.distanceTo(target.position);\n        return distance < 10; // Hit radius\n    }\n}\n/**\n * Minion projectile fired by Starlings\n */\nclass MinionProjectile {\n    constructor(position, velocity, owner, damage, maxRangePx = _constants__WEBPACK_IMPORTED_MODULE_0__.STARLING_PROJECTILE_MAX_RANGE_PX) {\n        this.position = position;\n        this.owner = owner;\n        this.damage = damage;\n        this.distanceTraveledPx = 0;\n        this.velocity = velocity;\n        this.maxRangePx = maxRangePx;\n    }\n    update(deltaTime) {\n        const moveX = this.velocity.x * deltaTime;\n        const moveY = this.velocity.y * deltaTime;\n        this.position.x += moveX;\n        this.position.y += moveY;\n        this.distanceTraveledPx += Math.sqrt(moveX * moveX + moveY * moveY);\n    }\n    shouldDespawn() {\n        return this.distanceTraveledPx >= this.maxRangePx;\n    }\n    checkHit(target) {\n        const distance = this.position.distanceTo(target.position);\n        return distance < _constants__WEBPACK_IMPORTED_MODULE_0__.STARLING_PROJECTILE_HIT_RADIUS_PX;\n    }\n}\n/**\n * Laser beam fired by Starlings (instant hit-scan weapon)\n */\nclass LaserBeam {\n    constructor(startPos, endPos, owner, damage) {\n        this.startPos = startPos;\n        this.endPos = endPos;\n        this.owner = owner;\n        this.damage = damage;\n        this.lifetime = 0;\n        this.maxLifetime = 0.1; // 100ms visible duration\n    }\n    update(deltaTime) {\n        this.lifetime += deltaTime;\n        return this.lifetime >= this.maxLifetime;\n    }\n}\n/**\n * Impact particle spawned at laser beam endpoint\n */\nclass ImpactParticle {\n    constructor(position, velocity, maxLifetime, faction) {\n        this.position = position;\n        this.velocity = velocity;\n        this.maxLifetime = maxLifetime;\n        this.faction = faction;\n        this.lifetime = 0;\n    }\n    update(deltaTime) {\n        this.position.x += this.velocity.x * deltaTime;\n        this.position.y += this.velocity.y * deltaTime;\n        this.lifetime += deltaTime;\n    }\n    shouldDespawn() {\n        return this.lifetime >= this.maxLifetime;\n    }\n}\n/**\n * Base Unit class\n */\nclass Unit {\n    constructor(position, owner, maxHealth, attackRange, attackDamage, attackSpeed, // attacks per second\n    abilityCooldownTime = 5.0, // Default ability cooldown time\n    collisionRadiusPx = _constants__WEBPACK_IMPORTED_MODULE_0__.UNIT_RADIUS_PX) {\n        this.position = position;\n        this.owner = owner;\n        this.attackRange = attackRange;\n        this.attackDamage = attackDamage;\n        this.attackSpeed = attackSpeed;\n        this.abilityCooldownTime = abilityCooldownTime;\n        this.attackCooldown = 0;\n        this.abilityCooldown = 0; // Cooldown for special ability\n        this.target = null;\n        this.rallyPoint = null;\n        this.lastAbilityEffects = [];\n        this.isHero = false; // Flag to mark unit as hero\n        this.moveOrder = 0; // Movement order indicator (0 = no order)\n        this.rotation = 0; // Current facing angle in radians\n        this.velocity = new Vector2D(0, 0);\n        this.waypoints = []; // Path waypoints to follow\n        this.currentWaypointIndex = 0; // Current waypoint in path\n        this.stunDuration = 0; // Duration of stun effect in seconds\n        this.health = maxHealth;\n        this.maxHealth = maxHealth;\n        this.collisionRadiusPx = collisionRadiusPx;\n    }\n    /**\n     * Update unit logic\n     */\n    update(deltaTime, enemies, allUnits, asteroids = []) {\n        // Update attack cooldown\n        if (this.attackCooldown > 0) {\n            this.attackCooldown -= deltaTime;\n        }\n        // Update ability cooldown\n        if (this.abilityCooldown > 0) {\n            this.abilityCooldown -= deltaTime;\n        }\n        // Update stun duration\n        if (this.stunDuration > 0) {\n            this.stunDuration -= deltaTime;\n            // While stunned, can't move or attack\n            return;\n        }\n        this.moveTowardRallyPoint(deltaTime, _constants__WEBPACK_IMPORTED_MODULE_0__.UNIT_MOVE_SPEED, allUnits, asteroids);\n        // Find target if don't have one or current target is dead\n        if (!this.target || this.isTargetDead(this.target)) {\n            this.target = this.findNearestEnemy(enemies);\n        }\n        // Attack if target in range and cooldown ready\n        if (this.target && this.attackCooldown <= 0) {\n            const distance = this.position.distanceTo(this.target.position);\n            if (distance <= this.attackRange) {\n                this.attack(this.target);\n                this.attackCooldown = 1.0 / this.attackSpeed;\n            }\n        }\n        // Rotate to face target when attacking (overrides movement rotation)\n        if (this.target && !this.isTargetDead(this.target)) {\n            const distance = this.position.distanceTo(this.target.position);\n            if (distance <= this.attackRange) {\n                const dx = this.target.position.x - this.position.x;\n                const dy = this.target.position.y - this.position.y;\n                const targetRotation = Math.atan2(dy, dx) + Math.PI / 2;\n                const rotationDelta = this.getShortestAngleDelta(this.rotation, targetRotation);\n                const maxRotationStep = _constants__WEBPACK_IMPORTED_MODULE_0__.UNIT_TURN_SPEED_RAD_PER_SEC * deltaTime;\n                if (Math.abs(rotationDelta) <= maxRotationStep) {\n                    this.rotation = targetRotation;\n                }\n                else {\n                    this.rotation += Math.sign(rotationDelta) * maxRotationStep;\n                }\n                // Normalize rotation to [0, 2)\n                this.rotation = ((this.rotation % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);\n            }\n        }\n    }\n    /**\n     * Set a path for the unit to follow through multiple waypoints\n     */\n    setPath(waypoints) {\n        this.waypoints = waypoints.map(wp => new Vector2D(wp.x, wp.y));\n        this.currentWaypointIndex = 0;\n        if (this.waypoints.length > 0) {\n            this.rallyPoint = this.waypoints[0];\n        }\n    }\n    moveTowardRallyPoint(deltaTime, moveSpeed, allUnits, asteroids = []) {\n        if (!this.rallyPoint) {\n            this.velocity.x = 0;\n            this.velocity.y = 0;\n            return;\n        }\n        const dx = this.rallyPoint.x - this.position.x;\n        const dy = this.rallyPoint.y - this.position.y;\n        const distanceToTarget = Math.sqrt(dx * dx + dy * dy);\n        if (distanceToTarget <= _constants__WEBPACK_IMPORTED_MODULE_0__.UNIT_ARRIVAL_THRESHOLD) {\n            // Check if there are more waypoints to follow\n            if (this.waypoints.length > 0 && this.currentWaypointIndex < this.waypoints.length - 1) {\n                // Move to next waypoint\n                this.currentWaypointIndex++;\n                this.rallyPoint = this.waypoints[this.currentWaypointIndex];\n                return;\n            }\n            else {\n                // No more waypoints, clear everything\n                this.rallyPoint = null;\n                this.waypoints = [];\n                this.currentWaypointIndex = 0;\n                this.velocity.x = 0;\n                this.velocity.y = 0;\n                return;\n            }\n        }\n        let directionX = dx / distanceToTarget;\n        let directionY = dy / distanceToTarget;\n        const avoidanceRangePx = _constants__WEBPACK_IMPORTED_MODULE_0__.UNIT_AVOIDANCE_RANGE_PX;\n        const avoidanceRangeSq = avoidanceRangePx * avoidanceRangePx;\n        let avoidanceX = 0;\n        let avoidanceY = 0;\n        for (let i = 0; i < allUnits.length; i++) {\n            const otherUnit = allUnits[i];\n            if (otherUnit === this || otherUnit.isDead()) {\n                continue;\n            }\n            const offsetX = this.position.x - otherUnit.position.x;\n            const offsetY = this.position.y - otherUnit.position.y;\n            const distanceSq = offsetX * offsetX + offsetY * offsetY;\n            if (distanceSq > 0 && distanceSq < avoidanceRangeSq) {\n                const distance = Math.sqrt(distanceSq);\n                const strength = (avoidanceRangePx - distance) / avoidanceRangePx;\n                let weight = strength;\n                if (this.isHero && !otherUnit.isHero) {\n                    weight *= _constants__WEBPACK_IMPORTED_MODULE_0__.UNIT_HERO_AVOIDANCE_MULTIPLIER;\n                }\n                else if (!this.isHero && otherUnit.isHero) {\n                    weight *= _constants__WEBPACK_IMPORTED_MODULE_0__.UNIT_MINION_YIELD_MULTIPLIER;\n                }\n                avoidanceX += (offsetX / distance) * weight;\n                avoidanceY += (offsetY / distance) * weight;\n            }\n        }\n        const avoidanceLength = Math.sqrt(avoidanceX * avoidanceX + avoidanceY * avoidanceY);\n        if (avoidanceLength > 0) {\n            avoidanceX /= avoidanceLength;\n            avoidanceY /= avoidanceLength;\n        }\n        let asteroidAvoidanceX = 0;\n        let asteroidAvoidanceY = 0;\n        const lookaheadPx = _constants__WEBPACK_IMPORTED_MODULE_0__.UNIT_ASTEROID_AVOIDANCE_LOOKAHEAD_PX;\n        const bufferPx = _constants__WEBPACK_IMPORTED_MODULE_0__.UNIT_ASTEROID_AVOIDANCE_BUFFER_PX;\n        for (let i = 0; i < asteroids.length; i++) {\n            const asteroid = asteroids[i];\n            const toAsteroidX = asteroid.position.x - this.position.x;\n            const toAsteroidY = asteroid.position.y - this.position.y;\n            const projection = toAsteroidX * directionX + toAsteroidY * directionY;\n            const avoidanceRadius = asteroid.size + this.collisionRadiusPx + bufferPx;\n            const avoidanceRadiusSq = avoidanceRadius * avoidanceRadius;\n            if (projection > 0 && projection < lookaheadPx) {\n                const perpendicularX = toAsteroidX - directionX * projection;\n                const perpendicularY = toAsteroidY - directionY * projection;\n                const perpendicularDistanceSq = perpendicularX * perpendicularX + perpendicularY * perpendicularY;\n                if (perpendicularDistanceSq < avoidanceRadiusSq) {\n                    const cross = directionX * toAsteroidY - directionY * toAsteroidX;\n                    const steerX = cross > 0 ? directionY : -directionY;\n                    const steerY = cross > 0 ? -directionX : directionX;\n                    const strength = (avoidanceRadius - Math.sqrt(perpendicularDistanceSq)) / avoidanceRadius;\n                    asteroidAvoidanceX += steerX * strength;\n                    asteroidAvoidanceY += steerY * strength;\n                }\n            }\n            const offsetX = this.position.x - asteroid.position.x;\n            const offsetY = this.position.y - asteroid.position.y;\n            const distanceSq = offsetX * offsetX + offsetY * offsetY;\n            if (distanceSq < avoidanceRadiusSq) {\n                const distance = Math.sqrt(distanceSq);\n                if (distance > 0) {\n                    const pushStrength = (avoidanceRadius - distance) / avoidanceRadius;\n                    asteroidAvoidanceX += (offsetX / distance) * pushStrength;\n                    asteroidAvoidanceY += (offsetY / distance) * pushStrength;\n                }\n            }\n        }\n        const asteroidAvoidanceLength = Math.sqrt(asteroidAvoidanceX * asteroidAvoidanceX + asteroidAvoidanceY * asteroidAvoidanceY);\n        if (asteroidAvoidanceLength > 0) {\n            asteroidAvoidanceX /= asteroidAvoidanceLength;\n            asteroidAvoidanceY /= asteroidAvoidanceLength;\n        }\n        directionX += avoidanceX * _constants__WEBPACK_IMPORTED_MODULE_0__.UNIT_AVOIDANCE_STRENGTH;\n        directionY += avoidanceY * _constants__WEBPACK_IMPORTED_MODULE_0__.UNIT_AVOIDANCE_STRENGTH;\n        directionX += asteroidAvoidanceX * _constants__WEBPACK_IMPORTED_MODULE_0__.UNIT_ASTEROID_AVOIDANCE_STRENGTH;\n        directionY += asteroidAvoidanceY * _constants__WEBPACK_IMPORTED_MODULE_0__.UNIT_ASTEROID_AVOIDANCE_STRENGTH;\n        const directionLength = Math.sqrt(directionX * directionX + directionY * directionY);\n        if (directionLength > 0) {\n            directionX /= directionLength;\n            directionY /= directionLength;\n        }\n        // Update rotation to face movement direction with smooth turning\n        if (directionLength > 0) {\n            // Add /2 so the TOP of the sprite is treated as the FRONT (not the bottom/right side)\n            const targetRotation = Math.atan2(directionY, directionX) + Math.PI / 2;\n            const rotationDelta = this.getShortestAngleDelta(this.rotation, targetRotation);\n            const maxRotationStep = _constants__WEBPACK_IMPORTED_MODULE_0__.UNIT_TURN_SPEED_RAD_PER_SEC * deltaTime;\n            if (Math.abs(rotationDelta) <= maxRotationStep) {\n                this.rotation = targetRotation;\n            }\n            else {\n                this.rotation += Math.sign(rotationDelta) * maxRotationStep;\n            }\n            // Normalize rotation to [0, 2) using modulo\n            this.rotation = ((this.rotation % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);\n        }\n        const moveDistance = moveSpeed * deltaTime;\n        const moveX = directionX * moveDistance;\n        const moveY = directionY * moveDistance;\n        this.position.x += moveX;\n        this.position.y += moveY;\n        this.velocity.x = directionX * moveSpeed;\n        this.velocity.y = directionY * moveSpeed;\n        // Clamp position to playable map boundaries (keep units out of dark border fade zone)\n        const boundary = _constants__WEBPACK_IMPORTED_MODULE_0__.MAP_PLAYABLE_BOUNDARY;\n        this.position.x = Math.max(-boundary, Math.min(boundary, this.position.x));\n        this.position.y = Math.max(-boundary, Math.min(boundary, this.position.y));\n    }\n    /**\n     * Get shortest angle delta between two angles (in radians)\n     */\n    getShortestAngleDelta(from, to) {\n        let delta = to - from;\n        while (delta > Math.PI)\n            delta -= Math.PI * 2;\n        while (delta < -Math.PI)\n            delta += Math.PI * 2;\n        return delta;\n    }\n    /**\n     * Check if target is dead\n     */\n    isTargetDead(target) {\n        if ('health' in target) {\n            return target.health <= 0;\n        }\n        return false;\n    }\n    /**\n     * Find nearest enemy\n     */\n    findNearestEnemy(enemies) {\n        let nearest = null;\n        let minDistance = Infinity;\n        for (const enemy of enemies) {\n            if ('health' in enemy && enemy.health <= 0)\n                continue;\n            const distance = this.position.distanceTo(enemy.position);\n            if (distance < minDistance) {\n                minDistance = distance;\n                nearest = enemy;\n            }\n        }\n        return nearest;\n    }\n    /**\n     * Attack target (to be overridden by subclasses)\n     */\n    attack(target) {\n        // Base implementation\n        if ('health' in target) {\n            target.health -= this.attackDamage;\n        }\n    }\n    /**\n     * Use special ability in a direction (to be overridden by subclasses)\n     * @param direction The normalized direction vector for the ability\n     * @returns true if ability was used, false if on cooldown\n     */\n    useAbility(direction) {\n        // Check if ability is ready\n        if (this.abilityCooldown > 0) {\n            return false;\n        }\n        // Set cooldown\n        this.abilityCooldown = this.abilityCooldownTime;\n        // Base implementation does nothing\n        return true;\n    }\n    /**\n     * Get effects from last ability use (for game state to manage)\n     */\n    getAndClearLastAbilityEffects() {\n        const effects = this.lastAbilityEffects;\n        this.lastAbilityEffects = [];\n        return effects;\n    }\n    /**\n     * Apply stun effect to unit\n     */\n    applyStun(duration) {\n        this.stunDuration = Math.max(this.stunDuration, duration);\n    }\n    /**\n     * Check if unit is stunned\n     */\n    isStunned() {\n        return this.stunDuration > 0;\n    }\n    /**\n     * Take damage\n     */\n    takeDamage(amount) {\n        this.health -= amount;\n    }\n    /**\n     * Check if unit is dead\n     */\n    isDead() {\n        return this.health <= 0;\n    }\n}\nconst { Marine } = (0,_heroes_marine__WEBPACK_IMPORTED_MODULE_7__.createMarineHero)({\n    Unit,\n    Vector2D,\n    Constants: _constants__WEBPACK_IMPORTED_MODULE_0__,\n    MuzzleFlash,\n    BulletCasing,\n    BouncingBullet,\n    AbilityBullet\n});\nconst { Grave, GraveProjectile } = (0,_heroes_grave__WEBPACK_IMPORTED_MODULE_5__.createGraveHero)({\n    Unit,\n    Vector2D,\n    Constants: _constants__WEBPACK_IMPORTED_MODULE_0__\n});\nconst { Ray, RayBeamSegment } = (0,_heroes_ray__WEBPACK_IMPORTED_MODULE_10__.createRayHero)({\n    Unit,\n    Vector2D,\n    Constants: _constants__WEBPACK_IMPORTED_MODULE_0__\n});\nconst { InfluenceBall, InfluenceZone, InfluenceBallProjectile } = (0,_heroes_influence_ball__WEBPACK_IMPORTED_MODULE_6__.createInfluenceBallHero)({\n    Unit,\n    Vector2D,\n    Constants: _constants__WEBPACK_IMPORTED_MODULE_0__\n});\nconst { TurretDeployer, DeployedTurret } = (0,_heroes_turret_deployer__WEBPACK_IMPORTED_MODULE_12__.createTurretDeployerHero)({\n    Unit,\n    Vector2D,\n    Constants: _constants__WEBPACK_IMPORTED_MODULE_0__\n});\nconst { Driller } = (0,_heroes_driller__WEBPACK_IMPORTED_MODULE_4__.createDrillerHero)({\n    Unit,\n    Vector2D,\n    Constants: _constants__WEBPACK_IMPORTED_MODULE_0__\n});\nconst { Dagger } = (0,_heroes_dagger__WEBPACK_IMPORTED_MODULE_3__.createDaggerHero)({\n    Unit,\n    Vector2D,\n    Constants: _constants__WEBPACK_IMPORTED_MODULE_0__,\n    AbilityBullet\n});\nconst { Beam } = (0,_heroes_beam__WEBPACK_IMPORTED_MODULE_2__.createBeamHero)({\n    Unit,\n    Vector2D,\n    Constants: _constants__WEBPACK_IMPORTED_MODULE_0__,\n    AbilityBullet\n});\nconst { Mortar, MortarProjectile } = (0,_heroes_mortar__WEBPACK_IMPORTED_MODULE_8__.createMortarHero)({\n    Unit,\n    Vector2D,\n    Constants: _constants__WEBPACK_IMPORTED_MODULE_0__\n});\nconst { Preist, HealingBombParticle } = (0,_heroes_preist__WEBPACK_IMPORTED_MODULE_9__.createPreistHero)({\n    Unit,\n    Vector2D,\n    Constants: _constants__WEBPACK_IMPORTED_MODULE_0__,\n    AbilityBullet\n});\nconst { Tank, CrescentWave } = (0,_heroes_tank__WEBPACK_IMPORTED_MODULE_11__.createTankHero)({\n    Unit,\n    Vector2D,\n    Constants: _constants__WEBPACK_IMPORTED_MODULE_0__\n});\n\n/**\n * Starling unit - minion that spawns from stellar forge and has AI behavior\n */\nclass Starling extends Unit {\n    constructor(position, owner, assignedPath = []) {\n        super(position, owner, _constants__WEBPACK_IMPORTED_MODULE_0__.STARLING_MAX_HEALTH, _constants__WEBPACK_IMPORTED_MODULE_0__.STARLING_ATTACK_RANGE, _constants__WEBPACK_IMPORTED_MODULE_0__.STARLING_ATTACK_DAMAGE, _constants__WEBPACK_IMPORTED_MODULE_0__.STARLING_ATTACK_SPEED, 0, // No special ability\n        _constants__WEBPACK_IMPORTED_MODULE_0__.STARLING_COLLISION_RADIUS_PX);\n        this.explorationTarget = null;\n        this.explorationTimer = 0;\n        this.currentPathWaypointIndex = 0; // Current waypoint index in the assigned path\n        this.assignedPath = [];\n        this.hasManualOrder = false;\n        this.lastShotLasers = [];\n        this.pathHash = ''; // Unique identifier for the assigned path\n        this.hasReachedFinalWaypoint = false; // True when starling reaches the last waypoint\n        this.assignedPath = assignedPath.map((waypoint) => new Vector2D(waypoint.x, waypoint.y));\n        this.pathHash = this.generatePathHash(this.assignedPath);\n    }\n    /**\n     * Generate a unique hash for the assigned path to identify starlings with the same movement instructions\n     */\n    generatePathHash(path) {\n        if (path.length === 0) {\n            return 'no-path';\n        }\n        // Create hash from path waypoints (rounded to avoid floating point issues)\n        return path.map(waypoint => `${Math.round(waypoint.x)},${Math.round(waypoint.y)}`).join('|');\n    }\n    setManualRallyPoint(target) {\n        this.rallyPoint = target;\n        this.hasManualOrder = true;\n        // Reset the final waypoint flag since we're now moving to a new destination\n        this.hasReachedFinalWaypoint = false;\n    }\n    setPath(path) {\n        this.assignedPath = path.map((waypoint) => new Vector2D(waypoint.x, waypoint.y));\n        this.pathHash = this.generatePathHash(this.assignedPath);\n        this.currentPathWaypointIndex = 0;\n        this.hasManualOrder = true;\n        this.hasReachedFinalWaypoint = false;\n        this.rallyPoint = null; // Clear rally point when following a path\n    }\n    getAssignedPathLength() {\n        return this.assignedPath.length;\n    }\n    getPathHash() {\n        return this.pathHash;\n    }\n    getHasReachedFinalWaypoint() {\n        return this.hasReachedFinalWaypoint;\n    }\n    getCurrentPathWaypointIndex() {\n        return this.currentPathWaypointIndex;\n    }\n    hasActiveManualOrder() {\n        return this.hasManualOrder;\n    }\n    getAndClearLastShotProjectiles() {\n        // Legacy method - no longer used for lasers\n        return [];\n    }\n    getAndClearLastShotLasers() {\n        const lasers = this.lastShotLasers;\n        this.lastShotLasers = [];\n        return lasers;\n    }\n    /**\n     * Update starling AI behavior (call this before regular update)\n     */\n    updateAI(gameState, enemies) {\n        var _a, _b;\n        if (this.hasManualOrder) {\n            return;\n        }\n        // Use the assigned minion path\n        if (this.assignedPath.length > 0) {\n            // Follow the base's path\n            const targetWaypoint = this.assignedPath[this.currentPathWaypointIndex];\n            const rallyTarget = (_a = this.getStandoffPointForWaypoint(gameState, targetWaypoint)) !== null && _a !== void 0 ? _a : targetWaypoint;\n            // Check if we've reached the current waypoint\n            if (this.position.distanceTo(rallyTarget) < _constants__WEBPACK_IMPORTED_MODULE_0__.UNIT_ARRIVAL_THRESHOLD * _constants__WEBPACK_IMPORTED_MODULE_0__.PATH_WAYPOINT_ARRIVAL_MULTIPLIER) {\n                // Move to next waypoint if there is one\n                if (this.currentPathWaypointIndex < this.assignedPath.length - 1) {\n                    this.currentPathWaypointIndex++;\n                    const nextWaypoint = this.assignedPath[this.currentPathWaypointIndex];\n                    this.rallyPoint = (_b = this.getStandoffPointForWaypoint(gameState, nextWaypoint)) !== null && _b !== void 0 ? _b : nextWaypoint;\n                }\n                else {\n                    // We've reached the end of the path, stay here (pile up)\n                    this.rallyPoint = rallyTarget;\n                    this.hasReachedFinalWaypoint = true;\n                    return;\n                }\n            }\n            else {\n                // Set rally point to current waypoint\n                this.rallyPoint = rallyTarget;\n            }\n        }\n        else {\n            // No path defined, fall back to original AI behavior\n            // No need to update exploration timer here, it's updated in the main update loop\n            // AI behavior: prioritize enemy base, then buildings, then explore\n            let targetPosition = null;\n            let targetRadiusPx = null;\n            // 1. Try to target enemy base if visible\n            for (const enemy of enemies) {\n                if (enemy instanceof StellarForge && enemy.owner !== this.owner) {\n                    // Check if enemy base is visible (not in shadow)\n                    if (gameState.isObjectVisibleToPlayer(enemy.position, this.owner)) {\n                        targetPosition = enemy.position;\n                        targetRadiusPx = enemy.radius;\n                        break;\n                    }\n                }\n            }\n            // 2. If no visible enemy base, target visible enemy buildings (mirrors)\n            if (!targetPosition) {\n                for (const player of gameState.players) {\n                    if (player !== this.owner) {\n                        for (const mirror of player.solarMirrors) {\n                            if (gameState.isObjectVisibleToPlayer(mirror.position, this.owner)) {\n                                targetPosition = mirror.position;\n                                break;\n                            }\n                        }\n                        if (targetPosition)\n                            break;\n                    }\n                }\n            }\n            // 3. If no visible structures, explore shadows randomly\n            if (!targetPosition) {\n                // Generate new random exploration target every few seconds or if we've reached current target\n                if (this.explorationTimer <= 0 || !this.explorationTarget ||\n                    this.position.distanceTo(this.explorationTarget) < _constants__WEBPACK_IMPORTED_MODULE_0__.UNIT_ARRIVAL_THRESHOLD) {\n                    // Pick a random position in shadow\n                    const angle = Math.random() * Math.PI * 2;\n                    const distance = 300 + Math.random() * 500;\n                    this.explorationTarget = new Vector2D(this.position.x + Math.cos(angle) * distance, this.position.y + Math.sin(angle) * distance);\n                    this.explorationTimer = _constants__WEBPACK_IMPORTED_MODULE_0__.STARLING_EXPLORATION_CHANGE_INTERVAL;\n                }\n                targetPosition = this.explorationTarget;\n            }\n            // Set rally point for movement\n            if (targetPosition) {\n                if (targetRadiusPx) {\n                    this.rallyPoint = this.getStructureStandoffPoint(targetPosition, targetRadiusPx);\n                }\n                else {\n                    this.rallyPoint = targetPosition;\n                }\n            }\n        }\n    }\n    getStandoffPointForWaypoint(gameState, waypoint) {\n        for (const player of gameState.players) {\n            if (player.stellarForge) {\n                const forgeDistance = waypoint.distanceTo(player.stellarForge.position);\n                if (forgeDistance < player.stellarForge.radius + this.collisionRadiusPx) {\n                    return this.getStructureStandoffPoint(player.stellarForge.position, player.stellarForge.radius);\n                }\n            }\n            for (const building of player.buildings) {\n                const buildingDistance = waypoint.distanceTo(building.position);\n                if (buildingDistance < building.radius + this.collisionRadiusPx) {\n                    return this.getStructureStandoffPoint(building.position, building.radius);\n                }\n            }\n        }\n        return null;\n    }\n    getStructureStandoffPoint(targetPosition, targetRadiusPx) {\n        const offsetX = this.position.x - targetPosition.x;\n        const offsetY = this.position.y - targetPosition.y;\n        const distance = Math.sqrt(offsetX * offsetX + offsetY * offsetY);\n        const minDistance = targetRadiusPx + this.collisionRadiusPx + _constants__WEBPACK_IMPORTED_MODULE_0__.UNIT_STRUCTURE_STANDOFF_PX;\n        if (distance <= 0) {\n            return new Vector2D(targetPosition.x + minDistance, targetPosition.y);\n        }\n        const scale = minDistance / distance;\n        return new Vector2D(targetPosition.x + offsetX * scale, targetPosition.y + offsetY * scale);\n    }\n    /**\n     * Override moveTowardRallyPoint to implement group stopping behavior\n     * Starlings at their final waypoint will stop when touching other stopped starlings from the same group\n     */\n    moveTowardRallyPoint(deltaTime, moveSpeed, allUnits, asteroids = []) {\n        // Check if we should stop due to touching a stopped starling from our group\n        // This only applies when we're heading to the final waypoint (not intermediate waypoints)\n        if (this.assignedPath.length > 0 &&\n            this.currentPathWaypointIndex === this.assignedPath.length - 1 &&\n            !this.hasReachedFinalWaypoint &&\n            this.rallyPoint !== null) {\n            // Check for collision with other stopped starlings from the same group\n            const stopDistance = _constants__WEBPACK_IMPORTED_MODULE_0__.UNIT_AVOIDANCE_RANGE_PX; // Use avoidance range as collision detection range\n            for (let i = 0; i < allUnits.length; i++) {\n                const otherUnit = allUnits[i];\n                // Skip if not a starling, is self, is dead, or is not from the same team\n                if (!(otherUnit instanceof Starling) || otherUnit === this || otherUnit.isDead() || otherUnit.owner !== this.owner) {\n                    continue;\n                }\n                // Check if other starling is from the same group (same path hash)\n                if (otherUnit.pathHash !== this.pathHash) {\n                    continue;\n                }\n                // Check if other starling has reached its final waypoint and stopped\n                if (!otherUnit.hasReachedFinalWaypoint) {\n                    continue;\n                }\n                // Check if we're close enough to the stopped starling\n                const offsetX = this.position.x - otherUnit.position.x;\n                const offsetY = this.position.y - otherUnit.position.y;\n                const distanceSq = offsetX * offsetX + offsetY * offsetY;\n                if (distanceSq < stopDistance * stopDistance) {\n                    // Stop this starling - we've touched a stopped starling from our group\n                    this.rallyPoint = null;\n                    this.velocity.x = 0;\n                    this.velocity.y = 0;\n                    this.hasReachedFinalWaypoint = true;\n                    return;\n                }\n            }\n        }\n        // Call parent implementation for normal movement\n        super.moveTowardRallyPoint(deltaTime, moveSpeed, allUnits, asteroids);\n    }\n    /**\n     * Override update to use custom movement speed\n     */\n    update(deltaTime, enemies, allUnits = [], asteroids = []) {\n        // Update attack cooldown\n        if (this.attackCooldown > 0) {\n            this.attackCooldown -= deltaTime;\n        }\n        // Update ability cooldown\n        if (this.abilityCooldown > 0) {\n            this.abilityCooldown -= deltaTime;\n        }\n        // Update exploration timer\n        this.explorationTimer -= deltaTime;\n        this.moveTowardRallyPoint(deltaTime, _constants__WEBPACK_IMPORTED_MODULE_0__.STARLING_MOVE_SPEED, allUnits, asteroids);\n        // Use base class methods for targeting and attacking\n        // Find target if don't have one or current target is dead\n        if (!this.target || this.isTargetDead(this.target)) {\n            this.target = this.findNearestEnemy(enemies);\n        }\n        // Attack if target in range and cooldown ready\n        if (this.target && this.attackCooldown <= 0) {\n            const distance = this.position.distanceTo(this.target.position);\n            if (distance <= this.attackRange) {\n                this.attack(this.target);\n                this.attackCooldown = 1.0 / this.attackSpeed;\n            }\n        }\n    }\n    attack(target) {\n        const dx = target.position.x - this.position.x;\n        const dy = target.position.y - this.position.y;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        if (distance <= 0) {\n            return;\n        }\n        // Create laser beam for visual effect\n        const laserBeam = new LaserBeam(new Vector2D(this.position.x, this.position.y), new Vector2D(target.position.x, target.position.y), this.owner, this.attackDamage);\n        this.lastShotLasers.push(laserBeam);\n        // Deal instant damage to target\n        if ('takeDamage' in target) {\n            target.takeDamage(this.attackDamage);\n        }\n    }\n}\n/**\n * Warp gate being conjured by player\n */\nclass WarpGate {\n    constructor(position, owner) {\n        this.position = position;\n        this.owner = owner;\n        this.chargeTime = 0;\n        this.isCharging = false;\n        this.isComplete = false;\n        this.health = 100;\n        this.hasEmittedShockwave = false; // Track if shockwave was emitted\n    }\n    /**\n     * Update warp gate charging\n     */\n    update(deltaTime, isStillHolding, chargeMultiplier = 1.0) {\n        if (!this.isCharging || this.isComplete) {\n            return;\n        }\n        if (!isStillHolding) {\n            // Player let go, cancel the warp gate\n            this.cancel();\n            return;\n        }\n        this.chargeTime += deltaTime * chargeMultiplier;\n        // Check if fully charged\n        if (this.chargeTime >= _constants__WEBPACK_IMPORTED_MODULE_0__.WARP_GATE_CHARGE_TIME) {\n            this.isComplete = true;\n            this.isCharging = false;\n        }\n    }\n    /**\n     * Start charging the warp gate\n     */\n    startCharging() {\n        this.isCharging = true;\n        this.chargeTime = 0;\n    }\n    /**\n     * Take damage and potentially dissipate\n     */\n    takeDamage(amount) {\n        this.health -= amount;\n        if (this.health <= 0) {\n            this.cancel();\n            return true; // Gate destroyed\n        }\n        return false;\n    }\n    /**\n     * Cancel/dissipate the warp gate\n     */\n    cancel() {\n        this.isCharging = false;\n        this.isComplete = false;\n        // Scatter particles will be handled in game state\n    }\n    /**\n     * Check if shockwave should be emitted (at 1 second mark)\n     */\n    shouldEmitShockwave() {\n        if (this.hasEmittedShockwave) {\n            return false;\n        }\n        if (this.chargeTime >= 1.0) {\n            this.hasEmittedShockwave = true;\n            return true;\n        }\n        return false;\n    }\n}\n/**\n * Damage number that floats upward and fades out\n */\nclass DamageNumber {\n    constructor(position, damage, creationTime, maxHealth = 100, remainingHealth = 0, unitId = null) {\n        this.position = new Vector2D(position.x, position.y);\n        this.damage = Math.round(damage);\n        this.remainingHealth = Math.round(remainingHealth);\n        this.creationTime = creationTime;\n        this.maxHealth = maxHealth;\n        this.unitId = unitId;\n        // Random horizontal drift\n        this.velocity = new Vector2D((Math.random() - 0.5) * 20, -50 // Upward velocity\n        );\n    }\n    /**\n     * Update position based on velocity\n     */\n    update(deltaTime) {\n        this.position.x += this.velocity.x * deltaTime;\n        this.position.y += this.velocity.y * deltaTime;\n    }\n    /**\n     * Check if damage number has expired (2 second lifetime)\n     */\n    isExpired(currentTime) {\n        return currentTime - this.creationTime > 2.0;\n    }\n    /**\n     * Get opacity based on age (fade out over time)\n     */\n    getOpacity(currentTime) {\n        const age = currentTime - this.creationTime;\n        const lifetime = 2.0;\n        return Math.max(0, 1 - age / lifetime);\n    }\n}\n/**\n * Main game state\n */\nclass GameState {\n    constructor() {\n        this.players = [];\n        this.suns = [];\n        this.spaceDust = [];\n        this.warpGates = [];\n        this.asteroids = [];\n        this.muzzleFlashes = [];\n        this.bulletCasings = [];\n        this.bouncingBullets = [];\n        this.abilityBullets = [];\n        this.minionProjectiles = [];\n        this.mortarProjectiles = [];\n        this.laserBeams = [];\n        this.impactParticles = [];\n        this.influenceZones = [];\n        this.influenceBallProjectiles = [];\n        this.deployedTurrets = [];\n        this.damageNumbers = [];\n        this.crescentWaves = [];\n        this.gameTime = 0.0;\n        this.stateHash = 0;\n        this.stateHashTickCounter = 0;\n        this.isRunning = false;\n        this.countdownTime = _constants__WEBPACK_IMPORTED_MODULE_0__.COUNTDOWN_DURATION; // Countdown from 3 seconds\n        this.isCountdownActive = true; // Start with countdown active\n        this.mirrorsMovedToSun = false; // Track if mirrors have been moved\n        this.mapSize = 2000; // Map size in world units\n        this.damageDisplayMode = 'damage'; // How to display damage numbers\n        // Network support\n        this.networkManager = null; // Network manager for LAN/online play\n        this.localPlayerIndex = 0; // Index of the local player (0 or 1)\n        this.pendingCommands = []; // Commands from network to be processed\n        // Collision resolution constants\n        this.MAX_PUSH_DISTANCE = 10; // Maximum push distance for collision resolution\n        this.PUSH_MULTIPLIER = 15; // Multiplier for push strength calculation\n        this.dustSpatialHash = new Map();\n        this.dustSpatialHashKeys = [];\n    }\n    /**\n     * Update game state\n     */\n    update(deltaTime) {\n        var _a, _b;\n        this.gameTime += deltaTime;\n        // Process pending network commands from remote players\n        if (this.networkManager) {\n            this.processPendingNetworkCommands();\n        }\n        // Handle countdown\n        if (this.isCountdownActive) {\n            this.countdownTime -= deltaTime;\n            // Initialize mirror movement at the start of countdown\n            if (!this.mirrorsMovedToSun) {\n                this.initializeMirrorMovement();\n                this.mirrorsMovedToSun = true;\n            }\n            // End countdown when timer reaches 0\n            if (this.countdownTime <= 0) {\n                this.isCountdownActive = false;\n                this.countdownTime = 0;\n            }\n        }\n        // Update asteroids\n        for (const asteroid of this.asteroids) {\n            asteroid.update(deltaTime);\n        }\n        if (!this.isCountdownActive) {\n            this.updateAi(deltaTime);\n        }\n        // Update each player\n        for (const player of this.players) {\n            if (player.isDefeated()) {\n                continue;\n            }\n            if (player.solarMirrors.length > 0) {\n                player.solarMirrors = player.solarMirrors.filter(mirror => mirror.health > 0);\n            }\n            // Update light status for Stellar Forge\n            if (player.stellarForge) {\n                const oldForgePos = new Vector2D(player.stellarForge.position.x, player.stellarForge.position.y);\n                player.stellarForge.updateLightStatus(player.solarMirrors, this.suns, this.asteroids, this.players);\n                // Only allow forge movement after countdown\n                if (!this.isCountdownActive) {\n                    player.stellarForge.update(deltaTime, this); // Update forge movement with gameState\n                    // Check collision for forge (larger radius)\n                    if (this.checkCollision(player.stellarForge.position, player.stellarForge.radius, player.stellarForge)) {\n                        // Revert to old position and stop movement\n                        player.stellarForge.position = oldForgePos;\n                        player.stellarForge.targetPosition = null;\n                        player.stellarForge.velocity = new Vector2D(0, 0);\n                    }\n                    this.applyDustPushFromMovingEntity(player.stellarForge.position, player.stellarForge.velocity, _constants__WEBPACK_IMPORTED_MODULE_0__.FORGE_DUST_PUSH_RADIUS_PX, _constants__WEBPACK_IMPORTED_MODULE_0__.FORGE_DUST_PUSH_FORCE_MULTIPLIER, deltaTime);\n                }\n                // Check for forge crunch (spawns minions with excess energy)\n                if (!this.isCountdownActive) {\n                    const energyForMinions = player.stellarForge.shouldCrunch();\n                    if (energyForMinions > 0) {\n                        // Calculate number of starlings to spawn based on energy\n                        const numStarlings = Math.floor(energyForMinions / _constants__WEBPACK_IMPORTED_MODULE_0__.STARLING_COST_PER_ENERGY);\n                        // Spawn starlings at the wave edge during wave phase\n                        for (let i = 0; i < numStarlings; i++) {\n                            const angle = (Math.PI * 2 * i) / numStarlings; // Evenly distribute around forge\n                            const spawnRadius = _constants__WEBPACK_IMPORTED_MODULE_0__.FORGE_CRUNCH_WAVE_RADIUS * 0.7; // Spawn at 70% of wave radius\n                            const spawnPosition = new Vector2D(player.stellarForge.position.x + Math.cos(angle) * spawnRadius, player.stellarForge.position.y + Math.sin(angle) * spawnRadius);\n                            const starling = new Starling(spawnPosition, player, (_b = (_a = player.stellarForge) === null || _a === void 0 ? void 0 : _a.minionPath) !== null && _b !== void 0 ? _b : []);\n                            player.units.push(starling);\n                            player.unitsCreated++;\n                        }\n                        if (numStarlings > 0) {\n                            console.log(`${player.name} forge crunch spawned ${numStarlings} Starlings with ${energyForMinions.toFixed(0)} energy`);\n                        }\n                    }\n                }\n                if (!this.isCountdownActive) {\n                    const completedHeroType = player.stellarForge.advanceHeroProduction(deltaTime);\n                    if (completedHeroType) {\n                        const spawnAngleRad = (player.unitsCreated % 8) * (Math.PI / 4);\n                        const spawnRadius = player.stellarForge.radius + _constants__WEBPACK_IMPORTED_MODULE_0__.UNIT_RADIUS_PX + 5;\n                        const spawnPosition = new Vector2D(player.stellarForge.position.x + Math.cos(spawnAngleRad) * spawnRadius, player.stellarForge.position.y + Math.sin(spawnAngleRad) * spawnRadius);\n                        const heroUnit = this.createHeroUnit(completedHeroType, spawnPosition, player);\n                        if (heroUnit) {\n                            player.units.push(heroUnit);\n                            player.unitsCreated++;\n                            console.log(`${player.name} forged hero ${completedHeroType}`);\n                        }\n                    }\n                }\n            }\n            // Update solar mirrors - position and reflection angle\n            // Mirrors can move during countdown to reach the sun\n            for (const mirror of player.solarMirrors) {\n                const oldMirrorPos = new Vector2D(mirror.position.x, mirror.position.y);\n                mirror.update(deltaTime, this); // Update mirror movement with gameState\n                // Check collision for mirror\n                if (this.checkCollision(mirror.position, 20, mirror)) {\n                    // Revert to old position and stop movement\n                    mirror.position = oldMirrorPos;\n                    mirror.targetPosition = null;\n                    mirror.velocity = new Vector2D(0, 0);\n                }\n                this.applyDustPushFromMovingEntity(mirror.position, mirror.velocity, _constants__WEBPACK_IMPORTED_MODULE_0__.MIRROR_DUST_PUSH_RADIUS_PX, _constants__WEBPACK_IMPORTED_MODULE_0__.MIRROR_DUST_PUSH_FORCE_MULTIPLIER, deltaTime);\n                mirror.updateReflectionAngle(player.stellarForge, this.suns, this.asteroids, deltaTime);\n                // Generate energy even during countdown once mirrors reach position\n                if (mirror.hasLineOfSightToLight(this.suns, this.asteroids) &&\n                    player.stellarForge &&\n                    mirror.hasLineOfSightToForge(player.stellarForge, this.asteroids, this.players)) {\n                    const energyGenerated = mirror.generateEnergy(deltaTime);\n                    // Add to player's energy for building/heroes AND to forge's pending energy pool for starling spawns\n                    player.addEnergy(energyGenerated);\n                    player.stellarForge.addPendingEnergy(energyGenerated);\n                }\n                if (player.stellarForge && mirror.health < _constants__WEBPACK_IMPORTED_MODULE_0__.MIRROR_MAX_HEALTH) {\n                    const distanceToForge = player.stellarForge.position.distanceTo(mirror.position);\n                    if (distanceToForge <= _constants__WEBPACK_IMPORTED_MODULE_0__.INFLUENCE_RADIUS) {\n                        mirror.health = Math.min(_constants__WEBPACK_IMPORTED_MODULE_0__.MIRROR_MAX_HEALTH, mirror.health + _constants__WEBPACK_IMPORTED_MODULE_0__.MIRROR_REGEN_PER_SEC * deltaTime);\n                    }\n                }\n            }\n        }\n        // Update space dust particles\n        this.updateSpaceDust(deltaTime);\n        // Update units and collect enemies for targeting\n        const allUnits = [];\n        const allStructures = [];\n        for (const player of this.players) {\n            if (!player.isDefeated()) {\n                allUnits.push(...player.units);\n                if (player.stellarForge) {\n                    allStructures.push(player.stellarForge);\n                }\n            }\n        }\n        // Update each player's units\n        for (const player of this.players) {\n            if (player.isDefeated())\n                continue;\n            // Get enemies (units and structures not owned by this player)\n            const enemies = [];\n            for (const otherPlayer of this.players) {\n                if (otherPlayer !== player && !otherPlayer.isDefeated()) {\n                    enemies.push(...otherPlayer.units);\n                    enemies.push(...otherPlayer.buildings);\n                    for (const mirror of otherPlayer.solarMirrors) {\n                        if (mirror.health > 0) {\n                            enemies.push(mirror);\n                        }\n                    }\n                    if (otherPlayer.stellarForge) {\n                        enemies.push(otherPlayer.stellarForge);\n                    }\n                }\n            }\n            // Update each unit (only after countdown)\n            if (!this.isCountdownActive) {\n                for (const unit of player.units) {\n                    // Starlings need special AI update before regular update\n                    if (unit instanceof Starling) {\n                        unit.updateAI(this, enemies);\n                    }\n                    unit.update(deltaTime, enemies, allUnits, this.asteroids);\n                    if (unit instanceof Starling) {\n                        this.applyDustPushFromMovingEntity(unit.position, unit.velocity, _constants__WEBPACK_IMPORTED_MODULE_0__.STARLING_DUST_PUSH_RADIUS_PX, _constants__WEBPACK_IMPORTED_MODULE_0__.STARLING_DUST_PUSH_FORCE_MULTIPLIER, deltaTime);\n                    }\n                    // Apply fluid forces from Grave projectiles\n                    if (unit instanceof Grave) {\n                        for (const projectile of unit.getProjectiles()) {\n                            if (projectile.isAttacking) {\n                                // Attacking projectiles push dust as they fly\n                                const projectileSpeed = Math.sqrt(Math.pow(projectile.velocity.x, 2) + Math.pow(projectile.velocity.y, 2));\n                                this.applyFluidForceFromMovingObject(projectile.position, projectile.velocity, _constants__WEBPACK_IMPORTED_MODULE_0__.GRAVE_PROJECTILE_EFFECT_RADIUS, projectileSpeed * _constants__WEBPACK_IMPORTED_MODULE_0__.GRAVE_PROJECTILE_FORCE_MULTIPLIER, deltaTime);\n                            }\n                        }\n                    }\n                    // If unit is a Marine, collect its effects\n                    if (unit instanceof Marine) {\n                        const effects = unit.getAndClearLastShotEffects();\n                        if (effects.muzzleFlash) {\n                            this.muzzleFlashes.push(effects.muzzleFlash);\n                        }\n                        if (effects.casing) {\n                            this.bulletCasings.push(effects.casing);\n                        }\n                        if (effects.bouncingBullet) {\n                            this.bouncingBullets.push(effects.bouncingBullet);\n                        }\n                    }\n                    // Collect ability effects from all units\n                    const abilityEffects = unit.getAndClearLastAbilityEffects();\n                    this.abilityBullets.push(...abilityEffects);\n                    if (unit instanceof Starling) {\n                        const lasers = unit.getAndClearLastShotLasers();\n                        if (lasers.length > 0) {\n                            this.laserBeams.push(...lasers);\n                            // Spawn impact particles at laser endpoints\n                            for (const laser of lasers) {\n                                for (let i = 0; i < _constants__WEBPACK_IMPORTED_MODULE_0__.STARLING_LASER_IMPACT_PARTICLES; i++) {\n                                    const angle = (Math.PI * 2 * i) / _constants__WEBPACK_IMPORTED_MODULE_0__.STARLING_LASER_IMPACT_PARTICLES;\n                                    const velocity = new Vector2D(Math.cos(angle) * _constants__WEBPACK_IMPORTED_MODULE_0__.STARLING_LASER_PARTICLE_SPEED, Math.sin(angle) * _constants__WEBPACK_IMPORTED_MODULE_0__.STARLING_LASER_PARTICLE_SPEED);\n                                    this.impactParticles.push(new ImpactParticle(new Vector2D(laser.endPos.x, laser.endPos.y), velocity, _constants__WEBPACK_IMPORTED_MODULE_0__.STARLING_LASER_PARTICLE_LIFETIME, laser.owner.faction));\n                                }\n                            }\n                        }\n                    }\n                    // Handle InfluenceBall projectiles specifically\n                    if (unit instanceof InfluenceBall) {\n                        const projectile = unit.getAndClearProjectile();\n                        if (projectile) {\n                            this.influenceBallProjectiles.push(projectile);\n                        }\n                    }\n                    // Handle Mortar projectiles\n                    if (unit instanceof Mortar) {\n                        const projectiles = unit.getAndClearLastShotProjectiles();\n                        if (projectiles.length > 0) {\n                            this.mortarProjectiles.push(...projectiles);\n                        }\n                    }\n                    // Handle Tank crescent wave\n                    if (unit instanceof Tank) {\n                        const wave = unit.getCrescentWave();\n                        if (wave && !this.crescentWaves.includes(wave)) {\n                            this.crescentWaves.push(wave);\n                        }\n                    }\n                    // Handle Ray beam updates\n                    if (unit instanceof Ray) {\n                        unit.updateBeamSegments(deltaTime);\n                        // Apply fluid forces from active beam segments\n                        for (const segment of unit.getBeamSegments()) {\n                            this.applyFluidForceFromBeam(segment.startPos, segment.endPos, _constants__WEBPACK_IMPORTED_MODULE_0__.BEAM_EFFECT_RADIUS, _constants__WEBPACK_IMPORTED_MODULE_0__.BEAM_FORCE_STRENGTH, deltaTime);\n                        }\n                        // Process Ray ability if just used (check if cooldown is near max)\n                        if (unit.abilityCooldown > unit.abilityCooldownTime - 0.1 && unit.drillDirection) {\n                            this.processRayBeamAbility(unit);\n                            unit.drillDirection = null; // Clear after processing\n                        }\n                    }\n                    // Handle TurretDeployer ability\n                    if (unit instanceof TurretDeployer) {\n                        // Check if ability was just used (check if cooldown is near max)\n                        if (unit.abilityCooldown > unit.abilityCooldownTime - 0.1) {\n                            this.processTurretDeployment(unit);\n                        }\n                    }\n                    // Handle Driller movement and collision\n                    if (unit instanceof Driller && unit.isDrilling) {\n                        unit.updateDrilling(deltaTime);\n                        this.processDrillerCollisions(unit, deltaTime);\n                    }\n                    // Handle Dagger timers\n                    if (unit instanceof Dagger) {\n                        unit.updateTimers(deltaTime);\n                    }\n                    // Handle Grave projectile absorption\n                    if (unit instanceof Grave) {\n                        for (const projectile of unit.getProjectiles()) {\n                            if (projectile.isAttacking) {\n                                // Check for absorption by Space Dust Swirler buildings\n                                let wasAbsorbed = false;\n                                for (const player of this.players) {\n                                    for (const building of player.buildings) {\n                                        if (building instanceof SpaceDustSwirler) {\n                                            // Don't absorb friendly projectiles\n                                            if (building.owner === projectile.owner)\n                                                continue;\n                                            if (building.absorbProjectile(projectile)) {\n                                                // Make projectile return to grave (stop attacking)\n                                                projectile.isAttacking = false;\n                                                projectile.trail = [];\n                                                projectile.targetEnemy = null;\n                                                wasAbsorbed = true;\n                                                break;\n                                            }\n                                        }\n                                    }\n                                    if (wasAbsorbed)\n                                        break;\n                                }\n                            }\n                        }\n                    }\n                }\n            } // End of countdown check\n            // Remove dead units and track losses\n            const deadUnits = player.units.filter(unit => unit.isDead());\n            player.unitsLost += deadUnits.length;\n            player.units = player.units.filter(unit => !unit.isDead());\n            // Update each building (only after countdown)\n            if (!this.isCountdownActive) {\n                for (const building of player.buildings) {\n                    building.update(deltaTime, enemies, allUnits);\n                    // If building is a Cannon, collect its effects\n                    if (building instanceof Minigun) {\n                        const effects = building.getAndClearLastShotEffects();\n                        if (effects.muzzleFlash) {\n                            this.muzzleFlashes.push(effects.muzzleFlash);\n                        }\n                        if (effects.casing) {\n                            this.bulletCasings.push(effects.casing);\n                        }\n                        if (effects.bouncingBullet) {\n                            this.bouncingBullets.push(effects.bouncingBullet);\n                        }\n                    }\n                    // If building is a Foundry, check for completed production\n                    if (building instanceof SubsidiaryFactory) {\n                        const completed = building.getCompletedProduction();\n                        if (completed === 'solar-mirror') {\n                            // Spawn solar mirror near the factory\n                            const spawnAngle = Math.random() * Math.PI * 2;\n                            const spawnDistance = 80; // Spawn 80 pixels away from factory\n                            const spawnPos = new Vector2D(building.position.x + Math.cos(spawnAngle) * spawnDistance, building.position.y + Math.sin(spawnAngle) * spawnDistance);\n                            const mirror = new SolarMirror(spawnPos, player);\n                            player.solarMirrors.push(mirror);\n                        }\n                    }\n                }\n            } // End of countdown check for buildings\n            // Update building construction (only after countdown)\n            if (!this.isCountdownActive) {\n                for (const building of player.buildings) {\n                    if (building.isComplete)\n                        continue; // Skip completed buildings\n                    // Check if building is inside player's influence (near stellar forge)\n                    const isInInfluence = player.stellarForge &&\n                        building.position.distanceTo(player.stellarForge.position) <= _constants__WEBPACK_IMPORTED_MODULE_0__.INFLUENCE_RADIUS;\n                    if (isInInfluence && player.stellarForge) {\n                        // Building inside influence: take energy from forge\n                        // Calculate build progress per second (inverse of build time)\n                        const buildRate = 1.0 / _constants__WEBPACK_IMPORTED_MODULE_0__.BUILDING_BUILD_TIME;\n                        const buildProgress = buildRate * deltaTime;\n                        // TODO: Split energy between buildings and hero units\n                        // For now, buildings get energy if available\n                        building.addBuildProgress(buildProgress);\n                    }\n                    else {\n                        // Building outside influence: powered by mirrors shining on it\n                        // Calculate total light from all mirrors pointing at this building\n                        let totalLight = 0;\n                        for (const mirror of player.solarMirrors) {\n                            // Check if mirror has line of sight to light source\n                            if (!mirror.hasLineOfSightToLight(this.suns, this.asteroids))\n                                continue;\n                            // Check if mirror has line of sight to building\n                            const ray = new LightRay(mirror.position, new Vector2D(building.position.x - mirror.position.x, building.position.y - mirror.position.y).normalize(), 1.0);\n                            let hasLineOfSight = true;\n                            for (const asteroid of this.asteroids) {\n                                if (ray.intersectsPolygon(asteroid.getWorldVertices())) {\n                                    hasLineOfSight = false;\n                                    break;\n                                }\n                            }\n                            if (hasLineOfSight) {\n                                // Mirror can shine on building - calculate efficiency based on distance from light\n                                const closestSun = this.suns.reduce((closest, sun) => {\n                                    const distToSun = mirror.position.distanceTo(sun.position);\n                                    const distToClosest = closest ? mirror.position.distanceTo(closest.position) : Infinity;\n                                    return distToSun < distToClosest ? sun : closest;\n                                }, null);\n                                if (closestSun) {\n                                    const distanceToSun = mirror.position.distanceTo(closestSun.position);\n                                    const distanceMultiplier = Math.max(1.0, _constants__WEBPACK_IMPORTED_MODULE_0__.MIRROR_PROXIMITY_MULTIPLIER * (1.0 - Math.min(1.0, distanceToSun / _constants__WEBPACK_IMPORTED_MODULE_0__.MIRROR_MAX_GLOW_DISTANCE)));\n                                    totalLight += distanceMultiplier;\n                                }\n                            }\n                        }\n                        // Convert light to build progress\n                        if (totalLight > 0) {\n                            const buildRate = (totalLight / 10.0) * (1.0 / _constants__WEBPACK_IMPORTED_MODULE_0__.BUILDING_BUILD_TIME);\n                            const buildProgress = buildRate * deltaTime;\n                            building.addBuildProgress(buildProgress);\n                        }\n                    }\n                }\n            } // End of countdown check for building construction\n            // Remove destroyed buildings\n            player.buildings = player.buildings.filter(building => !building.isDestroyed());\n        }\n        if (!this.isCountdownActive) {\n            this.resolveUnitCollisions(allUnits);\n            this.resolveUnitObstacleCollisions(allUnits);\n        }\n        this.stateHashTickCounter += 1;\n        if (this.stateHashTickCounter % _constants__WEBPACK_IMPORTED_MODULE_0__.STATE_HASH_TICK_INTERVAL === 0) {\n            this.updateStateHash();\n        }\n        // Update muzzle flashes\n        for (const flash of this.muzzleFlashes) {\n            flash.update(deltaTime);\n        }\n        this.muzzleFlashes = this.muzzleFlashes.filter(flash => !flash.shouldDespawn());\n        // Update bullet casings and interact with space dust\n        for (const casing of this.bulletCasings) {\n            casing.update(deltaTime);\n            // Check collision with space dust particles\n            for (const particle of this.spaceDust) {\n                const distance = casing.position.distanceTo(particle.position);\n                if (distance < _constants__WEBPACK_IMPORTED_MODULE_0__.CASING_SPACEDUST_COLLISION_DISTANCE) {\n                    // Apply force to both casing and particle\n                    const direction = new Vector2D(particle.position.x - casing.position.x, particle.position.y - casing.position.y).normalize();\n                    particle.applyForce(new Vector2D(direction.x * _constants__WEBPACK_IMPORTED_MODULE_0__.CASING_SPACEDUST_FORCE, direction.y * _constants__WEBPACK_IMPORTED_MODULE_0__.CASING_SPACEDUST_FORCE));\n                    // Apply counter-force to casing (damping applied in applyCollision method)\n                    casing.applyCollision(new Vector2D(-direction.x * _constants__WEBPACK_IMPORTED_MODULE_0__.CASING_SPACEDUST_FORCE, -direction.y * _constants__WEBPACK_IMPORTED_MODULE_0__.CASING_SPACEDUST_FORCE));\n                }\n            }\n        }\n        this.bulletCasings = this.bulletCasings.filter(casing => !casing.shouldDespawn());\n        // Update bouncing bullets\n        for (const bullet of this.bouncingBullets) {\n            bullet.update(deltaTime);\n        }\n        this.bouncingBullets = this.bouncingBullets.filter(bullet => !bullet.shouldDespawn());\n        // Update ability bullets and check for hits\n        for (const bullet of this.abilityBullets) {\n            bullet.update(deltaTime);\n            // Check if projectile is blocked by Tank shields\n            let isBlocked = false;\n            for (const player of this.players) {\n                for (const unit of player.units) {\n                    if (unit instanceof Tank && unit.isPositionInShield(bullet.position)) {\n                        // Shield blocks projectiles but not friendly fire\n                        if (bullet.owner !== player) {\n                            isBlocked = true;\n                            bullet.lifetime = bullet.maxLifetime; // Mark for removal\n                            break;\n                        }\n                    }\n                }\n                if (isBlocked)\n                    break;\n            }\n            if (isBlocked)\n                continue;\n            // Check if healing bomb reached max range or lifetime - if so, explode\n            if (bullet.isHealingBomb && bullet.healingBombOwner && bullet.shouldDespawn()) {\n                bullet.healingBombOwner.explodeHealingBomb(bullet.position);\n            }\n            // Apply fluid-like force to space dust particles\n            const bulletSpeed = Math.sqrt(Math.pow(bullet.velocity.x, 2) + Math.pow(bullet.velocity.y, 2));\n            this.applyFluidForceFromMovingObject(bullet.position, bullet.velocity, _constants__WEBPACK_IMPORTED_MODULE_0__.ABILITY_BULLET_EFFECT_RADIUS, bulletSpeed * _constants__WEBPACK_IMPORTED_MODULE_0__.ABILITY_BULLET_FORCE_MULTIPLIER, deltaTime);\n            // Check hits against enemies\n            for (const player of this.players) {\n                // Skip if same team as bullet\n                if (player === bullet.owner) {\n                    continue;\n                }\n                // Skip hit detection for healing bombs (they explode on max range/lifetime)\n                if (bullet.isHealingBomb) {\n                    continue;\n                }\n                // Check hits on units\n                for (const unit of player.units) {\n                    if (bullet.checkHit(unit)) {\n                        let finalDamage = bullet.damage;\n                        // Check if this is a Beam projectile for distance-based damage\n                        if (bullet.isBeamProjectile && bullet.beamOwner) {\n                            const beamOwner = bullet.beamOwner;\n                            const distance = beamOwner.position.distanceTo(unit.position);\n                            const multiplier = 1 + (distance * _constants__WEBPACK_IMPORTED_MODULE_0__.BEAM_ABILITY_DAMAGE_PER_DISTANCE);\n                            finalDamage = Math.round(_constants__WEBPACK_IMPORTED_MODULE_0__.BEAM_ABILITY_BASE_DAMAGE * multiplier);\n                            // Store info for display above Beam unit\n                            beamOwner.lastBeamDamage = finalDamage;\n                            beamOwner.lastBeamDistance = distance;\n                            beamOwner.lastBeamMultiplier = multiplier;\n                            beamOwner.lastBeamTime = this.gameTime;\n                        }\n                        unit.takeDamage(finalDamage);\n                        // Create damage number\n                        const unitKey = `unit_${unit.position.x}_${unit.position.y}_${unit.owner.name}`;\n                        this.addDamageNumber(unit.position, finalDamage, unit.maxHealth, unit.health, unitKey);\n                        bullet.lifetime = bullet.maxLifetime; // Mark for removal\n                        break;\n                    }\n                }\n                if (bullet.shouldDespawn()) {\n                    continue;\n                }\n                for (const mirror of player.solarMirrors) {\n                    if (mirror.health <= 0) {\n                        continue;\n                    }\n                    if (bullet.checkHit(mirror)) {\n                        mirror.health -= bullet.damage;\n                        const mirrorKey = `mirror_${mirror.position.x}_${mirror.position.y}_${player.name}`;\n                        this.addDamageNumber(mirror.position, bullet.damage, _constants__WEBPACK_IMPORTED_MODULE_0__.MIRROR_MAX_HEALTH, mirror.health, mirrorKey);\n                        bullet.lifetime = bullet.maxLifetime; // Mark for removal\n                        break;\n                    }\n                }\n                if (bullet.shouldDespawn()) {\n                    continue;\n                }\n                // Check hits on Stellar Forge\n                if (player.stellarForge && bullet.checkHit(player.stellarForge)) {\n                    let finalDamage = bullet.damage;\n                    // Check if this is a Beam projectile for distance-based damage\n                    if (bullet.isBeamProjectile && bullet.beamOwner) {\n                        const beamOwner = bullet.beamOwner;\n                        const distance = beamOwner.position.distanceTo(player.stellarForge.position);\n                        const multiplier = 1 + (distance * _constants__WEBPACK_IMPORTED_MODULE_0__.BEAM_ABILITY_DAMAGE_PER_DISTANCE);\n                        finalDamage = Math.round(_constants__WEBPACK_IMPORTED_MODULE_0__.BEAM_ABILITY_BASE_DAMAGE * multiplier);\n                        // Store info for display above Beam unit\n                        beamOwner.lastBeamDamage = finalDamage;\n                        beamOwner.lastBeamDistance = distance;\n                        beamOwner.lastBeamMultiplier = multiplier;\n                        beamOwner.lastBeamTime = this.gameTime;\n                    }\n                    player.stellarForge.health -= finalDamage;\n                    // Create damage number\n                    const forgeKey = `forge_${player.stellarForge.position.x}_${player.stellarForge.position.y}_${player.name}`;\n                    this.addDamageNumber(player.stellarForge.position, finalDamage, _constants__WEBPACK_IMPORTED_MODULE_0__.STELLAR_FORGE_MAX_HEALTH, player.stellarForge.health, forgeKey);\n                    bullet.lifetime = bullet.maxLifetime; // Mark for removal\n                }\n            }\n        }\n        this.abilityBullets = this.abilityBullets.filter(bullet => !bullet.shouldDespawn());\n        // Update mortar projectiles and check for splash damage hits\n        for (const projectile of this.mortarProjectiles) {\n            projectile.update(deltaTime);\n            // Check hits against enemies\n            let shouldExplode = false;\n            for (const player of this.players) {\n                // Skip if same team as projectile\n                if (player === projectile.owner) {\n                    continue;\n                }\n                // Check if projectile hit any unit\n                for (const unit of player.units) {\n                    if (projectile.checkHit(unit)) {\n                        shouldExplode = true;\n                        break;\n                    }\n                }\n                if (shouldExplode) {\n                    break;\n                }\n            }\n            // If projectile hit something or reached max lifetime, apply splash damage\n            if (shouldExplode || projectile.shouldDespawn()) {\n                // Collect all enemy targets for splash damage\n                const allEnemyTargets = [];\n                for (const player of this.players) {\n                    if (player === projectile.owner) {\n                        continue;\n                    }\n                    // Add units as potential targets\n                    allEnemyTargets.push(...player.units);\n                    // Add forge as potential target\n                    if (player.stellarForge && player.stellarForge.health > 0) {\n                        allEnemyTargets.push(player.stellarForge);\n                    }\n                    // Add buildings as potential targets\n                    for (const building of player.buildings) {\n                        if (building.health > 0) {\n                            allEnemyTargets.push(building);\n                        }\n                    }\n                }\n                // Apply splash damage to all targets in range\n                const damagedTargets = projectile.applySplashDamage(allEnemyTargets);\n                // Create damage numbers for all damaged targets\n                for (const target of damagedTargets) {\n                    const distance = projectile.position.distanceTo(target.position);\n                    const damageMultiplier = 1.0 - (distance / projectile.splashRadius) * (1.0 - _constants__WEBPACK_IMPORTED_MODULE_0__.MORTAR_SPLASH_DAMAGE_FALLOFF);\n                    const finalDamage = Math.round(projectile.damage * damageMultiplier);\n                    if (target instanceof Unit) {\n                        const unitKey = `unit_${target.position.x}_${target.position.y}_${target.owner.name}`;\n                        this.addDamageNumber(target.position, finalDamage, target.maxHealth, target.health, unitKey);\n                    }\n                    else if ('isBuilding' in target && target.isBuilding) {\n                        const buildingKey = `building_${target.position.x}_${target.position.y}`;\n                        this.addDamageNumber(target.position, finalDamage, target.maxHealth, target.health, buildingKey);\n                    }\n                    else if ('isForge' in target && target.isForge) {\n                        const forgeKey = `forge_${target.position.x}_${target.position.y}`;\n                        this.addDamageNumber(target.position, finalDamage, target.maxHealth, target.health, forgeKey);\n                    }\n                }\n                // Mark projectile for removal\n                projectile.lifetime = projectile.maxLifetime;\n            }\n        }\n        this.mortarProjectiles = this.mortarProjectiles.filter(projectile => !projectile.shouldDespawn());\n        // Update minion projectiles and check for hits\n        for (const projectile of this.minionProjectiles) {\n            projectile.update(deltaTime);\n            // Check if projectile is blocked by Tank shields\n            let isBlocked = false;\n            for (const player of this.players) {\n                for (const unit of player.units) {\n                    if (unit instanceof Tank && unit.isPositionInShield(projectile.position)) {\n                        // Shield blocks projectiles but not friendly fire\n                        if (projectile.owner !== player) {\n                            isBlocked = true;\n                            projectile.distanceTraveledPx = projectile.maxRangePx; // Mark for removal\n                            break;\n                        }\n                    }\n                }\n                if (isBlocked)\n                    break;\n            }\n            if (isBlocked)\n                continue;\n            // Apply fluid-like force to space dust particles\n            const projectileSpeed = Math.sqrt(Math.pow(projectile.velocity.x, 2) + Math.pow(projectile.velocity.y, 2));\n            this.applyFluidForceFromMovingObject(projectile.position, projectile.velocity, _constants__WEBPACK_IMPORTED_MODULE_0__.MINION_PROJECTILE_EFFECT_RADIUS, projectileSpeed * _constants__WEBPACK_IMPORTED_MODULE_0__.MINION_PROJECTILE_FORCE_MULTIPLIER, deltaTime);\n            // Check for absorption by Space Dust Swirler buildings\n            let wasAbsorbed = false;\n            for (const player of this.players) {\n                for (const building of player.buildings) {\n                    if (building instanceof SpaceDustSwirler) {\n                        // Don't absorb friendly projectiles\n                        if (building.owner === projectile.owner)\n                            continue;\n                        if (building.absorbProjectile(projectile)) {\n                            // Mark projectile for removal by setting distance to max\n                            projectile.distanceTraveledPx = projectile.maxRangePx;\n                            wasAbsorbed = true;\n                            break;\n                        }\n                    }\n                }\n                if (wasAbsorbed)\n                    break;\n            }\n            if (wasAbsorbed)\n                continue;\n            let hasHit = false;\n            for (const player of this.players) {\n                if (player === projectile.owner) {\n                    continue;\n                }\n                for (const unit of player.units) {\n                    if (projectile.checkHit(unit)) {\n                        unit.takeDamage(projectile.damage);\n                        // Create damage number\n                        const unitKey = `unit_${unit.position.x}_${unit.position.y}_${unit.owner.name}`;\n                        this.addDamageNumber(unit.position, projectile.damage, unit.maxHealth, unit.health, unitKey);\n                        hasHit = true;\n                        break;\n                    }\n                }\n                if (hasHit) {\n                    break;\n                }\n                for (const mirror of player.solarMirrors) {\n                    if (mirror.health <= 0) {\n                        continue;\n                    }\n                    if (projectile.checkHit(mirror)) {\n                        mirror.health -= projectile.damage;\n                        const mirrorKey = `mirror_${mirror.position.x}_${mirror.position.y}_${player.name}`;\n                        this.addDamageNumber(mirror.position, projectile.damage, _constants__WEBPACK_IMPORTED_MODULE_0__.MIRROR_MAX_HEALTH, mirror.health, mirrorKey);\n                        hasHit = true;\n                        break;\n                    }\n                }\n                if (hasHit) {\n                    break;\n                }\n                for (const building of player.buildings) {\n                    if (projectile.checkHit(building)) {\n                        building.health -= projectile.damage;\n                        // Create damage number\n                        const buildingKey = `building_${building.position.x}_${building.position.y}_${player.name}`;\n                        this.addDamageNumber(building.position, projectile.damage, building.maxHealth, building.health, buildingKey);\n                        hasHit = true;\n                        break;\n                    }\n                }\n                if (hasHit) {\n                    break;\n                }\n                if (player.stellarForge && projectile.checkHit(player.stellarForge)) {\n                    player.stellarForge.health -= projectile.damage;\n                    // Create damage number\n                    const forgeKey = `forge_${player.stellarForge.position.x}_${player.stellarForge.position.y}_${player.name}`;\n                    this.addDamageNumber(player.stellarForge.position, projectile.damage, _constants__WEBPACK_IMPORTED_MODULE_0__.STELLAR_FORGE_MAX_HEALTH, player.stellarForge.health, forgeKey);\n                    hasHit = true;\n                    break;\n                }\n            }\n            if (hasHit) {\n                projectile.distanceTraveledPx = projectile.maxRangePx;\n            }\n        }\n        this.minionProjectiles = this.minionProjectiles.filter(projectile => !projectile.shouldDespawn());\n        // Update laser beams (visual effects only)\n        this.laserBeams = this.laserBeams.filter(laser => !laser.update(deltaTime));\n        // Update impact particles (visual effects only)\n        for (const particle of this.impactParticles) {\n            particle.update(deltaTime);\n        }\n        this.impactParticles = this.impactParticles.filter(particle => !particle.shouldDespawn());\n        // Update influence zones\n        this.influenceZones = this.influenceZones.filter(zone => !zone.update(deltaTime));\n        // Update influence ball projectiles\n        for (const projectile of this.influenceBallProjectiles) {\n            projectile.update(deltaTime);\n            // Apply fluid-like force to space dust particles\n            const projectileSpeed = Math.sqrt(Math.pow(projectile.velocity.x, 2) + Math.pow(projectile.velocity.y, 2));\n            this.applyFluidForceFromMovingObject(projectile.position, projectile.velocity, _constants__WEBPACK_IMPORTED_MODULE_0__.INFLUENCE_BALL_EFFECT_RADIUS, projectileSpeed * _constants__WEBPACK_IMPORTED_MODULE_0__.INFLUENCE_BALL_FORCE_MULTIPLIER, deltaTime);\n            // Check for absorption by Space Dust Swirler buildings\n            let wasAbsorbed = false;\n            for (const player of this.players) {\n                for (const building of player.buildings) {\n                    if (building instanceof SpaceDustSwirler) {\n                        // Don't absorb friendly projectiles\n                        if (building.owner === projectile.owner)\n                            continue;\n                        if (building.absorbProjectile(projectile)) {\n                            // Mark projectile for removal by setting lifetime to max\n                            projectile.lifetime = projectile.maxLifetime;\n                            wasAbsorbed = true;\n                            break;\n                        }\n                    }\n                }\n                if (wasAbsorbed)\n                    break;\n            }\n            if (wasAbsorbed)\n                continue;\n            // Check if should explode (max lifetime reached)\n            if (projectile.shouldExplode()) {\n                // Create influence zone\n                const zone = new InfluenceZone(new Vector2D(projectile.position.x, projectile.position.y), projectile.owner);\n                this.influenceZones.push(zone);\n            }\n        }\n        this.influenceBallProjectiles = this.influenceBallProjectiles.filter(p => !p.shouldExplode());\n        // Update crescent waves and handle stunning\n        for (const wave of this.crescentWaves) {\n            wave.update(deltaTime);\n            // Check for units in wave and stun them\n            for (const player of this.players) {\n                for (const unit of player.units) {\n                    // Only stun units that haven't been affected by this wave yet\n                    if (!wave.affectedUnits.has(unit) && wave.isPointInWave(unit.position)) {\n                        unit.applyStun(_constants__WEBPACK_IMPORTED_MODULE_0__.TANK_STUN_DURATION);\n                        wave.affectedUnits.add(unit);\n                    }\n                }\n            }\n            // Erase projectiles in wave\n            this.abilityBullets = this.abilityBullets.filter(bullet => {\n                if (wave.isPointInWave(bullet.position)) {\n                    return false; // Remove projectile\n                }\n                return true;\n            });\n            this.minionProjectiles = this.minionProjectiles.filter(projectile => {\n                if (wave.isPointInWave(projectile.position)) {\n                    return false; // Remove projectile\n                }\n                return true;\n            });\n            this.mortarProjectiles = this.mortarProjectiles.filter(projectile => {\n                if (wave.isPointInWave(projectile.position)) {\n                    return false; // Remove projectile\n                }\n                return true;\n            });\n            this.influenceBallProjectiles = this.influenceBallProjectiles.filter(projectile => {\n                if (wave.isPointInWave(projectile.position)) {\n                    return false; // Remove projectile\n                }\n                return true;\n            });\n            this.bouncingBullets = this.bouncingBullets.filter(bullet => {\n                if (wave.isPointInWave(bullet.position)) {\n                    return false; // Remove projectile\n                }\n                return true;\n            });\n        }\n        this.crescentWaves = this.crescentWaves.filter(wave => !wave.shouldDespawn());\n        // Update deployed turrets\n        const allUnitsAndStructures = [];\n        for (const player of this.players) {\n            if (!player.isDefeated()) {\n                allUnitsAndStructures.push(...player.units);\n                allUnitsAndStructures.push(...player.buildings);\n                for (const mirror of player.solarMirrors) {\n                    if (mirror.health > 0) {\n                        allUnitsAndStructures.push(mirror);\n                    }\n                }\n                if (player.stellarForge) {\n                    allUnitsAndStructures.push(player.stellarForge);\n                }\n            }\n        }\n        for (const turret of this.deployedTurrets) {\n            // Get enemies for this turret\n            const enemies = allUnitsAndStructures.filter(e => e.owner !== turret.owner);\n            turret.update(deltaTime, enemies);\n        }\n        this.deployedTurrets = this.deployedTurrets.filter(turret => !turret.isDead());\n        // Update damage numbers\n        for (const damageNumber of this.damageNumbers) {\n            damageNumber.update(deltaTime);\n        }\n        // Remove expired damage numbers\n        this.damageNumbers = this.damageNumbers.filter(dn => !dn.isExpired(this.gameTime));\n    }\n    /**\n     * Update space dust particles with physics and color influences\n     */\n    updateSpaceDust(deltaTime) {\n        this.applyDustRepulsion(deltaTime);\n        for (const particle of this.spaceDust) {\n            // Update particle position\n            particle.update(deltaTime);\n            // Check for influence from player bases\n            let closestInfluence = null;\n            for (let i = 0; i < this.players.length; i++) {\n                const player = this.players[i];\n                if (player.stellarForge && !player.isDefeated()) {\n                    const distance = particle.position.distanceTo(player.stellarForge.position);\n                    if (distance < _constants__WEBPACK_IMPORTED_MODULE_0__.INFLUENCE_RADIUS) {\n                        const color = i === 0 ? _constants__WEBPACK_IMPORTED_MODULE_0__.PLAYER_1_COLOR : _constants__WEBPACK_IMPORTED_MODULE_0__.PLAYER_2_COLOR;\n                        if (!closestInfluence || distance < closestInfluence.distance) {\n                            closestInfluence = { color, distance };\n                        }\n                    }\n                }\n            }\n            // Update particle color based on influence\n            if (closestInfluence) {\n                const blendFactor = 1.0 - (closestInfluence.distance / _constants__WEBPACK_IMPORTED_MODULE_0__.INFLUENCE_RADIUS);\n                particle.updateColor(closestInfluence.color, blendFactor);\n            }\n            else {\n                particle.updateColor(null, 0);\n            }\n        }\n        // Apply forces from warp gates (spiral effect)\n        for (const gate of this.warpGates) {\n            if (gate.isCharging && gate.chargeTime >= _constants__WEBPACK_IMPORTED_MODULE_0__.WARP_GATE_INITIAL_DELAY) {\n                for (const particle of this.spaceDust) {\n                    const distance = particle.position.distanceTo(gate.position);\n                    if (distance < _constants__WEBPACK_IMPORTED_MODULE_0__.WARP_GATE_SPIRAL_RADIUS && distance > _constants__WEBPACK_IMPORTED_MODULE_0__.WARP_GATE_SPIRAL_MIN_DISTANCE) {\n                        // Calculate spiral force\n                        const direction = new Vector2D(gate.position.x - particle.position.x, gate.position.y - particle.position.y).normalize();\n                        // Add tangential component for spiral\n                        const tangent = new Vector2D(-direction.y, direction.x);\n                        const force = new Vector2D(direction.x * _constants__WEBPACK_IMPORTED_MODULE_0__.WARP_GATE_SPIRAL_FORCE_RADIAL + tangent.x * _constants__WEBPACK_IMPORTED_MODULE_0__.WARP_GATE_SPIRAL_FORCE_TANGENT, direction.y * _constants__WEBPACK_IMPORTED_MODULE_0__.WARP_GATE_SPIRAL_FORCE_RADIAL + tangent.y * _constants__WEBPACK_IMPORTED_MODULE_0__.WARP_GATE_SPIRAL_FORCE_TANGENT);\n                        particle.applyForce(new Vector2D(force.x * deltaTime / distance, force.y * deltaTime / distance));\n                    }\n                }\n            }\n        }\n        // Apply forces from forge crunches (suck in, then wave out)\n        for (const player of this.players) {\n            if (player.stellarForge && !player.isDefeated()) {\n                const crunch = player.stellarForge.getCurrentCrunch();\n                if (crunch && crunch.isActive()) {\n                    for (const particle of this.spaceDust) {\n                        const distance = particle.position.distanceTo(crunch.position);\n                        if (crunch.phase === 'suck' && distance < _constants__WEBPACK_IMPORTED_MODULE_0__.FORGE_CRUNCH_SUCK_RADIUS) {\n                            // Suck phase: pull dust toward forge\n                            if (distance > 5) { // Minimum distance to avoid division by zero\n                                const direction = new Vector2D(crunch.position.x - particle.position.x, crunch.position.y - particle.position.y).normalize();\n                                // Force decreases with distance\n                                const forceMagnitude = _constants__WEBPACK_IMPORTED_MODULE_0__.FORGE_CRUNCH_SUCK_FORCE / Math.sqrt(distance);\n                                particle.applyForce(new Vector2D(direction.x * forceMagnitude * deltaTime, direction.y * forceMagnitude * deltaTime));\n                            }\n                        }\n                        else if (crunch.phase === 'wave' && distance < _constants__WEBPACK_IMPORTED_MODULE_0__.FORGE_CRUNCH_WAVE_RADIUS) {\n                            // Wave phase: push dust away from forge\n                            if (distance > 5) { // Minimum distance to avoid division by zero\n                                const direction = new Vector2D(particle.position.x - crunch.position.x, particle.position.y - crunch.position.y).normalize();\n                                // Wave effect: stronger push at the wavefront\n                                const waveProgress = crunch.getPhaseProgress();\n                                const wavePosition = waveProgress * _constants__WEBPACK_IMPORTED_MODULE_0__.FORGE_CRUNCH_WAVE_RADIUS;\n                                const distanceToWave = Math.abs(distance - wavePosition);\n                                const waveSharpness = 50; // How focused the wave is\n                                const waveStrength = Math.exp(-distanceToWave / waveSharpness);\n                                const forceMagnitude = _constants__WEBPACK_IMPORTED_MODULE_0__.FORGE_CRUNCH_WAVE_FORCE * waveStrength;\n                                particle.applyForce(new Vector2D(direction.x * forceMagnitude * deltaTime, direction.y * forceMagnitude * deltaTime));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        // Apply forces from Space Dust Swirler buildings (counter-clockwise orbits)\n        for (const player of this.players) {\n            for (const building of player.buildings) {\n                if (building instanceof SpaceDustSwirler) {\n                    building.applyDustSwirl(this.spaceDust, deltaTime);\n                }\n            }\n        }\n    }\n    applyDustRepulsion(deltaTime) {\n        const cellSize = _constants__WEBPACK_IMPORTED_MODULE_0__.DUST_REPULSION_CELL_SIZE_PX;\n        const repulsionRadiusPx = _constants__WEBPACK_IMPORTED_MODULE_0__.DUST_REPULSION_RADIUS_PX;\n        const repulsionRadiusSq = repulsionRadiusPx * repulsionRadiusPx;\n        const repulsionStrength = _constants__WEBPACK_IMPORTED_MODULE_0__.DUST_REPULSION_STRENGTH;\n        for (let i = 0; i < this.dustSpatialHashKeys.length; i++) {\n            const key = this.dustSpatialHashKeys[i];\n            const bucket = this.dustSpatialHash.get(key);\n            if (bucket) {\n                bucket.length = 0;\n            }\n        }\n        this.dustSpatialHashKeys.length = 0;\n        for (let i = 0; i < this.spaceDust.length; i++) {\n            const particle = this.spaceDust[i];\n            const cellX = Math.floor(particle.position.x / cellSize);\n            const cellY = Math.floor(particle.position.y / cellSize);\n            const key = (cellX << 16) ^ (cellY & 0xffff);\n            let bucket = this.dustSpatialHash.get(key);\n            if (!bucket) {\n                bucket = [];\n                this.dustSpatialHash.set(key, bucket);\n            }\n            if (bucket.length === 0) {\n                this.dustSpatialHashKeys.push(key);\n            }\n            bucket.push(i);\n        }\n        for (let i = 0; i < this.spaceDust.length; i++) {\n            const particle = this.spaceDust[i];\n            const cellX = Math.floor(particle.position.x / cellSize);\n            const cellY = Math.floor(particle.position.y / cellSize);\n            let forceX = 0;\n            let forceY = 0;\n            for (let offsetY = -1; offsetY <= 1; offsetY++) {\n                for (let offsetX = -1; offsetX <= 1; offsetX++) {\n                    const neighborKey = ((cellX + offsetX) << 16) ^ ((cellY + offsetY) & 0xffff);\n                    const bucket = this.dustSpatialHash.get(neighborKey);\n                    if (!bucket) {\n                        continue;\n                    }\n                    for (let j = 0; j < bucket.length; j++) {\n                        const neighborIndex = bucket[j];\n                        if (neighborIndex === i) {\n                            continue;\n                        }\n                        const neighbor = this.spaceDust[neighborIndex];\n                        const dx = particle.position.x - neighbor.position.x;\n                        const dy = particle.position.y - neighbor.position.y;\n                        const distSq = dx * dx + dy * dy;\n                        if (distSq > 0 && distSq < repulsionRadiusSq) {\n                            const dist = Math.sqrt(distSq);\n                            const strength = (1 - dist / repulsionRadiusPx) * repulsionStrength;\n                            forceX += (dx / dist) * strength;\n                            forceY += (dy / dist) * strength;\n                        }\n                    }\n                }\n            }\n            if (forceX !== 0 || forceY !== 0) {\n                particle.velocity.x += forceX * deltaTime;\n                particle.velocity.y += forceY * deltaTime;\n            }\n        }\n    }\n    updateAi(deltaTime) {\n        for (const player of this.players) {\n            if (!player.isAi || player.isDefeated()) {\n                continue;\n            }\n            const enemies = this.getEnemiesForPlayer(player);\n            this.updateAiMirrorsForPlayer(player);\n            this.updateAiMirrorPurchaseForPlayer(player);\n            this.updateAiDefenseForPlayer(player, enemies);\n            this.updateAiHeroProductionForPlayer(player);\n            this.updateAiStructuresForPlayer(player, enemies);\n        }\n    }\n    getEnemiesForPlayer(player) {\n        const enemies = [];\n        for (const otherPlayer of this.players) {\n            if (otherPlayer !== player && !otherPlayer.isDefeated()) {\n                enemies.push(...otherPlayer.units);\n                enemies.push(...otherPlayer.buildings);\n                for (const mirror of otherPlayer.solarMirrors) {\n                    if (mirror.health > 0) {\n                        enemies.push(mirror);\n                    }\n                }\n                if (otherPlayer.stellarForge) {\n                    enemies.push(otherPlayer.stellarForge);\n                }\n            }\n        }\n        return enemies;\n    }\n    updateAiMirrorsForPlayer(player) {\n        if (this.gameTime < player.aiNextMirrorCommandSec) {\n            return;\n        }\n        player.aiNextMirrorCommandSec = this.gameTime + _constants__WEBPACK_IMPORTED_MODULE_0__.AI_MIRROR_COMMAND_INTERVAL_SEC;\n        if (!player.stellarForge || player.solarMirrors.length === 0) {\n            return;\n        }\n        const sun = this.getClosestSunToPoint(player.stellarForge.position);\n        if (!sun) {\n            return;\n        }\n        const mirrorCount = player.solarMirrors.length;\n        const baseAngleRad = Math.atan2(player.stellarForge.position.y - sun.position.y, player.stellarForge.position.x - sun.position.x);\n        const startAngleRad = baseAngleRad - (_constants__WEBPACK_IMPORTED_MODULE_0__.AI_MIRROR_ARC_SPACING_RAD * (mirrorCount - 1)) / 2;\n        const radiusPx = sun.radius + _constants__WEBPACK_IMPORTED_MODULE_0__.AI_MIRROR_SUN_DISTANCE_PX;\n        for (let i = 0; i < mirrorCount; i++) {\n            const mirror = player.solarMirrors[i];\n            const angleRad = startAngleRad + _constants__WEBPACK_IMPORTED_MODULE_0__.AI_MIRROR_ARC_SPACING_RAD * i;\n            const target = new Vector2D(sun.position.x + Math.cos(angleRad) * radiusPx, sun.position.y + Math.sin(angleRad) * radiusPx);\n            const distance = mirror.position.distanceTo(target);\n            if (distance > _constants__WEBPACK_IMPORTED_MODULE_0__.AI_MIRROR_REPOSITION_THRESHOLD_PX) {\n                mirror.setTarget(target);\n            }\n        }\n    }\n    updateAiMirrorPurchaseForPlayer(player) {\n        if (this.gameTime < player.aiNextMirrorPurchaseCommandSec) {\n            return;\n        }\n        player.aiNextMirrorPurchaseCommandSec = this.gameTime + _constants__WEBPACK_IMPORTED_MODULE_0__.AI_MIRROR_PURCHASE_INTERVAL_SEC;\n        // Check if we should buy more mirrors based on strategy\n        if (!player.stellarForge) {\n            return;\n        }\n        const currentMirrorCount = player.solarMirrors.length;\n        // Determine mirror count target based on AI strategy\n        let targetMirrorCount = 2; // Default minimum\n        switch (player.aiStrategy) {\n            case _constants__WEBPACK_IMPORTED_MODULE_0__.AIStrategy.ECONOMIC:\n                targetMirrorCount = _constants__WEBPACK_IMPORTED_MODULE_0__.AI_MAX_MIRRORS; // Max out mirrors\n                break;\n            case _constants__WEBPACK_IMPORTED_MODULE_0__.AIStrategy.DEFENSIVE:\n                targetMirrorCount = 4; // Moderate mirrors for balanced economy\n                break;\n            case _constants__WEBPACK_IMPORTED_MODULE_0__.AIStrategy.AGGRESSIVE:\n                targetMirrorCount = 3; // Fewer mirrors, spend on units\n                break;\n            case _constants__WEBPACK_IMPORTED_MODULE_0__.AIStrategy.WAVES:\n                targetMirrorCount = 4; // Need economy for wave production\n                break;\n        }\n        // Don't buy more mirrors than target\n        if (currentMirrorCount >= targetMirrorCount) {\n            return;\n        }\n        // Check if we can afford a mirror\n        if (player.energy < _constants__WEBPACK_IMPORTED_MODULE_0__.SOLAR_MIRROR_COST) {\n            return;\n        }\n        // Find a good position for the new mirror\n        const sun = this.getClosestSunToPoint(player.stellarForge.position);\n        if (!sun) {\n            return;\n        }\n        // Calculate position around the sun\n        const baseAngleRad = Math.atan2(player.stellarForge.position.y - sun.position.y, player.stellarForge.position.x - sun.position.x);\n        const mirrorIndex = currentMirrorCount;\n        const startAngleRad = baseAngleRad - (_constants__WEBPACK_IMPORTED_MODULE_0__.AI_MIRROR_ARC_SPACING_RAD * targetMirrorCount) / 2;\n        const angleRad = startAngleRad + _constants__WEBPACK_IMPORTED_MODULE_0__.AI_MIRROR_ARC_SPACING_RAD * mirrorIndex;\n        const radiusPx = sun.radius + _constants__WEBPACK_IMPORTED_MODULE_0__.AI_MIRROR_SUN_DISTANCE_PX;\n        const mirrorPosition = new Vector2D(sun.position.x + Math.cos(angleRad) * radiusPx, sun.position.y + Math.sin(angleRad) * radiusPx);\n        // Purchase the mirror\n        if (player.spendEnergy(_constants__WEBPACK_IMPORTED_MODULE_0__.SOLAR_MIRROR_COST)) {\n            const newMirror = new SolarMirror(mirrorPosition, player);\n            player.solarMirrors.push(newMirror);\n        }\n    }\n    updateAiDefenseForPlayer(player, enemies) {\n        if (this.gameTime < player.aiNextDefenseCommandSec) {\n            return;\n        }\n        player.aiNextDefenseCommandSec = this.gameTime + _constants__WEBPACK_IMPORTED_MODULE_0__.AI_DEFENSE_COMMAND_INTERVAL_SEC;\n        const threat = this.findAiThreat(player, enemies);\n        if (threat) {\n            const threatPosition = threat.enemy.position;\n            for (const unit of player.units) {\n                if (unit.isHero) {\n                    unit.rallyPoint = new Vector2D(threatPosition.x, threatPosition.y);\n                }\n                else if (unit instanceof Starling) {\n                    unit.setManualRallyPoint(new Vector2D(threatPosition.x, threatPosition.y));\n                }\n            }\n            return;\n        }\n        if (!player.stellarForge) {\n            return;\n        }\n        // Strategy-based defense behavior\n        if (player.aiStrategy === _constants__WEBPACK_IMPORTED_MODULE_0__.AIStrategy.WAVES) {\n            // Waves strategy: Accumulate units at base until reaching threshold\n            const unitCount = player.units.length;\n            const waveThreshold = _constants__WEBPACK_IMPORTED_MODULE_0__.AI_WAVES_ATTACK_THRESHOLD;\n            if (unitCount >= waveThreshold) {\n                // Send all units to attack enemy base\n                const enemyForge = this.getEnemyForgeForPlayer(player);\n                if (enemyForge) {\n                    for (const unit of player.units) {\n                        if (unit.isHero || unit instanceof Starling) {\n                            unit.rallyPoint = new Vector2D(enemyForge.position.x, enemyForge.position.y);\n                            if (unit instanceof Starling) {\n                                unit.setManualRallyPoint(new Vector2D(enemyForge.position.x, enemyForge.position.y));\n                            }\n                        }\n                    }\n                    return;\n                }\n            }\n            else {\n                // Accumulate at base\n                for (const unit of player.units) {\n                    if (unit.isHero) {\n                        unit.rallyPoint = new Vector2D(player.stellarForge.position.x, player.stellarForge.position.y);\n                    }\n                    else if (unit instanceof Starling) {\n                        unit.setManualRallyPoint(new Vector2D(player.stellarForge.position.x, player.stellarForge.position.y));\n                    }\n                }\n                return;\n            }\n        }\n        else if (player.aiStrategy === _constants__WEBPACK_IMPORTED_MODULE_0__.AIStrategy.AGGRESSIVE) {\n            // Aggressive strategy: Always push to enemy base\n            const enemyForge = this.getEnemyForgeForPlayer(player);\n            if (enemyForge) {\n                for (const unit of player.units) {\n                    if (unit.isHero) {\n                        unit.rallyPoint = new Vector2D(enemyForge.position.x, enemyForge.position.y);\n                    }\n                    else if (unit instanceof Starling) {\n                        unit.setManualRallyPoint(new Vector2D(enemyForge.position.x, enemyForge.position.y));\n                    }\n                }\n                return;\n            }\n        }\n        // Default behavior (for ECONOMIC and DEFENSIVE): Defend mirrors and base\n        const mirrorCount = player.solarMirrors.length;\n        let mirrorIndex = 0;\n        for (const unit of player.units) {\n            if (unit.isHero) {\n                unit.rallyPoint = new Vector2D(player.stellarForge.position.x, player.stellarForge.position.y);\n            }\n            else if (unit instanceof Starling) {\n                if (mirrorIndex < mirrorCount) {\n                    const mirror = player.solarMirrors[mirrorIndex];\n                    unit.setManualRallyPoint(new Vector2D(mirror.position.x, mirror.position.y));\n                    mirrorIndex += 1;\n                }\n                else {\n                    unit.setManualRallyPoint(new Vector2D(player.stellarForge.position.x, player.stellarForge.position.y));\n                }\n            }\n        }\n    }\n    getEnemyForgeForPlayer(player) {\n        for (const otherPlayer of this.players) {\n            if (otherPlayer !== player && !otherPlayer.isDefeated() && otherPlayer.stellarForge) {\n                return otherPlayer.stellarForge;\n            }\n        }\n        return null;\n    }\n    updateAiHeroProductionForPlayer(player) {\n        if (this.gameTime < player.aiNextHeroCommandSec) {\n            return;\n        }\n        // Strategy-based hero production intervals\n        let heroProductionInterval = _constants__WEBPACK_IMPORTED_MODULE_0__.AI_HERO_COMMAND_INTERVAL_SEC;\n        switch (player.aiStrategy) {\n            case _constants__WEBPACK_IMPORTED_MODULE_0__.AIStrategy.AGGRESSIVE:\n                heroProductionInterval = _constants__WEBPACK_IMPORTED_MODULE_0__.AI_HERO_COMMAND_INTERVAL_SEC * _constants__WEBPACK_IMPORTED_MODULE_0__.AI_AGGRESSIVE_HERO_MULTIPLIER;\n                break;\n            case _constants__WEBPACK_IMPORTED_MODULE_0__.AIStrategy.ECONOMIC:\n                heroProductionInterval = _constants__WEBPACK_IMPORTED_MODULE_0__.AI_HERO_COMMAND_INTERVAL_SEC * _constants__WEBPACK_IMPORTED_MODULE_0__.AI_ECONOMIC_HERO_MULTIPLIER;\n                break;\n            case _constants__WEBPACK_IMPORTED_MODULE_0__.AIStrategy.WAVES:\n                heroProductionInterval = _constants__WEBPACK_IMPORTED_MODULE_0__.AI_HERO_COMMAND_INTERVAL_SEC * _constants__WEBPACK_IMPORTED_MODULE_0__.AI_WAVES_HERO_MULTIPLIER;\n                break;\n            default:\n                heroProductionInterval = _constants__WEBPACK_IMPORTED_MODULE_0__.AI_HERO_COMMAND_INTERVAL_SEC;\n        }\n        player.aiNextHeroCommandSec = this.gameTime + heroProductionInterval;\n        if (!player.stellarForge || !player.stellarForge.canProduceUnits()) {\n            return;\n        }\n        const heroTypes = this.getAiHeroTypesForFaction(player.faction);\n        for (const heroType of heroTypes) {\n            if (this.isHeroUnitAlive(player, heroType)) {\n                continue;\n            }\n            if (this.isHeroUnitQueuedOrProducing(player.stellarForge, heroType)) {\n                continue;\n            }\n            if (!player.spendEnergy(_constants__WEBPACK_IMPORTED_MODULE_0__.HERO_UNIT_COST)) {\n                return;\n            }\n            player.stellarForge.enqueueHeroUnit(heroType);\n            player.stellarForge.startHeroProductionIfIdle();\n            return;\n        }\n    }\n    updateAiStructuresForPlayer(player, enemies) {\n        var _a;\n        if (this.gameTime < player.aiNextStructureCommandSec) {\n            return;\n        }\n        player.aiNextStructureCommandSec = this.gameTime + _constants__WEBPACK_IMPORTED_MODULE_0__.AI_STRUCTURE_COMMAND_INTERVAL_SEC;\n        if (!player.stellarForge) {\n            return;\n        }\n        const minigunCount = player.buildings.filter((building) => building instanceof Minigun).length;\n        const swirlerCount = player.buildings.filter((building) => building instanceof SpaceDustSwirler).length;\n        const hasSubsidiaryFactory = player.buildings.some((building) => building instanceof SubsidiaryFactory);\n        let buildType = null;\n        // Strategy-based building priorities\n        switch (player.aiStrategy) {\n            case _constants__WEBPACK_IMPORTED_MODULE_0__.AIStrategy.ECONOMIC:\n                // Economic: Build factory first, then minimal defenses\n                if (!hasSubsidiaryFactory && player.energy >= _constants__WEBPACK_IMPORTED_MODULE_0__.SUBSIDIARY_FACTORY_COST) {\n                    buildType = 'subsidiaryFactory';\n                }\n                else if (minigunCount < 1 && player.energy >= _constants__WEBPACK_IMPORTED_MODULE_0__.MINIGUN_COST) {\n                    buildType = 'minigun';\n                }\n                else if (swirlerCount < 1 && player.energy >= _constants__WEBPACK_IMPORTED_MODULE_0__.SWIRLER_COST) {\n                    buildType = 'swirler';\n                }\n                break;\n            case _constants__WEBPACK_IMPORTED_MODULE_0__.AIStrategy.DEFENSIVE:\n                // Defensive: Prioritize defenses heavily\n                if (swirlerCount < 2 && player.energy >= _constants__WEBPACK_IMPORTED_MODULE_0__.SWIRLER_COST) {\n                    buildType = 'swirler';\n                }\n                else if (minigunCount < 3 && player.energy >= _constants__WEBPACK_IMPORTED_MODULE_0__.MINIGUN_COST) {\n                    buildType = 'minigun';\n                }\n                else if (!hasSubsidiaryFactory && player.energy >= _constants__WEBPACK_IMPORTED_MODULE_0__.SUBSIDIARY_FACTORY_COST) {\n                    buildType = 'subsidiaryFactory';\n                }\n                else if (minigunCount < 5 && player.energy >= _constants__WEBPACK_IMPORTED_MODULE_0__.MINIGUN_COST) {\n                    buildType = 'minigun';\n                }\n                break;\n            case _constants__WEBPACK_IMPORTED_MODULE_0__.AIStrategy.AGGRESSIVE:\n                // Aggressive: Build factory early, skip most defenses\n                if (!hasSubsidiaryFactory && player.energy >= _constants__WEBPACK_IMPORTED_MODULE_0__.SUBSIDIARY_FACTORY_COST) {\n                    buildType = 'subsidiaryFactory';\n                }\n                else if (minigunCount < 1 && player.energy >= _constants__WEBPACK_IMPORTED_MODULE_0__.MINIGUN_COST) {\n                    buildType = 'minigun';\n                }\n                break;\n            case _constants__WEBPACK_IMPORTED_MODULE_0__.AIStrategy.WAVES:\n                // Waves: Balanced approach with factory priority\n                if (!hasSubsidiaryFactory && player.energy >= _constants__WEBPACK_IMPORTED_MODULE_0__.SUBSIDIARY_FACTORY_COST) {\n                    buildType = 'subsidiaryFactory';\n                }\n                else if (minigunCount < 2 && player.energy >= _constants__WEBPACK_IMPORTED_MODULE_0__.MINIGUN_COST) {\n                    buildType = 'minigun';\n                }\n                else if (swirlerCount < 1 && player.energy >= _constants__WEBPACK_IMPORTED_MODULE_0__.SWIRLER_COST) {\n                    buildType = 'swirler';\n                }\n                else if (minigunCount < 3 && player.energy >= _constants__WEBPACK_IMPORTED_MODULE_0__.MINIGUN_COST) {\n                    buildType = 'minigun';\n                }\n                break;\n        }\n        if (!buildType) {\n            return;\n        }\n        const threat = this.findAiThreat(player, enemies);\n        const anchor = (_a = threat === null || threat === void 0 ? void 0 : threat.guardPoint) !== null && _a !== void 0 ? _a : this.getAiStructureAnchor(player);\n        if (!anchor) {\n            return;\n        }\n        let placement = null;\n        switch (buildType) {\n            case 'subsidiaryFactory':\n                placement = this.findAiStructurePlacement(anchor, _constants__WEBPACK_IMPORTED_MODULE_0__.SUBSIDIARY_FACTORY_RADIUS, player);\n                if (placement && player.spendEnergy(_constants__WEBPACK_IMPORTED_MODULE_0__.SUBSIDIARY_FACTORY_COST)) {\n                    player.buildings.push(new SubsidiaryFactory(placement, player));\n                }\n                break;\n            case 'swirler':\n                placement = this.findAiStructurePlacement(anchor, _constants__WEBPACK_IMPORTED_MODULE_0__.SWIRLER_RADIUS, player);\n                if (placement && player.spendEnergy(_constants__WEBPACK_IMPORTED_MODULE_0__.SWIRLER_COST)) {\n                    player.buildings.push(new SpaceDustSwirler(placement, player));\n                }\n                break;\n            case 'minigun':\n                placement = this.findAiStructurePlacement(anchor, _constants__WEBPACK_IMPORTED_MODULE_0__.MINIGUN_RADIUS, player);\n                if (placement && player.spendEnergy(_constants__WEBPACK_IMPORTED_MODULE_0__.MINIGUN_COST)) {\n                    player.buildings.push(new Minigun(placement, player));\n                }\n                break;\n        }\n    }\n    getAiStructureAnchor(player) {\n        if (!player.stellarForge) {\n            return null;\n        }\n        if (player.solarMirrors.length === 0 || this.suns.length === 0) {\n            return player.stellarForge.position;\n        }\n        let bestMirror = null;\n        let bestDistance = Infinity;\n        for (const mirror of player.solarMirrors) {\n            const closestSun = mirror.getClosestSun(this.suns);\n            if (!closestSun) {\n                continue;\n            }\n            const distance = mirror.position.distanceTo(closestSun.position);\n            if (distance < bestDistance) {\n                bestDistance = distance;\n                bestMirror = mirror;\n            }\n        }\n        return bestMirror ? bestMirror.position : player.stellarForge.position;\n    }\n    findAiStructurePlacement(anchor, radiusPx, player) {\n        const baseAngleRad = player.buildings.length * _constants__WEBPACK_IMPORTED_MODULE_0__.AI_STRUCTURE_PLACEMENT_ANGLE_STEP_RAD;\n        const distancePx = _constants__WEBPACK_IMPORTED_MODULE_0__.AI_STRUCTURE_PLACEMENT_DISTANCE_PX + radiusPx;\n        for (let i = 0; i < 8; i++) {\n            const angleRad = baseAngleRad + _constants__WEBPACK_IMPORTED_MODULE_0__.AI_STRUCTURE_PLACEMENT_ANGLE_STEP_RAD * i;\n            const candidate = new Vector2D(anchor.x + Math.cos(angleRad) * distancePx, anchor.y + Math.sin(angleRad) * distancePx);\n            if (!this.checkCollision(candidate, radiusPx)) {\n                return candidate;\n            }\n        }\n        return null;\n    }\n    findAiThreat(player, enemies) {\n        if (!player.stellarForge) {\n            return null;\n        }\n        const guardPoints = [player.stellarForge.position];\n        for (const mirror of player.solarMirrors) {\n            guardPoints.push(mirror.position);\n        }\n        let closestThreat = null;\n        let closestGuardPoint = null;\n        let closestDistanceSq = Infinity;\n        const defenseRadiusSq = _constants__WEBPACK_IMPORTED_MODULE_0__.AI_DEFENSE_RADIUS_PX * _constants__WEBPACK_IMPORTED_MODULE_0__.AI_DEFENSE_RADIUS_PX;\n        for (const guardPoint of guardPoints) {\n            for (const enemy of enemies) {\n                if ('health' in enemy && enemy.health <= 0) {\n                    continue;\n                }\n                const dx = enemy.position.x - guardPoint.x;\n                const dy = enemy.position.y - guardPoint.y;\n                const distanceSq = dx * dx + dy * dy;\n                if (distanceSq <= defenseRadiusSq && distanceSq < closestDistanceSq) {\n                    closestDistanceSq = distanceSq;\n                    closestThreat = enemy;\n                    closestGuardPoint = guardPoint;\n                }\n            }\n        }\n        if (!closestThreat || !closestGuardPoint) {\n            return null;\n        }\n        return { enemy: closestThreat, guardPoint: closestGuardPoint };\n    }\n    getClosestSunToPoint(point) {\n        let closestSun = null;\n        let closestDistance = Infinity;\n        for (const sun of this.suns) {\n            const distance = point.distanceTo(sun.position);\n            if (distance < closestDistance) {\n                closestDistance = distance;\n                closestSun = sun;\n            }\n        }\n        return closestSun;\n    }\n    getAiHeroTypesForFaction(faction) {\n        switch (faction) {\n            case Faction.RADIANT:\n                return ['Marine', 'Dagger', 'Beam', 'Mortar', 'Preist', 'Tank'];\n            case Faction.AURUM:\n                return ['Grave', 'Driller'];\n            case Faction.SOLARI:\n                return ['Ray', 'InfluenceBall', 'TurretDeployer'];\n            default:\n                return [];\n        }\n    }\n    isHeroUnitOfType(unit, heroUnitType) {\n        switch (heroUnitType) {\n            case 'Marine':\n                return unit instanceof Marine;\n            case 'Grave':\n                return unit instanceof Grave;\n            case 'Ray':\n                return unit instanceof Ray;\n            case 'InfluenceBall':\n                return unit instanceof InfluenceBall;\n            case 'TurretDeployer':\n                return unit instanceof TurretDeployer;\n            case 'Driller':\n                return unit instanceof Driller;\n            case 'Dagger':\n                return unit instanceof Dagger;\n            case 'Beam':\n                return unit instanceof Beam;\n            case 'Mortar':\n                return unit instanceof Mortar;\n            case 'Preist':\n                return unit instanceof Preist;\n            case 'Tank':\n                return unit instanceof Tank;\n            default:\n                return false;\n        }\n    }\n    isHeroUnitAlive(player, heroUnitType) {\n        return player.units.some((unit) => this.isHeroUnitOfType(unit, heroUnitType));\n    }\n    isHeroUnitQueuedOrProducing(forge, heroUnitType) {\n        return forge.heroProductionUnitType === heroUnitType || forge.unitQueue.includes(heroUnitType);\n    }\n    applyDustPushFromMovingEntity(position, velocity, radiusPx, forceMultiplier, deltaTime) {\n        const speed = Math.sqrt(Math.pow(velocity.x, 2) + Math.pow(velocity.y, 2));\n        if (speed <= 0) {\n            return;\n        }\n        const effectiveSpeed = Math.max(speed, _constants__WEBPACK_IMPORTED_MODULE_0__.DUST_PUSH_MIN_EFFECTIVE_SPEED_PX_PER_SEC);\n        this.applyFluidForceFromMovingObject(position, velocity, radiusPx, effectiveSpeed * forceMultiplier, deltaTime);\n    }\n    /**\n     * Apply fluid-like forces to particles from a moving object (projectile)\n     * Particles closer to the object get pushed more, with falloff based on distance\n     *\n     * @param position - World position of the moving object (pixels)\n     * @param velocity - Velocity vector of the moving object (pixels/second)\n     * @param radius - Effect radius in pixels (particles beyond this distance are not affected)\n     * @param strength - Base force strength (higher values create stronger displacement)\n     * @param deltaTime - Time delta in seconds for frame-independent physics\n     */\n    applyFluidForceFromMovingObject(position, velocity, radius, strength, deltaTime) {\n        for (const particle of this.spaceDust) {\n            const distance = particle.position.distanceTo(position);\n            if (distance < radius && distance > _constants__WEBPACK_IMPORTED_MODULE_0__.FLUID_MIN_DISTANCE) {\n                // Calculate direction from object to particle\n                const directionToParticle = new Vector2D(particle.position.x - position.x, particle.position.y - position.y).normalize();\n                // Combine forward motion with radial push\n                const velocityNorm = velocity.normalize();\n                // Mix of forward push and radial displacement (like fluid being displaced)\n                const forwardComponent = _constants__WEBPACK_IMPORTED_MODULE_0__.FLUID_FORWARD_COMPONENT;\n                const radialComponent = _constants__WEBPACK_IMPORTED_MODULE_0__.FLUID_RADIAL_COMPONENT;\n                const pushDirection = new Vector2D(velocityNorm.x * forwardComponent + directionToParticle.x * radialComponent, velocityNorm.y * forwardComponent + directionToParticle.y * radialComponent);\n                // Force falls off with distance (inverse square for more realistic fluid behavior)\n                const distanceFactor = 1.0 - (distance / radius);\n                const forceMagnitude = strength * distanceFactor * distanceFactor;\n                particle.applyForce(new Vector2D(pushDirection.x * forceMagnitude * deltaTime, pushDirection.y * forceMagnitude * deltaTime));\n            }\n        }\n    }\n    /**\n     * Apply fluid-like forces to particles from a beam segment\n     * Creates a line-based displacement field along the beam\n     *\n     * @param startPos - Starting position of the beam segment (pixels)\n     * @param endPos - Ending position of the beam segment (pixels)\n     * @param radius - Effect radius around the beam line in pixels\n     * @param strength - Base force strength (higher values create stronger displacement)\n     * @param deltaTime - Time delta in seconds for frame-independent physics\n     */\n    applyFluidForceFromBeam(startPos, endPos, radius, strength, deltaTime) {\n        // Calculate beam direction\n        const beamLength = startPos.distanceTo(endPos);\n        if (beamLength < _constants__WEBPACK_IMPORTED_MODULE_0__.FLUID_MIN_DISTANCE)\n            return;\n        const beamDirection = new Vector2D(endPos.x - startPos.x, endPos.y - startPos.y).normalize();\n        for (const particle of this.spaceDust) {\n            // Find closest point on line segment to particle\n            const toParticle = new Vector2D(particle.position.x - startPos.x, particle.position.y - startPos.y);\n            // Project particle position onto beam line\n            const projection = toParticle.x * beamDirection.x + toParticle.y * beamDirection.y;\n            const clampedProjection = Math.max(0, Math.min(beamLength, projection));\n            // Closest point on beam to particle\n            const closestPoint = new Vector2D(startPos.x + beamDirection.x * clampedProjection, startPos.y + beamDirection.y * clampedProjection);\n            const distance = particle.position.distanceTo(closestPoint);\n            if (distance < radius && distance > _constants__WEBPACK_IMPORTED_MODULE_0__.FLUID_MIN_DISTANCE) {\n                // Direction from beam to particle (perpendicular push)\n                const directionToParticle = new Vector2D(particle.position.x - closestPoint.x, particle.position.y - closestPoint.y).normalize();\n                // Combine beam direction with radial push\n                // Particles along beam get pushed forward and outward\n                const alongBeamComponent = _constants__WEBPACK_IMPORTED_MODULE_0__.BEAM_ALONG_COMPONENT;\n                const perpendicularComponent = _constants__WEBPACK_IMPORTED_MODULE_0__.BEAM_PERPENDICULAR_COMPONENT;\n                const pushDirection = new Vector2D(beamDirection.x * alongBeamComponent + directionToParticle.x * perpendicularComponent, beamDirection.y * alongBeamComponent + directionToParticle.y * perpendicularComponent);\n                // Force falls off with distance from beam\n                const distanceFactor = 1.0 - (distance / radius);\n                const forceMagnitude = strength * distanceFactor * distanceFactor;\n                particle.applyForce(new Vector2D(pushDirection.x * forceMagnitude * deltaTime, pushDirection.y * forceMagnitude * deltaTime));\n            }\n        }\n    }\n    /**\n     * Initialize mirror movement at the start of countdown\n     * Moves mirrors outward perpendicular to base position\n     */\n    initializeMirrorMovement() {\n        if (this.suns.length === 0)\n            return;\n        const sun = this.suns[0]; // Use first sun as reference\n        for (const player of this.players) {\n            if (!player.stellarForge || player.solarMirrors.length < 2)\n                continue;\n            const forgePos = player.stellarForge.position;\n            // Calculate angle from sun to forge\n            const dx = forgePos.x - sun.position.x;\n            const dy = forgePos.y - sun.position.y;\n            const angleToForge = Math.atan2(dy, dx);\n            // Calculate perpendicular angles (left and right relative to sun-to-forge direction)\n            const leftAngle = angleToForge + Math.PI / 2;\n            const rightAngle = angleToForge - Math.PI / 2;\n            // Set target positions for the two mirrors\n            if (player.solarMirrors.length >= 1) {\n                const leftTarget = new Vector2D(forgePos.x + Math.cos(leftAngle) * _constants__WEBPACK_IMPORTED_MODULE_0__.MIRROR_COUNTDOWN_DEPLOY_DISTANCE, forgePos.y + Math.sin(leftAngle) * _constants__WEBPACK_IMPORTED_MODULE_0__.MIRROR_COUNTDOWN_DEPLOY_DISTANCE);\n                player.solarMirrors[0].setTarget(leftTarget);\n            }\n            if (player.solarMirrors.length >= 2) {\n                const rightTarget = new Vector2D(forgePos.x + Math.cos(rightAngle) * _constants__WEBPACK_IMPORTED_MODULE_0__.MIRROR_COUNTDOWN_DEPLOY_DISTANCE, forgePos.y + Math.sin(rightAngle) * _constants__WEBPACK_IMPORTED_MODULE_0__.MIRROR_COUNTDOWN_DEPLOY_DISTANCE);\n                player.solarMirrors[1].setTarget(rightTarget);\n            }\n        }\n    }\n    /**\n     * Check if a point is in shadow cast by asteroids from all suns\n     * Returns true if the point is in shadow from all light sources\n     */\n    isPointInShadow(point) {\n        // If no suns, everything is in shadow\n        if (this.suns.length === 0)\n            return true;\n        // Point must have line of sight to at least one sun to not be in shadow\n        for (const sun of this.suns) {\n            const direction = new Vector2D(sun.position.x - point.x, sun.position.y - point.y).normalize();\n            const ray = new LightRay(point, direction);\n            const distanceToSun = point.distanceTo(sun.position);\n            let hasLineOfSight = true;\n            for (const asteroid of this.asteroids) {\n                const intersectionDist = ray.getIntersectionDistance(asteroid.getWorldVertices());\n                if (intersectionDist !== null && intersectionDist < distanceToSun) {\n                    hasLineOfSight = false;\n                    break;\n                }\n            }\n            if (hasLineOfSight) {\n                return false; // Can see at least one sun, not in shadow\n            }\n        }\n        return true; // Cannot see any sun, in shadow\n    }\n    /**\n     * Check if an enemy object is visible to a player\n     * Objects are visible if:\n     * - They are NOT in shadow (in light), OR\n     * - They are in shadow but within proximity range of player unit, OR\n     * - They are in shadow but within player's influence radius\n     */\n    isObjectVisibleToPlayer(objectPos, player, object) {\n        // Special case: if object is a Dagger unit and is cloaked\n        if (object && object instanceof Dagger) {\n            // Dagger is only visible to enemies if not cloaked\n            if (object.isCloakedToEnemies() && object.owner !== player) {\n                return false; // Cloaked Daggers are invisible to enemies\n            }\n        }\n        // Check if object is in shadow\n        const inShadow = this.isPointInShadow(objectPos);\n        // If not in shadow, always visible\n        if (!inShadow) {\n            return true;\n        }\n        // In shadow - check proximity to player units\n        for (const unit of player.units) {\n            const distance = unit.position.distanceTo(objectPos);\n            if (distance <= _constants__WEBPACK_IMPORTED_MODULE_0__.VISIBILITY_PROXIMITY_RANGE) {\n                return true;\n            }\n        }\n        // In shadow - check if within player's influence\n        if (player.stellarForge) {\n            const distanceToForge = player.stellarForge.position.distanceTo(objectPos);\n            if (distanceToForge <= _constants__WEBPACK_IMPORTED_MODULE_0__.INFLUENCE_RADIUS) {\n                return true;\n            }\n        }\n        return false; // Not visible: in shadow and not within proximity or influence range\n    }\n    /**\n     * Process Ray's bouncing beam ability\n     */\n    processRayBeamAbility(ray) {\n        if (!ray.drillDirection) {\n            return;\n        }\n        const segments = [];\n        let currentPos = new Vector2D(ray.position.x, ray.position.y);\n        let currentDir = ray.drillDirection.normalize();\n        let bounces = 0;\n        const maxDistance = 2000; // Max beam travel distance\n        while (bounces < _constants__WEBPACK_IMPORTED_MODULE_0__.RAY_BEAM_MAX_BOUNCES) {\n            // Cast ray to find next hit\n            let closestHit = null;\n            let closestDistance = maxDistance;\n            // Check asteroids\n            for (const asteroid of this.asteroids) {\n                const hitPos = this.rayIntersectsAsteroid(currentPos, currentDir, asteroid);\n                if (hitPos) {\n                    const distance = currentPos.distanceTo(hitPos);\n                    if (distance < closestDistance) {\n                        closestDistance = distance;\n                        closestHit = { pos: hitPos, type: 'asteroid' };\n                    }\n                }\n            }\n            // Check enemy units\n            for (const player of this.players) {\n                if (player === ray.owner)\n                    continue;\n                for (const unit of player.units) {\n                    const hitPos = this.rayIntersectsUnit(currentPos, currentDir, unit.position);\n                    if (hitPos) {\n                        const distance = currentPos.distanceTo(hitPos);\n                        if (distance < closestDistance) {\n                            closestDistance = distance;\n                            closestHit = { pos: hitPos, type: 'unit', target: unit };\n                        }\n                    }\n                }\n                // Check enemy forge\n                if (player.stellarForge) {\n                    const hitPos = this.rayIntersectsUnit(currentPos, currentDir, player.stellarForge.position, player.stellarForge.radius);\n                    if (hitPos) {\n                        const distance = currentPos.distanceTo(hitPos);\n                        if (distance < closestDistance) {\n                            closestDistance = distance;\n                            closestHit = { pos: hitPos, type: 'forge', target: player.stellarForge };\n                        }\n                    }\n                }\n            }\n            // Check suns\n            for (const sun of this.suns) {\n                const hitPos = this.rayIntersectsUnit(currentPos, currentDir, sun.position, sun.radius);\n                if (hitPos) {\n                    const distance = currentPos.distanceTo(hitPos);\n                    if (distance < closestDistance) {\n                        closestDistance = distance;\n                        closestHit = { pos: hitPos, type: 'sun' };\n                    }\n                }\n            }\n            // Check map edges\n            const edgeHit = this.rayIntersectsEdge(currentPos, currentDir);\n            if (edgeHit && currentPos.distanceTo(edgeHit) < closestDistance) {\n                closestDistance = currentPos.distanceTo(edgeHit);\n                closestHit = { pos: edgeHit, type: 'edge' };\n            }\n            if (!closestHit) {\n                // No hit, beam continues to max distance\n                const endPos = new Vector2D(currentPos.x + currentDir.x * maxDistance, currentPos.y + currentDir.y * maxDistance);\n                segments.push(new RayBeamSegment(currentPos, endPos, ray.owner));\n                break;\n            }\n            // Add segment to hit point\n            segments.push(new RayBeamSegment(currentPos, closestHit.pos, ray.owner));\n            // Handle hit\n            if (closestHit.type === 'unit' || closestHit.type === 'forge') {\n                // Damage and stop\n                if (closestHit.target) {\n                    closestHit.target.takeDamage(_constants__WEBPACK_IMPORTED_MODULE_0__.RAY_BEAM_DAMAGE);\n                    // Create damage number\n                    const maxHealth = closestHit.type === 'forge'\n                        ? _constants__WEBPACK_IMPORTED_MODULE_0__.STELLAR_FORGE_MAX_HEALTH\n                        : closestHit.target.maxHealth;\n                    const targetKey = closestHit.type === 'forge'\n                        ? `forge_${closestHit.target.position.x}_${closestHit.target.position.y}_${closestHit.target.owner.name}`\n                        : `unit_${closestHit.target.position.x}_${closestHit.target.position.y}_${closestHit.target.owner.name}`;\n                    this.addDamageNumber(closestHit.target.position, _constants__WEBPACK_IMPORTED_MODULE_0__.RAY_BEAM_DAMAGE, maxHealth, closestHit.target.health, targetKey);\n                }\n                break;\n            }\n            else if (closestHit.type === 'sun' || closestHit.type === 'edge') {\n                // Stop at sun or edge\n                break;\n            }\n            else if (closestHit.type === 'asteroid') {\n                // Bounce off asteroid\n                bounces++;\n                currentPos = closestHit.pos;\n                // Calculate reflection direction (simplified)\n                currentDir = new Vector2D(-currentDir.x, -currentDir.y); // Simple bounce for now\n            }\n        }\n        ray.setBeamSegments(segments);\n    }\n    /**\n     * Check if ray intersects with an asteroid\n     */\n    rayIntersectsAsteroid(origin, direction, asteroid) {\n        // Simplified ray-polygon intersection\n        // For now, treat asteroid as circle\n        const toAsteroid = new Vector2D(asteroid.position.x - origin.x, asteroid.position.y - origin.y);\n        const projection = toAsteroid.x * direction.x + toAsteroid.y * direction.y;\n        if (projection < 0)\n            return null; // Behind ray\n        const closestPoint = new Vector2D(origin.x + direction.x * projection, origin.y + direction.y * projection);\n        const distance = closestPoint.distanceTo(asteroid.position);\n        if (distance < 60) { // Approximate asteroid radius\n            return closestPoint;\n        }\n        return null;\n    }\n    /**\n     * Check if ray intersects with a circular unit\n     */\n    rayIntersectsUnit(origin, direction, targetPos, radius = 8) {\n        const toTarget = new Vector2D(targetPos.x - origin.x, targetPos.y - origin.y);\n        const projection = toTarget.x * direction.x + toTarget.y * direction.y;\n        if (projection < 0)\n            return null; // Behind ray\n        const closestPoint = new Vector2D(origin.x + direction.x * projection, origin.y + direction.y * projection);\n        const distance = closestPoint.distanceTo(targetPos);\n        if (distance < radius) {\n            return closestPoint;\n        }\n        return null;\n    }\n    /**\n     * Check if ray intersects with map edge\n     */\n    rayIntersectsEdge(origin, direction) {\n        const mapSize = this.mapSize;\n        let closestHit = null;\n        let closestDist = Infinity;\n        // Check all four edges\n        const edges = [\n            { x: 0, normal: new Vector2D(1, 0) },\n            { x: mapSize, normal: new Vector2D(-1, 0) },\n            { y: 0, normal: new Vector2D(0, 1) },\n            { y: mapSize, normal: new Vector2D(0, -1) }\n        ];\n        for (const edge of edges) {\n            let hitPos = null;\n            if ('x' in edge && edge.x !== undefined) {\n                if (Math.abs(direction.x) > 0.001) {\n                    const t = (edge.x - origin.x) / direction.x;\n                    if (t > 0) {\n                        hitPos = new Vector2D(edge.x, origin.y + direction.y * t);\n                    }\n                }\n            }\n            else if ('y' in edge && edge.y !== undefined) {\n                if (Math.abs(direction.y) > 0.001) {\n                    const t = (edge.y - origin.y) / direction.y;\n                    if (t > 0) {\n                        hitPos = new Vector2D(origin.x + direction.x * t, edge.y);\n                    }\n                }\n            }\n            if (hitPos) {\n                const dist = origin.distanceTo(hitPos);\n                if (dist < closestDist) {\n                    closestDist = dist;\n                    closestHit = hitPos;\n                }\n            }\n        }\n        return closestHit;\n    }\n    /**\n     * Process turret deployment for TurretDeployer\n     */\n    processTurretDeployment(deployer) {\n        // Find nearest asteroid\n        let nearestAsteroid = null;\n        let minDistance = Infinity;\n        for (const asteroid of this.asteroids) {\n            const distance = deployer.position.distanceTo(asteroid.position);\n            if (distance < minDistance && distance < 200) { // Within 200 pixels\n                minDistance = distance;\n                nearestAsteroid = asteroid;\n            }\n        }\n        if (nearestAsteroid) {\n            // Deploy turret at asteroid position\n            const turret = new DeployedTurret(new Vector2D(nearestAsteroid.position.x, nearestAsteroid.position.y), deployer.owner, nearestAsteroid);\n            this.deployedTurrets.push(turret);\n        }\n    }\n    /**\n     * Process Driller collisions\n     */\n    processDrillerCollisions(driller, deltaTime) {\n        // Check collision with suns (dies)\n        for (const sun of this.suns) {\n            const distance = driller.position.distanceTo(sun.position);\n            if (distance < sun.radius + 10) {\n                driller.health = 0; // Dies\n                driller.stopDrilling();\n                return;\n            }\n        }\n        // Check collision with asteroids (burrows)\n        for (const asteroid of this.asteroids) {\n            if (asteroid.containsPoint(driller.position)) {\n                driller.hideInAsteroid(asteroid);\n                driller.stopDrilling();\n                return;\n            }\n        }\n        // Check collision with enemy units\n        for (const player of this.players) {\n            if (player === driller.owner)\n                continue;\n            for (const unit of player.units) {\n                const distance = driller.position.distanceTo(unit.position);\n                if (distance < 15) {\n                    unit.takeDamage(_constants__WEBPACK_IMPORTED_MODULE_0__.DRILLER_DRILL_DAMAGE);\n                    // Create damage number\n                    const unitKey = `unit_${unit.position.x}_${unit.position.y}_${unit.owner.name}`;\n                    this.addDamageNumber(unit.position, _constants__WEBPACK_IMPORTED_MODULE_0__.DRILLER_DRILL_DAMAGE, unit.maxHealth, unit.health, unitKey);\n                }\n            }\n            // Check collision with buildings (double damage, pass through)\n            for (const building of player.buildings) {\n                const distance = driller.position.distanceTo(building.position);\n                if (distance < 40) {\n                    const damage = _constants__WEBPACK_IMPORTED_MODULE_0__.DRILLER_DRILL_DAMAGE * _constants__WEBPACK_IMPORTED_MODULE_0__.DRILLER_BUILDING_DAMAGE_MULTIPLIER;\n                    building.takeDamage(damage);\n                    // Create damage number\n                    const buildingKey = `building_${building.position.x}_${building.position.y}_${player.name}`;\n                    this.addDamageNumber(building.position, damage, building.maxHealth, building.health, buildingKey);\n                    // Continue drilling through building\n                }\n            }\n            // Check collision with forge\n            if (player.stellarForge) {\n                const distance = driller.position.distanceTo(player.stellarForge.position);\n                if (distance < player.stellarForge.radius + 10) {\n                    const damage = _constants__WEBPACK_IMPORTED_MODULE_0__.DRILLER_DRILL_DAMAGE * _constants__WEBPACK_IMPORTED_MODULE_0__.DRILLER_BUILDING_DAMAGE_MULTIPLIER;\n                    player.stellarForge.health -= damage;\n                    // Create damage number\n                    const forgeKey = `forge_${player.stellarForge.position.x}_${player.stellarForge.position.y}_${player.name}`;\n                    this.addDamageNumber(player.stellarForge.position, damage, _constants__WEBPACK_IMPORTED_MODULE_0__.STELLAR_FORGE_MAX_HEALTH, player.stellarForge.health, forgeKey);\n                    // Continue drilling through\n                }\n            }\n        }\n        // Check collision with map edges (decelerate and stop)\n        const mapSize = this.mapSize;\n        if (driller.position.x < 0 || driller.position.x > mapSize ||\n            driller.position.y < 0 || driller.position.y > mapSize) {\n            // Apply deceleration\n            const speed = Math.sqrt(Math.pow(driller.drillVelocity.x, 2) + Math.pow(driller.drillVelocity.y, 2));\n            if (speed > 0) {\n                const decelAmount = _constants__WEBPACK_IMPORTED_MODULE_0__.DRILLER_DECELERATION * deltaTime;\n                const newSpeed = Math.max(0, speed - decelAmount);\n                if (newSpeed === 0) {\n                    driller.stopDrilling();\n                }\n                else {\n                    driller.drillVelocity.x = (driller.drillVelocity.x / speed) * newSpeed;\n                    driller.drillVelocity.y = (driller.drillVelocity.y / speed) * newSpeed;\n                }\n            }\n            // Keep within bounds\n            driller.position.x = Math.max(0, Math.min(mapSize, driller.position.x));\n            driller.position.y = Math.max(0, Math.min(mapSize, driller.position.y));\n        }\n    }\n    resolveUnitCollisions(allUnits) {\n        for (let i = 0; i < allUnits.length; i++) {\n            const unitA = allUnits[i];\n            if (unitA.isDead()) {\n                continue;\n            }\n            for (let j = i + 1; j < allUnits.length; j++) {\n                const unitB = allUnits[j];\n                if (unitB.isDead()) {\n                    continue;\n                }\n                let deltaX = unitB.position.x - unitA.position.x;\n                let deltaY = unitB.position.y - unitA.position.y;\n                let distanceSq = deltaX * deltaX + deltaY * deltaY;\n                if (distanceSq === 0) {\n                    deltaX = i % 2 === 0 ? 1 : -1;\n                    deltaY = 0;\n                    distanceSq = 1;\n                }\n                const minDistance = unitA.collisionRadiusPx + unitB.collisionRadiusPx;\n                const minDistanceSq = minDistance * minDistance;\n                if (distanceSq < minDistanceSq) {\n                    const distance = Math.sqrt(distanceSq);\n                    const overlap = minDistance - distance;\n                    const pushX = (deltaX / distance) * overlap;\n                    const pushY = (deltaY / distance) * overlap;\n                    if (unitA.isHero && !unitB.isHero) {\n                        unitB.position.x += pushX;\n                        unitB.position.y += pushY;\n                    }\n                    else if (!unitA.isHero && unitB.isHero) {\n                        unitA.position.x -= pushX;\n                        unitA.position.y -= pushY;\n                    }\n                    else {\n                        unitA.position.x -= pushX * 0.5;\n                        unitA.position.y -= pushY * 0.5;\n                        unitB.position.x += pushX * 0.5;\n                        unitB.position.y += pushY * 0.5;\n                    }\n                }\n            }\n        }\n    }\n    resolveUnitObstacleCollisions(allUnits) {\n        for (const unit of allUnits) {\n            if (unit.isDead()) {\n                continue;\n            }\n            const oldPosition = new Vector2D(unit.position.x, unit.position.y);\n            if (this.checkCollision(unit.position, unit.collisionRadiusPx)) {\n                // Smooth collision: Find the nearest obstacle and push away from it gently\n                let pushX = 0;\n                let pushY = 0;\n                let pushCount = 0;\n                // Check all obstacles and accumulate push directions\n                // Suns no longer block movement\n                // Check asteroids\n                for (const asteroid of this.asteroids) {\n                    const dx = unit.position.x - asteroid.position.x;\n                    const dy = unit.position.y - asteroid.position.y;\n                    const distSq = dx * dx + dy * dy;\n                    const minDist = asteroid.size + unit.collisionRadiusPx + _constants__WEBPACK_IMPORTED_MODULE_0__.UNIT_ASTEROID_AVOIDANCE_BUFFER_PX;\n                    const minDistSq = minDist * minDist;\n                    if (distSq < minDistSq || asteroid.containsPoint(unit.position)) {\n                        const dist = Math.sqrt(distSq) || 1;\n                        const pushStrength = (minDist - dist) / minDist;\n                        pushX += (dx / dist) * pushStrength;\n                        pushY += (dy / dist) * pushStrength;\n                        pushCount++;\n                    }\n                }\n                // Check stellar forges\n                for (const player of this.players) {\n                    if (player.stellarForge) {\n                        const forge = player.stellarForge;\n                        const dx = unit.position.x - forge.position.x;\n                        const dy = unit.position.y - forge.position.y;\n                        const dist = Math.sqrt(dx * dx + dy * dy);\n                        const minDist = forge.radius + unit.collisionRadiusPx;\n                        if (dist < minDist) {\n                            const pushStrength = (minDist - dist) / minDist;\n                            pushX += (dx / dist) * pushStrength;\n                            pushY += (dy / dist) * pushStrength;\n                            pushCount++;\n                        }\n                    }\n                }\n                // Check solar mirrors\n                for (const player of this.players) {\n                    for (const mirror of player.solarMirrors) {\n                        if (mirror.owner === unit.owner)\n                            continue;\n                        const dx = unit.position.x - mirror.position.x;\n                        const dy = unit.position.y - mirror.position.y;\n                        const dist = Math.sqrt(dx * dx + dy * dy);\n                        const minDist = 20 + unit.collisionRadiusPx;\n                        if (dist < minDist) {\n                            const pushStrength = (minDist - dist) / minDist;\n                            pushX += (dx / dist) * pushStrength;\n                            pushY += (dy / dist) * pushStrength;\n                            pushCount++;\n                        }\n                    }\n                }\n                // Check buildings\n                for (const player of this.players) {\n                    for (const building of player.buildings) {\n                        const dx = unit.position.x - building.position.x;\n                        const dy = unit.position.y - building.position.y;\n                        const dist = Math.sqrt(dx * dx + dy * dy);\n                        const minDist = building.radius + unit.collisionRadiusPx;\n                        if (dist < minDist) {\n                            const pushStrength = (minDist - dist) / minDist;\n                            pushX += (dx / dist) * pushStrength;\n                            pushY += (dy / dist) * pushStrength;\n                            pushCount++;\n                        }\n                    }\n                }\n                // Apply smooth push away from obstacles\n                if (pushCount > 0) {\n                    const pushLength = Math.sqrt(pushX * pushX + pushY * pushY);\n                    if (pushLength > 0) {\n                        // Normalize and apply gentle push\n                        const pushDistance = Math.min(this.MAX_PUSH_DISTANCE, pushLength * this.PUSH_MULTIPLIER);\n                        unit.position.x = oldPosition.x + (pushX / pushLength) * pushDistance;\n                        unit.position.y = oldPosition.y + (pushY / pushLength) * pushDistance;\n                    }\n                }\n                // If still in collision after push, stop the unit\n                if (this.checkCollision(unit.position, unit.collisionRadiusPx)) {\n                    unit.position = oldPosition;\n                    if (unit.rallyPoint && this.checkCollision(unit.rallyPoint, unit.collisionRadiusPx)) {\n                        unit.rallyPoint = null;\n                    }\n                }\n            }\n            this.clampUnitOutsideStructures(unit);\n        }\n    }\n    clampUnitOutsideStructures(unit) {\n        for (const player of this.players) {\n            if (player.stellarForge) {\n                this.pushUnitOutsideCircle(unit, player.stellarForge.position, player.stellarForge.radius);\n            }\n            for (const building of player.buildings) {\n                this.pushUnitOutsideCircle(unit, building.position, building.radius);\n            }\n        }\n    }\n    pushUnitOutsideCircle(unit, center, radius) {\n        const minDistance = radius + unit.collisionRadiusPx + _constants__WEBPACK_IMPORTED_MODULE_0__.UNIT_STRUCTURE_STANDOFF_PX;\n        const offsetX = unit.position.x - center.x;\n        const offsetY = unit.position.y - center.y;\n        const distanceSq = offsetX * offsetX + offsetY * offsetY;\n        const minDistanceSq = minDistance * minDistance;\n        if (distanceSq < minDistanceSq) {\n            const distance = Math.sqrt(distanceSq);\n            if (distance > 0) {\n                const scale = minDistance / distance;\n                unit.position.x = center.x + offsetX * scale;\n                unit.position.y = center.y + offsetY * scale;\n            }\n            else {\n                unit.position.x = center.x + minDistance;\n                unit.position.y = center.y;\n            }\n        }\n    }\n    /**\n     * Check if a position would collide with any obstacle (sun, asteroid, or building)\n     * Returns true if collision detected\n     */\n    createHeroUnit(unitType, spawnPosition, owner) {\n        switch (unitType) {\n            case 'Marine':\n                return new Marine(spawnPosition, owner);\n            case 'Grave':\n                return new Grave(spawnPosition, owner);\n            case 'Ray':\n                return new Ray(spawnPosition, owner);\n            case 'InfluenceBall':\n                return new InfluenceBall(spawnPosition, owner);\n            case 'TurretDeployer':\n                return new TurretDeployer(spawnPosition, owner);\n            case 'Driller':\n                return new Driller(spawnPosition, owner);\n            case 'Dagger':\n                return new Dagger(spawnPosition, owner);\n            case 'Beam':\n                return new Beam(spawnPosition, owner);\n            case 'Mortar':\n                return new Mortar(spawnPosition, owner);\n            case 'Preist':\n                return new Preist(spawnPosition, owner);\n            case 'Tank':\n                return new Tank(spawnPosition, owner);\n            default:\n                return null;\n        }\n    }\n    checkCollision(position, unitRadius = _constants__WEBPACK_IMPORTED_MODULE_0__.UNIT_RADIUS_PX, ignoredObject = null) {\n        // Suns no longer block movement or placement\n        // Check collision with asteroids\n        for (const asteroid of this.asteroids) {\n            if (asteroid.containsPoint(position)) {\n                return true; // Inside asteroid\n            }\n        }\n        // Check collision with all players' buildings\n        for (const player of this.players) {\n            // Check collision with stellar forge\n            if (player.stellarForge) {\n                if (player.stellarForge === ignoredObject) {\n                    continue;\n                }\n                const distance = position.distanceTo(player.stellarForge.position);\n                if (distance < player.stellarForge.radius + unitRadius) {\n                    return true; // Collision with forge\n                }\n            }\n            // Check collision with solar mirrors (using approximate radius)\n            for (const mirror of player.solarMirrors) {\n                if (mirror === ignoredObject) {\n                    continue;\n                }\n                const distance = position.distanceTo(mirror.position);\n                if (distance < 20 + unitRadius) { // Mirror has ~20 pixel radius\n                    return true; // Collision with mirror\n                }\n            }\n            // Check collision with buildings\n            for (const building of player.buildings) {\n                if (building === ignoredObject) {\n                    continue;\n                }\n                const distance = position.distanceTo(building.position);\n                if (distance < building.radius + unitRadius) {\n                    return true; // Collision with building\n                }\n            }\n        }\n        return false; // No collision\n    }\n    updateStateHash() {\n        var _a;\n        let hash = 2166136261;\n        const mix = (value) => {\n            const normalizedValue = Math.floor(value * 100);\n            hash = Math.imul(hash ^ normalizedValue, 16777619);\n        };\n        const mixInt = (value) => {\n            hash = Math.imul(hash ^ value, 16777619);\n        };\n        const mixString = (value) => {\n            mixInt(value.length);\n            for (let i = 0; i < value.length; i++) {\n                mixInt(value.charCodeAt(i));\n            }\n        };\n        mix(this.gameTime);\n        mix(this.suns.length);\n        mix(this.asteroids.length);\n        mixInt(this.spaceDust.length);\n        for (const particle of this.spaceDust) {\n            mix(particle.position.x);\n            mix(particle.position.y);\n            mix(particle.velocity.x);\n            mix(particle.velocity.y);\n            mix(particle.glowTransition);\n            mixInt(particle.glowState);\n            mixInt(particle.targetGlowState);\n            mixString(particle.baseColor);\n        }\n        for (const player of this.players) {\n            mix(player.energy);\n            mixInt(player.isAi ? 1 : 0);\n            mix(player.aiNextMirrorCommandSec);\n            mix(player.aiNextDefenseCommandSec);\n            mix(player.aiNextHeroCommandSec);\n            mix(player.aiNextStructureCommandSec);\n            mix(player.aiNextMirrorPurchaseCommandSec);\n            mixString(player.aiStrategy);\n            if (player.stellarForge) {\n                mix(player.stellarForge.position.x);\n                mix(player.stellarForge.position.y);\n                mix(player.stellarForge.health);\n                mixInt(player.stellarForge.unitQueue.length);\n                for (const unitType of player.stellarForge.unitQueue) {\n                    mixString(unitType);\n                }\n                mixString((_a = player.stellarForge.heroProductionUnitType) !== null && _a !== void 0 ? _a : '');\n                mix(player.stellarForge.heroProductionRemainingSec);\n                mix(player.stellarForge.heroProductionDurationSec);\n                mix(player.stellarForge.crunchTimer);\n                mix(player.stellarForge.rotation);\n                if (player.stellarForge.targetPosition) {\n                    mix(player.stellarForge.targetPosition.x);\n                    mix(player.stellarForge.targetPosition.y);\n                }\n                else {\n                    mix(-1);\n                    mix(-1);\n                }\n                mix(player.stellarForge.velocity.x);\n                mix(player.stellarForge.velocity.y);\n            }\n            else {\n                mix(-1);\n            }\n            for (const mirror of player.solarMirrors) {\n                mix(mirror.position.x);\n                mix(mirror.position.y);\n                mix(mirror.health);\n                mix(mirror.efficiency);\n                mix(mirror.reflectionAngle);\n                if (mirror.targetPosition) {\n                    mix(mirror.targetPosition.x);\n                    mix(mirror.targetPosition.y);\n                }\n                else {\n                    mix(-1);\n                    mix(-1);\n                }\n                mix(mirror.velocity.x);\n                mix(mirror.velocity.y);\n            }\n            for (const unit of player.units) {\n                mix(unit.position.x);\n                mix(unit.position.y);\n                mix(unit.velocity.x);\n                mix(unit.velocity.y);\n                mix(unit.rotation);\n                mix(unit.health);\n                mix(unit.isHero ? 1 : 0);\n                mix(unit.collisionRadiusPx);\n                mixInt(unit.moveOrder);\n                if (unit.rallyPoint) {\n                    mix(unit.rallyPoint.x);\n                    mix(unit.rallyPoint.y);\n                }\n                else {\n                    mix(-1);\n                    mix(-1);\n                }\n                if (unit instanceof Starling) {\n                    mixInt(unit.getAssignedPathLength());\n                    mixInt(unit.getCurrentPathWaypointIndex());\n                    mixInt(unit.hasActiveManualOrder() ? 1 : 0);\n                }\n            }\n            for (const building of player.buildings) {\n                mix(building.position.x);\n                mix(building.position.y);\n                mix(building.health);\n                mix(building.isComplete ? 1 : 0);\n            }\n        }\n        mixInt(this.minionProjectiles.length);\n        for (const projectile of this.minionProjectiles) {\n            mix(projectile.position.x);\n            mix(projectile.position.y);\n            mix(projectile.velocity.x);\n            mix(projectile.velocity.y);\n            mix(projectile.damage);\n            mix(projectile.distanceTraveledPx);\n            mix(projectile.maxRangePx);\n            mixInt(this.players.indexOf(projectile.owner));\n        }\n        this.stateHash = hash >>> 0;\n    }\n    /**\n     * Initialize space dust particles\n     */\n    initializeSpaceDust(count, width, height, palette) {\n        this.spaceDust = [];\n        for (let i = 0; i < count; i++) {\n            const x = (Math.random() - 0.5) * width;\n            const y = (Math.random() - 0.5) * height;\n            this.spaceDust.push(new SpaceDustParticle(new Vector2D(x, y), undefined, palette));\n        }\n    }\n    /**\n     * Initialize asteroids at random positions\n     */\n    initializeAsteroids(count, width, height) {\n        this.asteroids = [];\n        const maxAttempts = 50; // Maximum attempts to find a valid position\n        for (let i = 0; i < count; i++) {\n            let validPosition = false;\n            let attempts = 0;\n            let x = 0, y = 0, size = 0;\n            while (!validPosition && attempts < maxAttempts) {\n                // Random position avoiding the center (where players start)\n                const angle = Math.random() * Math.PI * 2;\n                const distance = 200 + Math.random() * (Math.min(width, height) / 2 - 300);\n                x = Math.cos(angle) * distance;\n                y = Math.sin(angle) * distance;\n                // Random size (30-80)\n                size = _constants__WEBPACK_IMPORTED_MODULE_0__.ASTEROID_MIN_SIZE + Math.random() * (80 - _constants__WEBPACK_IMPORTED_MODULE_0__.ASTEROID_MIN_SIZE);\n                // Check if this position has enough gap from existing asteroids\n                // Gap must be at least the sum of both asteroid radii\n                validPosition = true;\n                for (const asteroid of this.asteroids) {\n                    const dx = x - asteroid.position.x;\n                    const dy = y - asteroid.position.y;\n                    const dist = Math.sqrt(dx * dx + dy * dy);\n                    const requiredGap = size + asteroid.size;\n                    if (dist < requiredGap) {\n                        validPosition = false;\n                        break;\n                    }\n                }\n                attempts++;\n            }\n            // If we found a valid position, add the asteroid\n            if (validPosition) {\n                // Random polygon sides (3-9)\n                const sides = 3 + Math.floor(Math.random() * 7);\n                this.asteroids.push(new Asteroid(new Vector2D(x, y), sides, size));\n            }\n        }\n    }\n    /**\n     * Check if any player has won\n     */\n    checkVictoryConditions() {\n        const activePlayers = this.players.filter(p => !p.isDefeated());\n        if (activePlayers.length === 1) {\n            return activePlayers[0];\n        }\n        return null;\n    }\n    /**\n     * Initialize a player with starting structures\n     */\n    initializePlayer(player, forgePosition, mirrorPositions) {\n        // Create Stellar Forge\n        player.stellarForge = new StellarForge(forgePosition, player);\n        // Create starting Solar Mirrors\n        for (const pos of mirrorPositions) {\n            const mirror = new SolarMirror(pos, player);\n            player.solarMirrors.push(mirror);\n        }\n    }\n    /**\n     * Add a damage number with proper handling for display mode\n     */\n    addDamageNumber(position, damage, maxHealth, currentHealth, unitKey = null) {\n        const remainingHealth = Math.max(0, currentHealth);\n        // If in remaining-life mode and unitKey is provided, remove previous damage numbers for this unit\n        if (this.damageDisplayMode === 'remaining-life' && unitKey !== null) {\n            this.damageNumbers = this.damageNumbers.filter(dn => dn.unitId !== unitKey);\n        }\n        this.damageNumbers.push(new DamageNumber(position, damage, this.gameTime, maxHealth, remainingHealth, unitKey));\n    }\n    /**\n     * Set up network manager and register event handlers\n     */\n    setupNetworkManager(networkManager, localPlayerIndex) {\n        this.networkManager = networkManager;\n        this.localPlayerIndex = localPlayerIndex;\n        // Listen for incoming game commands from remote players\n        this.networkManager.on(_network__WEBPACK_IMPORTED_MODULE_1__.NetworkEvent.MESSAGE_RECEIVED, (data) => {\n            if (data && typeof data === 'object' && 'type' in data && data.type === _network__WEBPACK_IMPORTED_MODULE_1__.MessageType.GAME_COMMAND) {\n                const command = data.data;\n                this.receiveNetworkCommand(command);\n            }\n        });\n    }\n    /**\n     * Send a game command to all connected peers\n     */\n    sendGameCommand(command, data) {\n        if (!this.networkManager)\n            return;\n        const gameCommand = {\n            tick: Math.floor(this.gameTime * 60), // Convert time to tick number (60 ticks per second)\n            playerId: this.networkManager.getLocalPlayerId(),\n            command: command,\n            data: data\n        };\n        this.networkManager.sendGameCommand(gameCommand);\n    }\n    /**\n     * Receive and queue a game command from the network\n     */\n    receiveNetworkCommand(command) {\n        // Add to pending commands queue to be processed in next update\n        this.pendingCommands.push(command);\n    }\n    /**\n     * Process all pending network commands\n     */\n    processPendingNetworkCommands() {\n        if (this.pendingCommands.length === 0)\n            return;\n        // Sort commands by tick to ensure consistent execution order\n        this.pendingCommands.sort((a, b) => a.tick - b.tick);\n        // Process all pending commands\n        for (const cmd of this.pendingCommands) {\n            this.executeNetworkCommand(cmd);\n        }\n        // Clear the processed commands\n        this.pendingCommands = [];\n    }\n    /**\n     * Execute a network command\n     */\n    executeNetworkCommand(cmd) {\n        // Determine which player this command is for\n        // Remote player is always the opposite of local player\n        const remotePlayerIndex = this.localPlayerIndex === 0 ? 1 : 0;\n        const player = this.players[remotePlayerIndex];\n        if (!player)\n            return;\n        switch (cmd.command) {\n            case 'unit_move':\n                this.executeUnitMoveCommand(player, cmd.data);\n                break;\n            case 'unit_ability':\n                this.executeUnitAbilityCommand(player, cmd.data);\n                break;\n            case 'hero_purchase':\n                this.executeHeroPurchaseCommand(player, cmd.data);\n                break;\n            case 'building_purchase':\n                this.executeBuildingPurchaseCommand(player, cmd.data);\n                break;\n            case 'mirror_purchase':\n                this.executeMirrorPurchaseCommand(player, cmd.data);\n                break;\n            case 'forge_move':\n                this.executeForgeMoveCommand(player, cmd.data);\n                break;\n            case 'set_rally_path':\n                this.executeSetRallyPathCommand(player, cmd.data);\n                break;\n            default:\n                console.warn('Unknown network command:', cmd.command);\n        }\n    }\n    executeUnitMoveCommand(player, data) {\n        const { unitIds, targetX, targetY } = data;\n        const target = new Vector2D(targetX, targetY);\n        for (const unitId of unitIds) {\n            const unit = player.units.find(u => this.getUnitId(u) === unitId);\n            if (unit) {\n                unit.rallyPoint = target;\n            }\n            else {\n                console.warn(`Unit not found for network command: ${unitId}`);\n            }\n        }\n    }\n    executeUnitAbilityCommand(player, data) {\n        const { unitId, directionX, directionY } = data;\n        const direction = new Vector2D(directionX, directionY);\n        const unit = player.units.find(u => this.getUnitId(u) === unitId);\n        if (unit) {\n            unit.useAbility(direction);\n        }\n        else {\n            console.warn(`Unit not found for ability command: ${unitId}`);\n        }\n    }\n    executeHeroPurchaseCommand(player, data) {\n        const { heroType } = data;\n        if (player.stellarForge) {\n            player.stellarForge.enqueueHeroUnit(heroType);\n            player.stellarForge.startHeroProductionIfIdle();\n        }\n    }\n    executeBuildingPurchaseCommand(player, data) {\n        const { buildingType, positionX, positionY } = data;\n        const position = new Vector2D(positionX, positionY);\n        // Check if player can afford the building\n        let cost = 0;\n        if (buildingType === 'Minigun' || buildingType === 'Cannon') {\n            cost = _constants__WEBPACK_IMPORTED_MODULE_0__.MINIGUN_COST;\n        }\n        else if (buildingType === 'SpaceDustSwirler') {\n            cost = _constants__WEBPACK_IMPORTED_MODULE_0__.SWIRLER_COST;\n        }\n        else if (buildingType === 'SubsidiaryFactory' || buildingType === 'Foundry') {\n            cost = _constants__WEBPACK_IMPORTED_MODULE_0__.SUBSIDIARY_FACTORY_COST;\n        }\n        if (player.spendEnergy(cost)) {\n            // Create the building\n            if (buildingType === 'Minigun' || buildingType === 'Cannon') {\n                player.buildings.push(new Minigun(position, player));\n            }\n            else if (buildingType === 'SpaceDustSwirler') {\n                player.buildings.push(new SpaceDustSwirler(position, player));\n            }\n            else if (buildingType === 'SubsidiaryFactory' || buildingType === 'Foundry') {\n                player.buildings.push(new SubsidiaryFactory(position, player));\n            }\n        }\n    }\n    executeMirrorPurchaseCommand(player, data) {\n        const { positionX, positionY } = data;\n        const position = new Vector2D(positionX, positionY);\n        if (player.spendEnergy(_constants__WEBPACK_IMPORTED_MODULE_0__.SOLAR_MIRROR_COST)) {\n            player.solarMirrors.push(new SolarMirror(position, player));\n        }\n    }\n    executeForgeMoveCommand(player, data) {\n        const { targetX, targetY } = data;\n        const target = new Vector2D(targetX, targetY);\n        if (player.stellarForge) {\n            player.stellarForge.targetPosition = target;\n        }\n    }\n    executeSetRallyPathCommand(player, data) {\n        const { waypoints } = data;\n        const path = waypoints.map((wp) => new Vector2D(wp.x, wp.y));\n        if (player.stellarForge) {\n            player.stellarForge.setMinionPath(path);\n        }\n    }\n    /**\n     * Generate a unique ID for a unit (for network synchronization)\n     * Note: This is a temporary solution. In production, units should have explicit unique IDs.\n     */\n    getUnitId(unit) {\n        // Use a combination of owner, position, health, and type for uniqueness\n        // This is not perfect but works for most cases in the current implementation\n        const ownerIndex = this.players.indexOf(unit.owner);\n        return `${ownerIndex}_${unit.position.x.toFixed(1)}_${unit.position.y.toFixed(1)}_${unit.maxHealth}_${unit.constructor.name}`;\n    }\n}\n/**\n * Create a standard game setup\n */\nfunction createStandardGame(playerNames, spaceDustPalette) {\n    const game = new GameState();\n    // Add sun at center\n    game.suns.push(new Sun(new Vector2D(0, 0), 1.0, 100.0));\n    // Create players with starting positions in bottom-left and top-right\n    // Randomly assign which player gets which position\n    const bottomLeft = new Vector2D(-700, 700);\n    const topRight = new Vector2D(700, -700);\n    // Randomly decide player assignment\n    const randomizePositions = Math.random() < 0.5;\n    const positions = randomizePositions\n        ? [bottomLeft, topRight]\n        : [topRight, bottomLeft];\n    for (let i = 0; i < playerNames.length; i++) {\n        if (i >= positions.length) {\n            break;\n        }\n        const [name, faction] = playerNames[i];\n        const player = new Player(name, faction);\n        player.isAi = i !== 0;\n        // Assign random AI strategy for AI players\n        if (player.isAi) {\n            const strategies = [\n                _constants__WEBPACK_IMPORTED_MODULE_0__.AIStrategy.ECONOMIC,\n                _constants__WEBPACK_IMPORTED_MODULE_0__.AIStrategy.DEFENSIVE,\n                _constants__WEBPACK_IMPORTED_MODULE_0__.AIStrategy.AGGRESSIVE,\n                _constants__WEBPACK_IMPORTED_MODULE_0__.AIStrategy.WAVES\n            ];\n            player.aiStrategy = strategies[Math.floor(Math.random() * strategies.length)];\n        }\n        const forgePos = positions[i];\n        const mirrorSpawnDistance = _constants__WEBPACK_IMPORTED_MODULE_0__.MIRROR_COUNTDOWN_DEPLOY_DISTANCE;\n        const mirrorPositions = [\n            new Vector2D(forgePos.x - mirrorSpawnDistance, forgePos.y),\n            new Vector2D(forgePos.x + mirrorSpawnDistance, forgePos.y)\n        ];\n        game.initializePlayer(player, forgePos, mirrorPositions);\n        // Hero units (Marine and Grave) are no longer spawned automatically\n        // They must be obtained through other game mechanics\n        game.players.push(player);\n    }\n    // Initialize default minion paths (each forge targets the enemy's spawn location)\n    if (game.players.length >= 2) {\n        for (let i = 0; i < game.players.length; i++) {\n            const player = game.players[i];\n            const enemyIndex = (i + 1) % game.players.length;\n            const enemyPlayer = game.players[enemyIndex];\n            if (player.stellarForge && enemyPlayer.stellarForge) {\n                player.stellarForge.initializeDefaultPath(enemyPlayer.stellarForge.position);\n            }\n        }\n    }\n    // Initialize space dust particles\n    game.initializeSpaceDust(_constants__WEBPACK_IMPORTED_MODULE_0__.SPACE_DUST_PARTICLE_COUNT, 2000, 2000, spaceDustPalette);\n    // Initialize random asteroids\n    game.initializeAsteroids(10, 2000, 2000);\n    // Add two large strategic asteroids that cast shadows on the bases\n    // Position them close to the sun to cast shadows toward bottom-left and top-right\n    // Bottom-left shadow: asteroid positioned at top-right of sun (angle ~-45 degrees or 315 degrees)\n    const bottomLeftShadowAngle = -Math.PI / 4; // -45 degrees (top-right quadrant)\n    const bottomLeftAsteroidPos = new Vector2D(Math.cos(bottomLeftShadowAngle) * _constants__WEBPACK_IMPORTED_MODULE_0__.STRATEGIC_ASTEROID_DISTANCE, Math.sin(bottomLeftShadowAngle) * _constants__WEBPACK_IMPORTED_MODULE_0__.STRATEGIC_ASTEROID_DISTANCE);\n    game.asteroids.push(new Asteroid(bottomLeftAsteroidPos, 6, _constants__WEBPACK_IMPORTED_MODULE_0__.STRATEGIC_ASTEROID_SIZE));\n    // Top-right shadow: asteroid positioned at bottom-left of sun (angle ~135 degrees)\n    const topRightShadowAngle = (3 * Math.PI) / 4; // 135 degrees (bottom-left quadrant)\n    const topRightAsteroidPos = new Vector2D(Math.cos(topRightShadowAngle) * _constants__WEBPACK_IMPORTED_MODULE_0__.STRATEGIC_ASTEROID_DISTANCE, Math.sin(topRightShadowAngle) * _constants__WEBPACK_IMPORTED_MODULE_0__.STRATEGIC_ASTEROID_DISTANCE);\n    game.asteroids.push(new Asteroid(topRightAsteroidPos, 6, _constants__WEBPACK_IMPORTED_MODULE_0__.STRATEGIC_ASTEROID_SIZE));\n    game.isRunning = true;\n    return game;\n}\n\n\n//# sourceURL=webpack://sol/./src/game-core.ts?\n}");

/***/ },

/***/ "./src/heroes/beam.ts"
/*!****************************!*\
  !*** ./src/heroes/beam.ts ***!
  \****************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createBeamHero: () => (/* binding */ createBeamHero)\n/* harmony export */ });\nconst createBeamHero = (deps) => {\n    const { Unit, Vector2D, Constants, AbilityBullet } = deps;\n    /**\n     * Beam hero unit (Radiant faction) - sniper with distance-based damage\n     * Fires a thin beam that does more damage the further away the target is\n     */\n    class Beam extends Unit {\n        constructor(position, owner) {\n            super(position, owner, Constants.BEAM_MAX_HEALTH, Constants.BEAM_ATTACK_RANGE, Constants.BEAM_ATTACK_DAMAGE, Constants.BEAM_ATTACK_SPEED, Constants.BEAM_ABILITY_COOLDOWN);\n            this.lastBeamDamage = 0; // For displaying multiplier\n            this.lastBeamDistance = 0; // For calculating multiplier\n            this.lastBeamMultiplier = 0; // For display above unit\n            this.lastBeamTime = 0; // When the last beam was fired\n            this.isHero = true; // Beam is a hero unit for Radiant faction\n        }\n        /**\n         * Use Beam's ability: long-range sniper beam with distance-based damage\n         * Deals more damage the further away the target is\n         */\n        useAbility(direction) {\n            if (!super.useAbility(direction)) {\n                return false;\n            }\n            // Calculate beam direction\n            const beamDir = direction.normalize();\n            // Create a thin beam projectile that travels in a straight line\n            const speed = 1000; // Very fast beam speed\n            const velocity = new Vector2D(beamDir.x * speed, beamDir.y * speed);\n            // Create ability bullet for the beam\n            const bullet = new AbilityBullet(new Vector2D(this.position.x, this.position.y), velocity, this.owner, Constants.BEAM_ABILITY_BASE_DAMAGE // Base damage, will be modified on hit\n            );\n            // Set long range for the sniper beam\n            bullet.maxRange = Constants.BEAM_ABILITY_MAX_RANGE;\n            // Mark this as a beam projectile for special damage calculation\n            bullet.isBeamProjectile = true;\n            bullet.beamOwner = this;\n            this.lastAbilityEffects.push(bullet);\n            return true;\n        }\n    }\n    return { Beam };\n};\n\n\n//# sourceURL=webpack://sol/./src/heroes/beam.ts?\n}");

/***/ },

/***/ "./src/heroes/dagger.ts"
/*!******************************!*\
  !*** ./src/heroes/dagger.ts ***!
  \******************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createDaggerHero: () => (/* binding */ createDaggerHero)\n/* harmony export */ });\nconst createDaggerHero = (deps) => {\n    const { Unit, Vector2D, Constants, AbilityBullet } = deps;\n    /**\n     * Dagger hero unit (Radiant faction) - cloaked assassin\n     * Always cloaked and invisible to enemies. Cannot see enemies until ability is used.\n     * Becomes visible for 8 seconds after using ability.\n     */\n    class Dagger extends Unit {\n        constructor(position, owner) {\n            super(position, owner, Constants.DAGGER_MAX_HEALTH, Constants.DAGGER_ATTACK_RANGE, Constants.DAGGER_ATTACK_DAMAGE, Constants.DAGGER_ATTACK_SPEED, Constants.DAGGER_ABILITY_COOLDOWN);\n            this.isCloaked = true; // Always cloaked unless ability was recently used\n            this.visibilityTimer = 0; // Time remaining while visible after ability use\n            this.canSeeEnemies = false; // Can only see enemies after using ability\n            this.enemyVisionTimer = 0; // Time remaining with enemy vision\n            this.isHero = true; // Dagger is a hero unit for Radiant faction\n        }\n        /**\n         * Update visibility and enemy vision timers\n         */\n        updateTimers(deltaTime) {\n            // Update visibility timer (visible to enemies after ability use)\n            if (this.visibilityTimer > 0) {\n                this.visibilityTimer -= deltaTime;\n                if (this.visibilityTimer <= 0) {\n                    this.visibilityTimer = 0;\n                    this.isCloaked = true; // Return to cloaked state\n                }\n            }\n            // Update enemy vision timer (can see enemies after ability use)\n            if (this.enemyVisionTimer > 0) {\n                this.enemyVisionTimer -= deltaTime;\n                if (this.enemyVisionTimer <= 0) {\n                    this.enemyVisionTimer = 0;\n                    this.canSeeEnemies = false; // Lose ability to see enemies\n                }\n            }\n        }\n        /**\n         * Use Dagger's ability: short-range directional attack\n         * Deals damage in a cone and reveals the Dagger for 8 seconds\n         */\n        useAbility(direction) {\n            if (!super.useAbility(direction)) {\n                return false;\n            }\n            // Reveal Dagger for 8 seconds\n            this.isCloaked = false;\n            this.visibilityTimer = Constants.DAGGER_VISIBILITY_DURATION;\n            // Grant enemy vision for 8 seconds\n            this.canSeeEnemies = true;\n            this.enemyVisionTimer = Constants.DAGGER_VISIBILITY_DURATION;\n            // Calculate attack direction\n            const attackDir = direction.normalize();\n            const attackAngle = Math.atan2(attackDir.y, attackDir.x);\n            // Create a short-range directional attack projectile\n            const speed = 400; // Fast projectile speed\n            const velocity = new Vector2D(Math.cos(attackAngle) * speed, Math.sin(attackAngle) * speed);\n            // Create ability bullet\n            const bullet = new AbilityBullet(new Vector2D(this.position.x, this.position.y), velocity, this.owner, Constants.DAGGER_ABILITY_DAMAGE);\n            // Set short range for the projectile\n            bullet.maxRange = Constants.DAGGER_ABILITY_RANGE;\n            this.lastAbilityEffects.push(bullet);\n            return true;\n        }\n        /**\n         * Override update to filter enemies based on vision\n         */\n        update(deltaTime, enemies, allUnits, asteroids = []) {\n            // Filter enemies - Dagger can only see enemies if it has enemy vision\n            let visibleEnemies = enemies;\n            if (!this.canSeeEnemies) {\n                visibleEnemies = []; // Cannot see any enemies when lacking enemy vision\n            }\n            // Call parent update with filtered enemy list\n            super.update(deltaTime, visibleEnemies, allUnits, asteroids);\n        }\n        /**\n         * Check if this Dagger is cloaked (invisible to enemies)\n         */\n        isCloakedToEnemies() {\n            return this.isCloaked;\n        }\n        /**\n         * Check if this Dagger can currently see enemies\n         */\n        hasEnemyVision() {\n            return this.canSeeEnemies;\n        }\n    }\n    return { Dagger };\n};\n\n\n//# sourceURL=webpack://sol/./src/heroes/dagger.ts?\n}");

/***/ },

/***/ "./src/heroes/driller.ts"
/*!*******************************!*\
  !*** ./src/heroes/driller.ts ***!
  \*******************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createDrillerHero: () => (/* binding */ createDrillerHero)\n/* harmony export */ });\nconst createDrillerHero = (deps) => {\n    const { Unit, Vector2D, Constants } = deps;\n    /**\n     * Driller hero unit (Aurum faction) - drills through asteroids\n     */\n    class Driller extends Unit {\n        constructor(position, owner) {\n            super(position, owner, Constants.DRILLER_MAX_HEALTH, Constants.DRILLER_ATTACK_RANGE, Constants.DRILLER_ATTACK_DAMAGE, Constants.DRILLER_ATTACK_SPEED, Constants.DRILLER_ABILITY_COOLDOWN);\n            this.isDrilling = false;\n            this.isHidden = false; // Hidden when inside asteroid\n            this.drillDirection = null;\n            this.drillVelocity = new Vector2D(0, 0);\n            this.hiddenInAsteroid = null;\n            this.isHero = true; // Driller is a hero unit for Aurum faction\n        }\n        /**\n         * Driller has no normal attack - only the drilling ability\n         */\n        attack(target) {\n            // Driller does not have a normal attack - it only attacks via drilling ability\n            // This is intentional per the unit design\n        }\n        /**\n         * Use Driller's drilling ability\n         */\n        useAbility(direction) {\n            // Check if already drilling\n            if (this.isDrilling) {\n                return false;\n            }\n            if (!super.useAbility(direction)) {\n                return false;\n            }\n            // Start drilling\n            this.isDrilling = true;\n            this.isHidden = false;\n            this.drillDirection = direction.normalize();\n            this.drillVelocity = new Vector2D(this.drillDirection.x * Constants.DRILLER_DRILL_SPEED, this.drillDirection.y * Constants.DRILLER_DRILL_SPEED);\n            return true;\n        }\n        /**\n         * Update drilling movement\n         */\n        updateDrilling(deltaTime) {\n            if (this.isDrilling && this.drillVelocity) {\n                this.position.x += this.drillVelocity.x * deltaTime;\n                this.position.y += this.drillVelocity.y * deltaTime;\n            }\n        }\n        /**\n         * Stop drilling and start cooldown\n         */\n        stopDrilling() {\n            this.isDrilling = false;\n            this.drillVelocity = new Vector2D(0, 0);\n            // Cooldown timer already set by useAbility\n        }\n        /**\n         * Hide in asteroid\n         */\n        hideInAsteroid(asteroid) {\n            this.isHidden = true;\n            this.hiddenInAsteroid = asteroid;\n            this.position = new Vector2D(asteroid.position.x, asteroid.position.y);\n        }\n        /**\n         * Check if driller is hidden\n         */\n        isHiddenInAsteroid() {\n            return this.isHidden;\n        }\n    }\n    return { Driller };\n};\n\n\n//# sourceURL=webpack://sol/./src/heroes/driller.ts?\n}");

/***/ },

/***/ "./src/heroes/grave.ts"
/*!*****************************!*\
  !*** ./src/heroes/grave.ts ***!
  \*****************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createGraveHero: () => (/* binding */ createGraveHero)\n/* harmony export */ });\nconst createGraveHero = (deps) => {\n    const { Unit, Vector2D, Constants } = deps;\n    /**\n     * Projectile that orbits a Grave unit with gravitational attraction\n     */\n    class GraveProjectile {\n        constructor(position, velocity, owner) {\n            this.position = position;\n            this.owner = owner;\n            this.lifetime = 0;\n            this.isAttacking = false;\n            this.targetEnemy = null;\n            this.trail = []; // Trail of positions\n            this.velocity = velocity;\n        }\n        /**\n         * Update projectile position with gravitational attraction to grave\n         */\n        update(deltaTime, gravePosition) {\n            if (!this.isAttacking) {\n                // Apply gravitational attraction to grave\n                const dx = gravePosition.x - this.position.x;\n                const dy = gravePosition.y - this.position.y;\n                const distance = Math.sqrt(dx * dx + dy * dy);\n                if (distance > 0) {\n                    // Normalize direction\n                    const dirX = dx / distance;\n                    const dirY = dy / distance;\n                    // Apply attraction force\n                    const force = Constants.GRAVE_PROJECTILE_ATTRACTION_FORCE;\n                    this.velocity.x += dirX * force * deltaTime;\n                    this.velocity.y += dirY * force * deltaTime;\n                    // Maintain minimum speed to keep orbiting\n                    const speed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.y * this.velocity.y);\n                    if (speed < Constants.GRAVE_PROJECTILE_MIN_SPEED) {\n                        const scale = Constants.GRAVE_PROJECTILE_MIN_SPEED / speed;\n                        this.velocity.x *= scale;\n                        this.velocity.y *= scale;\n                    }\n                }\n            }\n            // Update position\n            this.position.x += this.velocity.x * deltaTime;\n            this.position.y += this.velocity.y * deltaTime;\n            // Update trail when attacking\n            if (this.isAttacking) {\n                this.trail.push(new Vector2D(this.position.x, this.position.y));\n                if (this.trail.length > Constants.GRAVE_PROJECTILE_TRAIL_LENGTH) {\n                    this.trail.shift(); // Remove oldest trail point\n                }\n                this.lifetime += deltaTime;\n            }\n            // Check if hit target\n            if (this.isAttacking && this.targetEnemy) {\n                const distance = this.position.distanceTo(this.targetEnemy.position);\n                if (distance < Constants.GRAVE_PROJECTILE_HIT_DISTANCE) {\n                    // Hit the target\n                    if ('health' in this.targetEnemy) {\n                        this.targetEnemy.health -= Constants.GRAVE_ATTACK_DAMAGE;\n                    }\n                    // Mark for removal by returning to grave\n                    this.isAttacking = false;\n                    this.trail = [];\n                    this.targetEnemy = null;\n                }\n            }\n        }\n        /**\n         * Launch projectile toward target\n         */\n        launchAtTarget(target) {\n            this.isAttacking = true;\n            this.targetEnemy = target;\n            this.trail = [];\n            this.lifetime = 0;\n            // Set velocity toward target\n            const dx = target.position.x - this.position.x;\n            const dy = target.position.y - this.position.y;\n            const distance = Math.sqrt(dx * dx + dy * dy);\n            if (distance > 0) {\n                const dirX = dx / distance;\n                const dirY = dy / distance;\n                this.velocity.x = dirX * Constants.GRAVE_PROJECTILE_LAUNCH_SPEED;\n                this.velocity.y = dirY * Constants.GRAVE_PROJECTILE_LAUNCH_SPEED;\n            }\n        }\n        /**\n         * Reset projectile to orbit mode\n         */\n        returnToOrbit() {\n            this.isAttacking = false;\n            this.targetEnemy = null;\n            this.trail = [];\n            this.lifetime = 0;\n        }\n    }\n    /**\n     * Grave unit - has orbiting projectiles that attack enemies\n     */\n    class Grave extends Unit {\n        constructor(position, owner) {\n            super(position, owner, Constants.GRAVE_MAX_HEALTH, Constants.GRAVE_ATTACK_RANGE * Constants.GRAVE_HERO_ATTACK_RANGE_MULTIPLIER, // Hero units have reduced range\n            Constants.GRAVE_ATTACK_DAMAGE, Constants.GRAVE_ATTACK_SPEED, 5.0 // Default ability cooldown\n            );\n            this.projectiles = [];\n            this.projectileLaunchCooldown = 0;\n            this.isHero = true; // Grave is a hero unit for Aurum faction\n            // Initialize orbiting projectiles\n            for (let i = 0; i < Constants.GRAVE_NUM_PROJECTILES; i++) {\n                const angle = (i / Constants.GRAVE_NUM_PROJECTILES) * Math.PI * 2;\n                const offsetX = Math.cos(angle) * Constants.GRAVE_PROJECTILE_ORBIT_RADIUS;\n                const offsetY = Math.sin(angle) * Constants.GRAVE_PROJECTILE_ORBIT_RADIUS;\n                // Give initial tangential velocity for orbit\n                const tangentVelX = -Math.sin(angle) * Constants.GRAVE_PROJECTILE_MIN_SPEED;\n                const tangentVelY = Math.cos(angle) * Constants.GRAVE_PROJECTILE_MIN_SPEED;\n                this.projectiles.push(new GraveProjectile(new Vector2D(position.x + offsetX, position.y + offsetY), new Vector2D(tangentVelX, tangentVelY), owner));\n            }\n        }\n        /**\n         * Update grave and its projectiles\n         */\n        update(deltaTime, enemies, allUnits, asteroids = []) {\n            // Update base unit logic\n            super.update(deltaTime, enemies, allUnits, asteroids);\n            // Update projectile launch cooldown\n            if (this.projectileLaunchCooldown > 0) {\n                this.projectileLaunchCooldown -= deltaTime;\n            }\n            // Update all projectiles\n            for (const projectile of this.projectiles) {\n                projectile.update(deltaTime, this.position);\n            }\n            // Launch projectiles at enemies if in range\n            if (this.target && this.projectileLaunchCooldown <= 0) {\n                const distance = this.position.distanceTo(this.target.position);\n                if (distance <= this.attackRange) {\n                    // Find an available projectile (not currently attacking)\n                    const availableProjectile = this.projectiles.find((projectile) => !projectile.isAttacking);\n                    if (availableProjectile) {\n                        availableProjectile.launchAtTarget(this.target);\n                        this.projectileLaunchCooldown = 1.0 / this.attackSpeed;\n                    }\n                }\n            }\n        }\n        /**\n         * Grave doesn't use the base attack (projectiles do the damage)\n         */\n        attack(target) {\n            // Projectiles handle the actual attacking\n        }\n        /**\n         * Get all projectiles for rendering\n         */\n        getProjectiles() {\n            return this.projectiles;\n        }\n    }\n    return { Grave, GraveProjectile };\n};\n\n\n//# sourceURL=webpack://sol/./src/heroes/grave.ts?\n}");

/***/ },

/***/ "./src/heroes/influence-ball.ts"
/*!**************************************!*\
  !*** ./src/heroes/influence-ball.ts ***!
  \**************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createInfluenceBallHero: () => (/* binding */ createInfluenceBallHero)\n/* harmony export */ });\nconst createInfluenceBallHero = (deps) => {\n    const { Unit, Vector2D, Constants } = deps;\n    /**\n     * Influence zone created by InfluenceBall ability\n     */\n    class InfluenceZone {\n        constructor(position, owner, radius = Constants.INFLUENCE_BALL_EXPLOSION_RADIUS, duration = Constants.INFLUENCE_BALL_DURATION) {\n            this.position = position;\n            this.owner = owner;\n            this.radius = radius;\n            this.duration = duration;\n            this.lifetime = 0;\n        }\n        update(deltaTime) {\n            this.lifetime += deltaTime;\n            return this.lifetime >= this.duration;\n        }\n        isExpired() {\n            return this.lifetime >= this.duration;\n        }\n    }\n    /**\n     * Influence Ball projectile\n     */\n    class InfluenceBallProjectile {\n        constructor(position, velocity, owner) {\n            this.position = position;\n            this.owner = owner;\n            this.lifetime = 0;\n            this.maxLifetime = 5.0; // Max 5 seconds before auto-explode\n            this.velocity = velocity;\n        }\n        update(deltaTime) {\n            this.position.x += this.velocity.x * deltaTime;\n            this.position.y += this.velocity.y * deltaTime;\n            this.lifetime += deltaTime;\n        }\n        shouldExplode() {\n            return this.lifetime >= this.maxLifetime;\n        }\n    }\n    /**\n     * Influence Ball hero unit (Solari faction) - creates temporary influence zones\n     */\n    class InfluenceBall extends Unit {\n        constructor(position, owner) {\n            super(position, owner, Constants.INFLUENCE_BALL_MAX_HEALTH, Constants.INFLUENCE_BALL_ATTACK_RANGE, Constants.INFLUENCE_BALL_ATTACK_DAMAGE, Constants.INFLUENCE_BALL_ATTACK_SPEED, Constants.INFLUENCE_BALL_ABILITY_COOLDOWN);\n            this.projectileToCreate = null;\n            this.isHero = true; // InfluenceBall is a hero unit for Solari faction\n        }\n        /**\n         * Use Influence Ball's area control ability\n         */\n        useAbility(direction) {\n            if (!super.useAbility(direction)) {\n                return false;\n            }\n            // Create influence ball projectile\n            const velocity = new Vector2D(direction.x * Constants.INFLUENCE_BALL_PROJECTILE_SPEED, direction.y * Constants.INFLUENCE_BALL_PROJECTILE_SPEED);\n            this.projectileToCreate = new InfluenceBallProjectile(new Vector2D(this.position.x, this.position.y), velocity, this.owner);\n            return true;\n        }\n        /**\n         * Get and clear pending projectile\n         */\n        getAndClearProjectile() {\n            const proj = this.projectileToCreate;\n            this.projectileToCreate = null;\n            return proj;\n        }\n    }\n    return { InfluenceBall, InfluenceZone, InfluenceBallProjectile };\n};\n\n\n//# sourceURL=webpack://sol/./src/heroes/influence-ball.ts?\n}");

/***/ },

/***/ "./src/heroes/marine.ts"
/*!******************************!*\
  !*** ./src/heroes/marine.ts ***!
  \******************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createMarineHero: () => (/* binding */ createMarineHero)\n/* harmony export */ });\nconst createMarineHero = (deps) => {\n    const { Unit, Vector2D, Constants, MuzzleFlash, BulletCasing, BouncingBullet, AbilityBullet } = deps;\n    class Marine extends Unit {\n        constructor(position, owner) {\n            super(position, owner, Constants.MARINE_MAX_HEALTH, Constants.MARINE_ATTACK_RANGE, Constants.MARINE_ATTACK_DAMAGE, Constants.MARINE_ATTACK_SPEED, Constants.MARINE_ABILITY_COOLDOWN);\n            this.lastShotEffects = {};\n            this.isHero = true; // Marine is a hero unit for Radiant faction\n        }\n        /**\n         * Attack with visual effects\n         */\n        attack(target) {\n            // Apply damage\n            super.attack(target);\n            // Calculate angle to target\n            const dx = target.position.x - this.position.x;\n            const dy = target.position.y - this.position.y;\n            const angle = Math.atan2(dy, dx);\n            // Create muzzle flash\n            this.lastShotEffects.muzzleFlash = new MuzzleFlash(new Vector2D(this.position.x, this.position.y), angle);\n            // Create bullet casing with slight angle deviation\n            const casingAngle = angle + Math.PI / 2 + (Math.random() - 0.5) * 0.5; // Eject to the side\n            const casingSpeed = Constants.BULLET_CASING_SPEED_MIN +\n                Math.random() * (Constants.BULLET_CASING_SPEED_MAX - Constants.BULLET_CASING_SPEED_MIN);\n            this.lastShotEffects.casing = new BulletCasing(new Vector2D(this.position.x, this.position.y), new Vector2D(Math.cos(casingAngle) * casingSpeed, Math.sin(casingAngle) * casingSpeed));\n            // Create bouncing bullet at target position\n            const bounceAngle = angle + Math.PI + (Math.random() - 0.5) * 1.0; // Bounce away from impact\n            const bounceSpeed = Constants.BOUNCING_BULLET_SPEED_MIN +\n                Math.random() * (Constants.BOUNCING_BULLET_SPEED_MAX - Constants.BOUNCING_BULLET_SPEED_MIN);\n            this.lastShotEffects.bouncingBullet = new BouncingBullet(new Vector2D(target.position.x, target.position.y), new Vector2D(Math.cos(bounceAngle) * bounceSpeed, Math.sin(bounceAngle) * bounceSpeed));\n        }\n        /**\n         * Get effects from last shot (for game state to manage)\n         */\n        getAndClearLastShotEffects() {\n            const effects = this.lastShotEffects;\n            this.lastShotEffects = {};\n            return effects;\n        }\n        /**\n         * Use special ability: Bullet Storm\n         * Fires a spread of bullets in the specified direction\n         */\n        useAbility(direction) {\n            // Check if ability is ready\n            if (!super.useAbility(direction)) {\n                return false;\n            }\n            // Calculate base angle from direction\n            const baseAngle = Math.atan2(direction.y, direction.x);\n            // Create bullets with spread\n            const spreadAngle = Constants.MARINE_ABILITY_SPREAD_ANGLE;\n            const bulletCount = Constants.MARINE_ABILITY_BULLET_COUNT;\n            for (let i = 0; i < bulletCount; i++) {\n                // Calculate angle for this bullet within the spread\n                // Distribute bullets evenly within the spread angle\n                // Use max to avoid division by zero if bulletCount is 1\n                const angleOffset = (i / Math.max(bulletCount - 1, 1) - 0.5) * spreadAngle * 2;\n                const bulletAngle = baseAngle + angleOffset;\n                // Calculate velocity\n                const speed = Constants.MARINE_ABILITY_BULLET_SPEED;\n                const velocity = new Vector2D(Math.cos(bulletAngle) * speed, Math.sin(bulletAngle) * speed);\n                // Create bullet\n                const bullet = new AbilityBullet(new Vector2D(this.position.x, this.position.y), velocity, this.owner);\n                this.lastAbilityEffects.push(bullet);\n            }\n            return true;\n        }\n    }\n    return { Marine };\n};\n\n\n//# sourceURL=webpack://sol/./src/heroes/marine.ts?\n}");

/***/ },

/***/ "./src/heroes/mortar.ts"
/*!******************************!*\
  !*** ./src/heroes/mortar.ts ***!
  \******************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createMortarHero: () => (/* binding */ createMortarHero)\n/* harmony export */ });\nconst createMortarHero = (deps) => {\n    const { Unit, Vector2D, Constants } = deps;\n    /**\n     * Mortar Projectile - projectile that deals splash damage on impact\n     */\n    class MortarProjectile {\n        constructor(position, velocity, owner, damage, splashRadius) {\n            this.position = position;\n            this.owner = owner;\n            this.damage = damage;\n            this.splashRadius = splashRadius;\n            this.lifetime = 0;\n            this.maxLifetime = 3.0; // 3 seconds max flight time\n            this.velocity = velocity;\n        }\n        /**\n         * Update projectile position\n         */\n        update(deltaTime) {\n            this.position.x += this.velocity.x * deltaTime;\n            this.position.y += this.velocity.y * deltaTime;\n            this.lifetime += deltaTime;\n        }\n        /**\n         * Check if projectile should be removed\n         */\n        shouldDespawn() {\n            return this.lifetime >= this.maxLifetime;\n        }\n        /**\n         * Check if projectile hits a target\n         */\n        checkHit(target) {\n            const distance = this.position.distanceTo(target.position);\n            return distance < 15; // Hit radius slightly larger than standard\n        }\n        /**\n         * Apply splash damage to all targets within splash radius\n         * Returns array of targets that took damage\n         */\n        applySplashDamage(targets) {\n            const damagedTargets = [];\n            for (const target of targets) {\n                const distance = this.position.distanceTo(target.position);\n                if (distance <= this.splashRadius) {\n                    // Calculate damage falloff based on distance\n                    const damageMultiplier = 1.0 - (distance / this.splashRadius) * (1.0 - Constants.MORTAR_SPLASH_DAMAGE_FALLOFF);\n                    const finalDamage = this.damage * damageMultiplier;\n                    // Apply damage\n                    if ('health' in target) {\n                        target.health -= finalDamage;\n                        damagedTargets.push(target);\n                    }\n                }\n            }\n            return damagedTargets;\n        }\n    }\n    /**\n     * Mortar hero unit (Radiant faction) - stationary artillery\n     * Must be set up by swiping in a direction before it can attack\n     * Detects enemies in a 150-degree cone and fires splash damage rounds at low fire rate\n     */\n    class Mortar extends Unit {\n        constructor(position, owner) {\n            super(position, owner, Constants.MORTAR_MAX_HEALTH, Constants.MORTAR_ATTACK_RANGE, Constants.MORTAR_ATTACK_DAMAGE, Constants.MORTAR_ATTACK_SPEED, Constants.MORTAR_ABILITY_COOLDOWN);\n            this.isSetup = false; // Not active until set up\n            this.facingDirection = null; // Direction mortar is facing after setup\n            this.lastShotProjectiles = [];\n            this.isHero = true; // Mortar is a hero unit for Radiant faction\n        }\n        /**\n         * Use ability: Set up the mortar facing a specific direction\n         * This enables the mortar to start attacking enemies in its cone\n         */\n        useAbility(direction) {\n            // Store the facing direction (normalized)\n            this.facingDirection = direction.normalize();\n            this.isSetup = true;\n            // Mark ability as used (though it has no cooldown)\n            return true;\n        }\n        /**\n         * Override update to only find enemies within the detection cone\n         */\n        update(deltaTime, enemies, allUnits, asteroids = []) {\n            // If not set up yet, don't attack\n            if (!this.isSetup || !this.facingDirection) {\n                // Just update cooldown\n                if (this.attackCooldown > 0) {\n                    this.attackCooldown -= deltaTime;\n                }\n                if (this.abilityCooldown > 0) {\n                    this.abilityCooldown -= deltaTime;\n                }\n                return;\n            }\n            // Filter enemies to only those in the detection cone\n            const enemiesInCone = this.getEnemiesInCone(enemies);\n            // Call parent update with filtered enemy list\n            super.update(deltaTime, enemiesInCone, allUnits, asteroids);\n        }\n        /**\n         * Filter enemies to only those within the detection cone\n         */\n        getEnemiesInCone(enemies) {\n            if (!this.facingDirection) {\n                return [];\n            }\n            const enemiesInCone = [];\n            const facingAngle = Math.atan2(this.facingDirection.y, this.facingDirection.x);\n            const halfConeAngle = Constants.MORTAR_DETECTION_CONE_ANGLE / 2;\n            for (const enemy of enemies) {\n                // Calculate angle to enemy\n                const dx = enemy.position.x - this.position.x;\n                const dy = enemy.position.y - this.position.y;\n                const angleToEnemy = Math.atan2(dy, dx);\n                // Calculate angle difference (accounting for wrap-around)\n                let angleDiff = angleToEnemy - facingAngle;\n                // Normalize angle difference to [-PI, PI]\n                while (angleDiff > Math.PI)\n                    angleDiff -= 2 * Math.PI;\n                while (angleDiff < -Math.PI)\n                    angleDiff += 2 * Math.PI;\n                // Check if enemy is within the cone\n                if (Math.abs(angleDiff) <= halfConeAngle) {\n                    enemiesInCone.push(enemy);\n                }\n            }\n            return enemiesInCone;\n        }\n        /**\n         * Attack with mortar projectile that has splash damage\n         */\n        attack(target) {\n            // Don't apply damage directly - projectile will handle it\n            // Just create the projectile\n            // Calculate angle to target\n            const dx = target.position.x - this.position.x;\n            const dy = target.position.y - this.position.y;\n            const angle = Math.atan2(dy, dx);\n            // Create projectile velocity\n            const speed = Constants.MORTAR_PROJECTILE_SPEED;\n            const velocity = new Vector2D(Math.cos(angle) * speed, Math.sin(angle) * speed);\n            // Create mortar projectile with splash damage\n            const projectile = new MortarProjectile(new Vector2D(this.position.x, this.position.y), velocity, this.owner, this.attackDamage, Constants.MORTAR_SPLASH_RADIUS);\n            this.lastShotProjectiles.push(projectile);\n        }\n        /**\n         * Get and clear projectiles from last shot (for game state to manage)\n         */\n        getAndClearLastShotProjectiles() {\n            const projectiles = this.lastShotProjectiles;\n            this.lastShotProjectiles = [];\n            return projectiles;\n        }\n        /**\n         * Check if mortar is set up and ready to fire\n         */\n        isReadyToFire() {\n            return this.isSetup && this.facingDirection !== null;\n        }\n        /**\n         * Get the facing direction of the mortar\n         */\n        getFacingDirection() {\n            return this.facingDirection;\n        }\n    }\n    return { Mortar, MortarProjectile };\n};\n\n\n//# sourceURL=webpack://sol/./src/heroes/mortar.ts?\n}");

/***/ },

/***/ "./src/heroes/preist.ts"
/*!******************************!*\
  !*** ./src/heroes/preist.ts ***!
  \******************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createPreistHero: () => (/* binding */ createPreistHero)\n/* harmony export */ });\nconst createPreistHero = (deps) => {\n    const { Unit, Vector2D, Constants, AbilityBullet } = deps;\n    /**\n     * Healing bomb particle - wild particles that heal units they hit\n     */\n    class HealingBombParticle {\n        constructor(position, velocity, owner) {\n            this.position = position;\n            this.velocity = velocity;\n            this.owner = owner;\n            this.lifetime = 0;\n            this.maxLifetime = Constants.PREIST_HEALING_BOMB_PARTICLE_LIFETIME;\n            this.hasHealed = new Set(); // Track which units this particle has healed\n        }\n        update(deltaTime) {\n            this.lifetime += deltaTime;\n            this.position.x += this.velocity.x * deltaTime;\n            this.position.y += this.velocity.y * deltaTime;\n            return this.lifetime >= this.maxLifetime;\n        }\n    }\n    /**\n     * Preist hero unit - support hero that heals allies with dual beams and healing bomb ability\n     * Prioritizes hero units over starlings, and most damaged units over less damaged ones\n     * Each beam stays locked on a target for at least 0.5 seconds\n     */\n    class Preist extends Unit {\n        constructor(position, owner) {\n            super(position, owner, Constants.PREIST_MAX_HEALTH, Constants.PREIST_HEALING_RANGE, // Use healing range as \"attack range\"\n            Constants.PREIST_ATTACK_DAMAGE, Constants.PREIST_ATTACK_SPEED, Constants.PREIST_ABILITY_COOLDOWN);\n            this.beamTargets = [];\n            this.healingBombParticles = [];\n            this.isHero = true;\n            // Initialize beam targets\n            for (let i = 0; i < Constants.PREIST_NUM_BEAMS; i++) {\n                this.beamTargets.push({ target: null, lockTimer: 0 });\n            }\n        }\n        /**\n         * Override update to handle healing beam targeting\n         */\n        update(deltaTime, enemies, allUnits, asteroids = []) {\n            // Call parent update but skip default attacking behavior\n            // Update cooldowns\n            if (this.attackCooldown > 0) {\n                this.attackCooldown -= deltaTime;\n            }\n            if (this.abilityCooldown > 0) {\n                this.abilityCooldown -= deltaTime;\n            }\n            this.moveTowardRallyPoint(deltaTime, Constants.UNIT_MOVE_SPEED, allUnits, asteroids);\n            // Handle healing beam targeting and healing\n            const friendlyUnits = this.getFriendlyUnits(allUnits);\n            this.updateHealingBeams(deltaTime, friendlyUnits);\n            // Update healing bomb particles\n            this.updateHealingBombParticles(deltaTime, allUnits);\n            // Rotate to face the primary healing target\n            if (this.beamTargets[0].target && !this.isTargetDead(this.beamTargets[0].target)) {\n                const target = this.beamTargets[0].target;\n                const dx = target.position.x - this.position.x;\n                const dy = target.position.y - this.position.y;\n                const targetRotation = Math.atan2(dy, dx) + Math.PI / 2;\n                const rotationDelta = this.getShortestAngleDelta(this.rotation, targetRotation);\n                const maxRotationStep = Constants.UNIT_TURN_SPEED_RAD_PER_SEC * deltaTime;\n                if (Math.abs(rotationDelta) <= maxRotationStep) {\n                    this.rotation = targetRotation;\n                }\n                else {\n                    this.rotation += Math.sign(rotationDelta) * maxRotationStep;\n                }\n                // Normalize rotation to [0, 2)\n                this.rotation = ((this.rotation % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);\n            }\n        }\n        /**\n         * Get friendly units that can be healed\n         */\n        getFriendlyUnits(allUnits) {\n            return allUnits.filter(unit => unit.owner === this.owner &&\n                unit !== this &&\n                !unit.isDead());\n        }\n        /**\n         * Update healing beams - find targets and apply healing\n         */\n        updateHealingBeams(deltaTime, friendlyUnits) {\n            // Update lock timers and clear targets if timer expired or target dead/out of range\n            for (const beamTarget of this.beamTargets) {\n                if (beamTarget.lockTimer > 0) {\n                    beamTarget.lockTimer -= deltaTime;\n                }\n                // Clear target if dead, out of range, or fully healed\n                if (beamTarget.target) {\n                    const targetDead = this.isTargetDead(beamTarget.target);\n                    const targetOutOfRange = this.position.distanceTo(beamTarget.target.position) > this.attackRange;\n                    const targetFullHealth = 'health' in beamTarget.target &&\n                        'maxHealth' in beamTarget.target &&\n                        beamTarget.target.health >= beamTarget.target.maxHealth;\n                    if (targetDead || targetOutOfRange || targetFullHealth || beamTarget.lockTimer <= 0) {\n                        beamTarget.target = null;\n                        beamTarget.lockTimer = 0;\n                    }\n                }\n            }\n            // Find new targets for beams that don't have one\n            for (const beamTarget of this.beamTargets) {\n                if (!beamTarget.target) {\n                    const newTarget = this.findBestHealingTarget(friendlyUnits);\n                    if (newTarget) {\n                        beamTarget.target = newTarget;\n                        beamTarget.lockTimer = Constants.PREIST_TARGET_LOCK_DURATION;\n                    }\n                }\n            }\n            // Apply healing to targets\n            for (const beamTarget of this.beamTargets) {\n                if (beamTarget.target && 'health' in beamTarget.target && 'maxHealth' in beamTarget.target) {\n                    const target = beamTarget.target;\n                    const healAmount = target.maxHealth * Constants.PREIST_HEALING_PER_SECOND * deltaTime;\n                    target.health = Math.min(target.maxHealth, target.health + healAmount);\n                }\n            }\n        }\n        /**\n         * Find the best target for healing based on priority rules:\n         * 1. Heroes over starlings\n         * 2. Most damaged over less damaged\n         * 3. Don't target units that are already being healed by another beam\n         */\n        findBestHealingTarget(friendlyUnits) {\n            // Get units that are already targeted by other beams\n            const currentlyTargeted = new Set(this.beamTargets\n                .filter(bt => bt.target)\n                .map(bt => bt.target));\n            // Filter to units that need healing, are in range, and not already targeted\n            const damagedUnitsInRange = friendlyUnits.filter(unit => {\n                if (currentlyTargeted.has(unit))\n                    return false;\n                if (unit.health >= unit.maxHealth)\n                    return false;\n                const distance = this.position.distanceTo(unit.position);\n                return distance <= this.attackRange;\n            });\n            if (damagedUnitsInRange.length === 0)\n                return null;\n            // Sort by priority: heroes first, then by most damaged (lowest health percentage)\n            damagedUnitsInRange.sort((a, b) => {\n                // Prioritize heroes over non-heroes\n                if (a.isHero !== b.isHero) {\n                    return a.isHero ? -1 : 1;\n                }\n                // Within same hero status, prioritize most damaged (lowest health percentage)\n                const aHealthPercent = a.health / a.maxHealth;\n                const bHealthPercent = b.health / b.maxHealth;\n                return aHealthPercent - bHealthPercent;\n            });\n            return damagedUnitsInRange[0];\n        }\n        /**\n         * Get current healing beam targets (for rendering)\n         */\n        getHealingBeamTargets() {\n            return this.beamTargets.map(bt => bt.target);\n        }\n        /**\n         * Use Preist's healing bomb ability\n         */\n        useAbility(direction) {\n            if (!super.useAbility(direction)) {\n                return false;\n            }\n            // Create a healing bomb projectile that travels in the given direction\n            const bombDir = direction.normalize();\n            const velocity = new Vector2D(bombDir.x * Constants.PREIST_HEALING_BOMB_SPEED, bombDir.y * Constants.PREIST_HEALING_BOMB_SPEED);\n            const bomb = new AbilityBullet(new Vector2D(this.position.x, this.position.y), velocity, this.owner, 0 // No damage, this is a healing bomb\n            );\n            bomb.maxRange = Constants.PREIST_HEALING_BOMB_MAX_RANGE;\n            bomb.isHealingBomb = true;\n            bomb.healingBombOwner = this;\n            this.lastAbilityEffects.push(bomb);\n            return true;\n        }\n        /**\n         * Explode healing bomb at position, creating wild particles\n         */\n        explodeHealingBomb(position) {\n            // Create 50 wild particles in random directions within a constrained circular area\n            for (let i = 0; i < Constants.PREIST_HEALING_BOMB_PARTICLE_COUNT; i++) {\n                // Random angle\n                const angle = Math.random() * Math.PI * 2;\n                // Random speed (with some variation for visual effect)\n                const speedVariation = 0.5 + Math.random() * 0.5; // 0.5x to 1.0x speed\n                const speed = Constants.PREIST_HEALING_BOMB_PARTICLE_SPEED * speedVariation;\n                const velocity = new Vector2D(Math.cos(angle) * speed, Math.sin(angle) * speed);\n                const particle = new HealingBombParticle(new Vector2D(position.x, position.y), velocity, this.owner);\n                this.healingBombParticles.push(particle);\n            }\n        }\n        /**\n         * Update healing bomb particles and apply healing\n         */\n        updateHealingBombParticles(deltaTime, allUnits) {\n            // Update particles and check for collisions with units\n            this.healingBombParticles = this.healingBombParticles.filter(particle => {\n                const expired = particle.update(deltaTime);\n                if (!expired) {\n                    // Check for collisions with units (both friendly and enemy)\n                    for (const unit of allUnits) {\n                        if (!unit.isDead() && !particle.hasHealed.has(unit)) {\n                            const distance = particle.position.distanceTo(unit.position);\n                            const hitRadius = unit.collisionRadiusPx || Constants.UNIT_RADIUS_PX;\n                            if (distance <= hitRadius) {\n                                // Heal the unit\n                                const healAmount = unit.maxHealth * Constants.PREIST_HEALING_BOMB_PARTICLE_HEALING;\n                                unit.health = Math.min(unit.maxHealth, unit.health + healAmount);\n                                // Mark this unit as healed by this particle\n                                particle.hasHealed.add(unit);\n                            }\n                        }\n                    }\n                }\n                return !expired;\n            });\n        }\n        /**\n         * Get healing bomb particles (for rendering)\n         */\n        getHealingBombParticles() {\n            return this.healingBombParticles;\n        }\n        /**\n         * Override attack to do nothing (Preist doesn't attack)\n         */\n        attack(target) {\n            // Preist doesn't attack, only heals\n        }\n    }\n    return { Preist, HealingBombParticle };\n};\n\n\n//# sourceURL=webpack://sol/./src/heroes/preist.ts?\n}");

/***/ },

/***/ "./src/heroes/ray.ts"
/*!***************************!*\
  !*** ./src/heroes/ray.ts ***!
  \***************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createRayHero: () => (/* binding */ createRayHero)\n/* harmony export */ });\nconst createRayHero = (deps) => {\n    const { Unit, Vector2D, Constants } = deps;\n    /**\n     * Ray beam segment for bouncing beam ability\n     */\n    class RayBeamSegment {\n        constructor(startPos, endPos, owner) {\n            this.startPos = startPos;\n            this.endPos = endPos;\n            this.owner = owner;\n            this.lifetime = 0;\n            this.maxLifetime = 0.5; // 0.5 seconds per segment\n        }\n        update(deltaTime) {\n            this.lifetime += deltaTime;\n            return this.lifetime >= this.maxLifetime;\n        }\n    }\n    /**\n     * Ray hero unit (Solari faction) - shoots bouncing beam\n     */\n    class Ray extends Unit {\n        constructor(position, owner) {\n            super(position, owner, Constants.RAY_MAX_HEALTH, Constants.RAY_ATTACK_RANGE, Constants.RAY_ATTACK_DAMAGE, Constants.RAY_ATTACK_SPEED, Constants.RAY_ABILITY_COOLDOWN);\n            this.beamSegments = [];\n            this.drillDirection = null; // Used temporarily to store ability direction\n            this.isHero = true; // Ray is a hero unit for Solari faction\n        }\n        /**\n         * Use Ray's bouncing beam ability\n         */\n        useAbility(direction) {\n            if (!super.useAbility(direction)) {\n                return false;\n            }\n            // Store direction for GameState to process\n            this.drillDirection = direction;\n            return true;\n        }\n        /**\n         * Get beam segments for rendering\n         */\n        getBeamSegments() {\n            return this.beamSegments;\n        }\n        /**\n         * Set beam segments (called by GameState after calculating bounces)\n         */\n        setBeamSegments(segments) {\n            this.beamSegments = segments;\n        }\n        /**\n         * Update beam segments\n         */\n        updateBeamSegments(deltaTime) {\n            this.beamSegments = this.beamSegments.filter((segment) => !segment.update(deltaTime));\n        }\n    }\n    return { Ray, RayBeamSegment };\n};\n\n\n//# sourceURL=webpack://sol/./src/heroes/ray.ts?\n}");

/***/ },

/***/ "./src/heroes/tank.ts"
/*!****************************!*\
  !*** ./src/heroes/tank.ts ***!
  \****************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createTankHero: () => (/* binding */ createTankHero)\n/* harmony export */ });\nconst createTankHero = (deps) => {\n    const { Unit, Vector2D, Constants } = deps;\n    /**\n     * Crescent wave projectile that stuns units and erases projectiles\n     */\n    class CrescentWave {\n        constructor(position, direction, // Normalized direction vector\n        angle, // Center angle of the wave\n        owner) {\n            this.position = position;\n            this.direction = direction;\n            this.angle = angle;\n            this.owner = owner;\n            this.lifetime = 0;\n            this.distanceTraveled = 0;\n            this.affectedUnits = new Set(); // Track which units have been stunned\n        }\n        update(deltaTime) {\n            const moveDistance = Constants.TANK_WAVE_SPEED * deltaTime;\n            this.position.x += this.direction.x * moveDistance;\n            this.position.y += this.direction.y * moveDistance;\n            this.distanceTraveled += moveDistance;\n            this.lifetime += deltaTime;\n        }\n        shouldDespawn() {\n            return this.distanceTraveled >= Constants.TANK_WAVE_RANGE;\n        }\n        /**\n         * Check if a point is within the crescent wave's arc\n         */\n        isPointInWave(point) {\n            const dx = point.x - this.position.x;\n            const dy = point.y - this.position.y;\n            const distance = Math.sqrt(dx * dx + dy * dy);\n            // Check if within wave width\n            if (distance > Constants.TANK_WAVE_WIDTH) {\n                return false;\n            }\n            // Check if within the 90-degree arc in front of the wave\n            const pointAngle = Math.atan2(dy, dx);\n            const angleDiff = this.normalizeAngle(pointAngle - this.angle);\n            // Within 45 degrees on either side (90 degrees total)\n            return Math.abs(angleDiff) <= Constants.TANK_WAVE_ANGLE / 2;\n        }\n        normalizeAngle(angle) {\n            while (angle > Math.PI)\n                angle -= 2 * Math.PI;\n            while (angle < -Math.PI)\n                angle += 2 * Math.PI;\n            return angle;\n        }\n    }\n    /**\n     * Tank hero unit - extremely tough defensive hero with projectile shield\n     * Doesn't attack but has a crescent wave ability that stuns and erases projectiles\n     */\n    class Tank extends Unit {\n        constructor(position, owner) {\n            super(position, owner, Constants.TANK_MAX_HEALTH, Constants.TANK_ATTACK_RANGE, Constants.TANK_ATTACK_DAMAGE, Constants.TANK_ATTACK_SPEED, Constants.TANK_ABILITY_COOLDOWN, Constants.TANK_COLLISION_RADIUS_PX);\n            this.crescentWave = null;\n            this.isHero = true;\n        }\n        /**\n         * Tank doesn't attack\n         */\n        attack(target) {\n            // Tank doesn't attack\n        }\n        /**\n         * Override update to skip normal attack behavior\n         */\n        update(deltaTime, enemies, allUnits, asteroids = []) {\n            // Update cooldowns\n            if (this.attackCooldown > 0) {\n                this.attackCooldown -= deltaTime;\n            }\n            if (this.abilityCooldown > 0) {\n                this.abilityCooldown -= deltaTime;\n            }\n            // Update stun duration - if stunned, can't do anything else\n            if (this.stunDuration > 0) {\n                this.stunDuration -= deltaTime;\n                return;\n            }\n            this.moveTowardRallyPoint(deltaTime, Constants.UNIT_MOVE_SPEED, allUnits, asteroids);\n            // Update rotation based on movement or face nearest enemy\n            if (this.rallyPoint) {\n                // Face movement direction\n                const dx = this.rallyPoint.x - this.position.x;\n                const dy = this.rallyPoint.y - this.position.y;\n                if (Math.abs(dx) > 0.1 || Math.abs(dy) > 0.1) {\n                    const targetRotation = Math.atan2(dy, dx) + Math.PI / 2;\n                    const rotationDelta = this.getShortestAngleDelta(this.rotation, targetRotation);\n                    const maxRotationStep = Constants.UNIT_TURN_SPEED_RAD_PER_SEC * deltaTime;\n                    if (Math.abs(rotationDelta) <= maxRotationStep) {\n                        this.rotation = targetRotation;\n                    }\n                    else {\n                        this.rotation += Math.sign(rotationDelta) * maxRotationStep;\n                    }\n                    // Normalize rotation to [0, 2)\n                    this.rotation = ((this.rotation % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);\n                }\n            }\n            else {\n                // Face nearest enemy when not moving\n                const nearestEnemy = this.findNearestEnemy(enemies);\n                if (nearestEnemy && !this.isTargetDead(nearestEnemy)) {\n                    const dx = nearestEnemy.position.x - this.position.x;\n                    const dy = nearestEnemy.position.y - this.position.y;\n                    const targetRotation = Math.atan2(dy, dx) + Math.PI / 2;\n                    const rotationDelta = this.getShortestAngleDelta(this.rotation, targetRotation);\n                    const maxRotationStep = Constants.UNIT_TURN_SPEED_RAD_PER_SEC * deltaTime;\n                    if (Math.abs(rotationDelta) <= maxRotationStep) {\n                        this.rotation = targetRotation;\n                    }\n                    else {\n                        this.rotation += Math.sign(rotationDelta) * maxRotationStep;\n                    }\n                    // Normalize rotation to [0, 2)\n                    this.rotation = ((this.rotation % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);\n                }\n            }\n            // Update crescent wave\n            if (this.crescentWave) {\n                this.crescentWave.update(deltaTime);\n                if (this.crescentWave.shouldDespawn()) {\n                    this.crescentWave = null;\n                }\n            }\n        }\n        /**\n         * Use special ability: Crescent Wave\n         * Sends a slow 90-degree wave that erases projectiles and stuns units\n         */\n        useAbility(direction) {\n            // Check if ability is ready\n            if (!super.useAbility(direction)) {\n                return false;\n            }\n            // Calculate angle from direction\n            const angle = Math.atan2(direction.y, direction.x);\n            // Create crescent wave\n            this.crescentWave = new CrescentWave(new Vector2D(this.position.x, this.position.y), direction.normalize(), angle, this.owner);\n            return true;\n        }\n        /**\n         * Get the current crescent wave\n         */\n        getCrescentWave() {\n            return this.crescentWave;\n        }\n        /**\n         * Check if a position is within the shield radius\n         */\n        isPositionInShield(position) {\n            const distance = this.position.distanceTo(position);\n            return distance <= Constants.TANK_SHIELD_RADIUS;\n        }\n    }\n    return { Tank, CrescentWave };\n};\n\n\n//# sourceURL=webpack://sol/./src/heroes/tank.ts?\n}");

/***/ },

/***/ "./src/heroes/turret-deployer.ts"
/*!***************************************!*\
  !*** ./src/heroes/turret-deployer.ts ***!
  \***************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createTurretDeployerHero: () => (/* binding */ createTurretDeployerHero)\n/* harmony export */ });\nconst createTurretDeployerHero = (deps) => {\n    const { Unit, Vector2D, Constants } = deps;\n    /**\n     * Deployed turret that attaches to asteroids\n     */\n    class DeployedTurret {\n        constructor(position, owner, attachedToAsteroid = null) {\n            this.position = position;\n            this.owner = owner;\n            this.attachedToAsteroid = attachedToAsteroid;\n            this.maxHealth = Constants.DEPLOYED_TURRET_MAX_HEALTH;\n            this.attackCooldown = 0;\n            this.target = null;\n            this.firingAnimationProgress = 0; // 0-1 progress through firing animation\n            this.isFiring = false; // Whether currently in firing animation\n            this.health = this.maxHealth;\n        }\n        update(deltaTime, enemies) {\n            // Update attack cooldown\n            if (this.attackCooldown > 0) {\n                this.attackCooldown -= deltaTime;\n            }\n            // Update firing animation\n            if (this.isFiring) {\n                // Animation completes in DEPLOYED_TURRET_ANIMATION_DURATION seconds\n                this.firingAnimationProgress += deltaTime / Constants.DEPLOYED_TURRET_ANIMATION_DURATION;\n                if (this.firingAnimationProgress >= 1.0) {\n                    this.firingAnimationProgress = 0;\n                    this.isFiring = false;\n                }\n            }\n            // Find target if don't have one or current target is dead\n            if (!this.target || this.isTargetDead(this.target)) {\n                this.target = this.findNearestEnemy(enemies);\n            }\n            // Attack if target in range and cooldown ready\n            if (this.target && this.attackCooldown <= 0) {\n                const distance = this.position.distanceTo(this.target.position);\n                if (distance <= Constants.DEPLOYED_TURRET_ATTACK_RANGE) {\n                    this.attack(this.target);\n                    this.attackCooldown = 1.0 / Constants.DEPLOYED_TURRET_ATTACK_SPEED;\n                    this.isFiring = true;\n                    this.firingAnimationProgress = 0;\n                }\n            }\n        }\n        isTargetDead(target) {\n            if ('health' in target) {\n                return target.health <= 0;\n            }\n            return false;\n        }\n        findNearestEnemy(enemies) {\n            let nearest = null;\n            let minDistance = Infinity;\n            for (const enemy of enemies) {\n                if ('health' in enemy && enemy.health <= 0)\n                    continue;\n                const distance = this.position.distanceTo(enemy.position);\n                if (distance < minDistance) {\n                    minDistance = distance;\n                    nearest = enemy;\n                }\n            }\n            return nearest;\n        }\n        attack(target) {\n            if ('health' in target) {\n                target.health -= Constants.DEPLOYED_TURRET_ATTACK_DAMAGE;\n            }\n        }\n        takeDamage(amount) {\n            this.health -= amount;\n        }\n        isDead() {\n            return this.health <= 0;\n        }\n    }\n    /**\n     * Turret Deployer hero unit (Solari faction) - deploys turrets on asteroids\n     */\n    class TurretDeployer extends Unit {\n        constructor(position, owner) {\n            super(position, owner, Constants.TURRET_DEPLOYER_MAX_HEALTH, Constants.TURRET_DEPLOYER_ATTACK_RANGE, Constants.TURRET_DEPLOYER_ATTACK_DAMAGE, Constants.TURRET_DEPLOYER_ATTACK_SPEED, Constants.TURRET_DEPLOYER_ABILITY_COOLDOWN);\n            this.isHero = true; // TurretDeployer is a hero unit for Solari faction\n        }\n        /**\n         * Use Turret Deployer's turret placement ability\n         * The turret deployment will be handled by GameState which has access to asteroids\n         */\n        useAbility(direction) {\n            if (!super.useAbility(direction)) {\n                return false;\n            }\n            // Signal that ability was used, GameState will handle turret placement\n            return true;\n        }\n    }\n    return { TurretDeployer, DeployedTurret };\n};\n\n\n//# sourceURL=webpack://sol/./src/heroes/turret-deployer.ts?\n}");

/***/ },

/***/ "./src/main.ts"
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _game_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./game-core */ \"./src/game-core.ts\");\n/* harmony import */ var _renderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./renderer */ \"./src/renderer.ts\");\n/* harmony import */ var _menu__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./menu */ \"./src/menu.ts\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constants */ \"./src/constants.ts\");\n/**\n * Main entry point for SoL game\n */\n\n\n\n\nclass GameController {\n    /**\n     * Check if only hero units are currently selected\n     */\n    hasOnlyHeroUnitsSelected() {\n        return this.selectedUnits.size > 0 &&\n            Array.from(this.selectedUnits).every(unit => unit.isHero);\n    }\n    /**\n     * Check if a world position is near any selected unit\n     */\n    isDragStartNearSelectedUnits(worldPos) {\n        if (this.selectedUnits.size === 0)\n            return false;\n        for (const unit of this.selectedUnits) {\n            const distance = unit.position.distanceTo(worldPos);\n            if (distance <= _constants__WEBPACK_IMPORTED_MODULE_3__.UNIT_PATH_DRAW_RADIUS) {\n                return true;\n            }\n        }\n        return false;\n    }\n    getHeroUnitType(heroName) {\n        switch (heroName) {\n            case 'Marine':\n            case 'Grave':\n            case 'Ray':\n            case 'Dagger':\n            case 'Beam':\n            case 'Driller':\n                return heroName;\n            case 'Influence Ball':\n                return 'InfluenceBall';\n            case 'Turret Deployer':\n                return 'TurretDeployer';\n            default:\n                return null;\n        }\n    }\n    isHeroUnitOfType(unit, heroUnitType) {\n        switch (heroUnitType) {\n            case 'Marine':\n                return unit instanceof _game_core__WEBPACK_IMPORTED_MODULE_0__.Marine;\n            case 'Grave':\n                return unit instanceof _game_core__WEBPACK_IMPORTED_MODULE_0__.Grave;\n            case 'Ray':\n                return unit instanceof _game_core__WEBPACK_IMPORTED_MODULE_0__.Ray;\n            case 'InfluenceBall':\n                return unit instanceof _game_core__WEBPACK_IMPORTED_MODULE_0__.InfluenceBall;\n            case 'TurretDeployer':\n                return unit instanceof _game_core__WEBPACK_IMPORTED_MODULE_0__.TurretDeployer;\n            case 'Driller':\n                return unit instanceof _game_core__WEBPACK_IMPORTED_MODULE_0__.Driller;\n            case 'Dagger':\n                return unit instanceof _game_core__WEBPACK_IMPORTED_MODULE_0__.Dagger;\n            case 'Beam':\n                return unit instanceof _game_core__WEBPACK_IMPORTED_MODULE_0__.Beam;\n            default:\n                return false;\n        }\n    }\n    isHeroUnitAlive(player, heroUnitType) {\n        return player.units.some((unit) => this.isHeroUnitOfType(unit, heroUnitType));\n    }\n    isHeroUnitQueuedOrProducing(forge, heroUnitType) {\n        return forge.heroProductionUnitType === heroUnitType || forge.unitQueue.includes(heroUnitType);\n    }\n    getClickedHeroButton(screenX, screenY, forge, heroNames) {\n        // Convert forge position to screen space\n        const forgeScreenPos = this.renderer.worldToScreen(forge.position);\n        // Button measurements in screen space (affected by zoom)\n        const buttonRadius = _constants__WEBPACK_IMPORTED_MODULE_3__.HERO_BUTTON_RADIUS_PX * this.renderer.zoom;\n        const buttonDistance = _constants__WEBPACK_IMPORTED_MODULE_3__.HERO_BUTTON_DISTANCE_PX * this.renderer.zoom;\n        const positions = [\n            { x: 0, y: -1 },\n            { x: 1, y: 0 },\n            { x: 0, y: 1 },\n            { x: -1, y: 0 }\n        ];\n        const displayHeroes = heroNames.slice(0, positions.length);\n        for (let i = 0; i < displayHeroes.length; i++) {\n            const pos = positions[i];\n            // Calculate button position in screen space\n            const buttonScreenX = forgeScreenPos.x + pos.x * buttonDistance;\n            const buttonScreenY = forgeScreenPos.y + pos.y * buttonDistance;\n            // Check distance in screen space\n            const dx = screenX - buttonScreenX;\n            const dy = screenY - buttonScreenY;\n            const distance = Math.sqrt(dx * dx + dy * dy);\n            if (distance <= buttonRadius) {\n                // Convert button screen position back to world position for the wave effect\n                const buttonWorldPos = this.renderer.screenToWorld(buttonScreenX, buttonScreenY);\n                return { heroName: displayHeroes[i], buttonPos: buttonWorldPos };\n            }\n        }\n        return null;\n    }\n    clearPathPreview() {\n        this.pathPoints = [];\n        this.isDrawingPath = false;\n        this.renderer.pathPreviewForge = null;\n        this.renderer.pathPreviewPoints = this.pathPoints;\n        this.renderer.pathPreviewEnd = null;\n    }\n    toggleInGameMenu() {\n        this.showInGameMenu = !this.showInGameMenu;\n        this.isPaused = this.showInGameMenu;\n        this.renderer.showInGameMenu = this.showInGameMenu;\n        this.renderer.isPaused = this.isPaused;\n    }\n    toggleInfo() {\n        this.showInfo = !this.showInfo;\n        this.renderer.showInfo = this.showInfo;\n    }\n    surrender() {\n        if (!this.game)\n            return;\n        // Set player's forge health to 0 to trigger defeat\n        const player = this.game.players[0];\n        if (player.stellarForge) {\n            player.stellarForge.health = 0;\n        }\n        // Close menu\n        this.showInGameMenu = false;\n        this.isPaused = false;\n        this.renderer.showInGameMenu = false;\n        this.renderer.isPaused = false;\n        console.log('Player surrendered');\n    }\n    returnToMainMenu() {\n        // Stop the game\n        this.stop();\n        this.game = null;\n        // Clear selections\n        this.selectedUnits.clear();\n        this.selectedMirrors.clear();\n        this.selectedBase = null;\n        this.selectedBuildings.clear();\n        this.renderer.selectedUnits = this.selectedUnits;\n        // Reset states\n        this.isPaused = false;\n        this.showInGameMenu = false;\n        this.showInfo = this.menu.getSettings().isBattleStatsInfoEnabled;\n        this.renderer.showInGameMenu = false;\n        this.renderer.isPaused = false;\n        this.renderer.showInfo = this.showInfo;\n        // Show main menu\n        this.menu.show();\n    }\n    constructor() {\n        this.game = null;\n        this.lastTime = 0;\n        this.isRunning = false;\n        this.isPaused = false;\n        this.showInGameMenu = false;\n        this.showInfo = false;\n        this.holdStartTime = null;\n        this.holdPosition = null;\n        this.currentWarpGate = null;\n        this.isUsingMirrorsForWarpGate = false;\n        this.selectedUnits = new Set();\n        this.selectedMirrors = new Set(); // Set of SolarMirror\n        this.selectedBase = null; // StellarForge or null\n        this.selectedBuildings = new Set(); // Set of Building (Minigun/Cannon, SpaceDustSwirler, SubsidiaryFactory/Foundry)\n        this.isSelecting = false;\n        this.selectionStartScreen = null;\n        this.isDraggingHeroArrow = false; // Flag for hero arrow dragging\n        this.isDrawingPath = false; // Flag for drawing minion path from base\n        this.pathPoints = []; // Path waypoints being drawn\n        this.moveOrderCounter = 0; // Counter for move order indicators\n        // Create canvas\n        const canvas = document.getElementById('gameCanvas');\n        if (!canvas) {\n            throw new Error('Canvas element not found');\n        }\n        // Initialize renderer\n        this.renderer = new _renderer__WEBPACK_IMPORTED_MODULE_1__.GameRenderer(canvas);\n        // Create and show main menu\n        this.menu = new _menu__WEBPACK_IMPORTED_MODULE_2__.MainMenu();\n        this.menu.onStart((settings) => this.startNewGame(settings));\n        this.showInfo = this.menu.getSettings().isBattleStatsInfoEnabled;\n        this.renderer.showInfo = this.showInfo;\n        // Set up input handlers\n        this.setupInputHandlers(canvas);\n    }\n    startNewGame(settings) {\n        // Create game based on selected map\n        this.game = this.createGameFromSettings(settings);\n        this.renderer.selectedHeroNames = settings.selectedHeroNames;\n        // Set player and enemy colors from settings\n        this.renderer.playerColor = settings.playerColor;\n        this.renderer.enemyColor = settings.enemyColor;\n        // Set color scheme from settings\n        const colorScheme = _menu__WEBPACK_IMPORTED_MODULE_2__.COLOR_SCHEMES[settings.colorScheme];\n        if (colorScheme) {\n            this.renderer.colorScheme = colorScheme;\n        }\n        // Set damage and health display modes from settings\n        this.renderer.damageDisplayMode = settings.damageDisplayMode;\n        this.renderer.healthDisplayMode = settings.healthDisplayMode;\n        this.game.damageDisplayMode = settings.damageDisplayMode;\n        // Set graphics quality from settings\n        this.renderer.graphicsQuality = settings.graphicsQuality;\n        // Set up network manager for LAN play\n        if (settings.gameMode === 'lan' && settings.networkManager) {\n            // Determine local player index based on whether this client is the host\n            const isHost = settings.networkManager.isLobbyHost();\n            const localPlayerIndex = isHost ? 0 : 1;\n            // Set up AI flag for players (local player is not AI, remote player is not AI either)\n            this.game.players[0].isAi = false;\n            this.game.players[1].isAi = false;\n            // Set up network manager in game state\n            this.game.setupNetworkManager(settings.networkManager, localPlayerIndex);\n            console.log(`LAN mode: Local player is Player ${localPlayerIndex + 1} (${isHost ? 'Host' : 'Client'})`);\n        }\n        // Set the viewing player for the renderer (player 1 is the human player)\n        if (this.game.players.length > 0) {\n            this.renderer.viewingPlayer = this.game.players[0];\n            // Center camera on player's base and zoom in halfway\n            const player = this.game.players[0];\n            if (player.stellarForge) {\n                this.renderer.setCameraPosition(player.stellarForge.position);\n                this.renderer.setZoom(0.5); // Halfway zoomed in\n            }\n        }\n        this.showInfo = settings.isBattleStatsInfoEnabled;\n        this.renderer.showInfo = this.showInfo;\n        // Start game loop\n        this.start();\n    }\n    createGameFromSettings(settings) {\n        var _a, _b, _c;\n        const playerFaction = (_a = settings.selectedFaction) !== null && _a !== void 0 ? _a : _game_core__WEBPACK_IMPORTED_MODULE_0__.Faction.RADIANT;\n        const aiFaction = _game_core__WEBPACK_IMPORTED_MODULE_0__.Faction.RADIANT;\n        const colorScheme = _menu__WEBPACK_IMPORTED_MODULE_2__.COLOR_SCHEMES[settings.colorScheme];\n        const game = (0,_game_core__WEBPACK_IMPORTED_MODULE_0__.createStandardGame)([\n            ['Player 1', playerFaction],\n            ['Player 2', aiFaction]\n        ], colorScheme === null || colorScheme === void 0 ? void 0 : colorScheme.spaceDustPalette);\n        // Clear and recreate based on map settings\n        const map = settings.selectedMap;\n        // Set map size\n        game.mapSize = map.mapSize;\n        // Clear existing suns and add new ones based on map\n        game.suns = [];\n        if (map.id === 'twin-suns') {\n            // Two suns positioned diagonally\n            game.suns.push(new _game_core__WEBPACK_IMPORTED_MODULE_0__.Sun(new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(-300, -300), 1.0, 100.0));\n            game.suns.push(new _game_core__WEBPACK_IMPORTED_MODULE_0__.Sun(new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(300, 300), 1.0, 100.0));\n        }\n        else if (map.id === 'test-level') {\n            // Single sun at center for test level\n            game.suns.push(new _game_core__WEBPACK_IMPORTED_MODULE_0__.Sun(new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(0, 0), 1.0, 100.0));\n        }\n        else {\n            // Single sun at center (default for all other maps)\n            game.suns.push(new _game_core__WEBPACK_IMPORTED_MODULE_0__.Sun(new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(0, 0), 1.0, 100.0));\n        }\n        if (map.id === 'test-level') {\n            const leftForgePosition = new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(-700, 0);\n            const rightForgePosition = new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(700, 0);\n            const mirrorOffset = _constants__WEBPACK_IMPORTED_MODULE_3__.MIRROR_COUNTDOWN_DEPLOY_DISTANCE;\n            const mirrorPositionsLeft = [\n                new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(leftForgePosition.x, leftForgePosition.y - mirrorOffset),\n                new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(leftForgePosition.x, leftForgePosition.y + mirrorOffset)\n            ];\n            const mirrorPositionsRight = [\n                new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(rightForgePosition.x, rightForgePosition.y - mirrorOffset),\n                new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(rightForgePosition.x, rightForgePosition.y + mirrorOffset)\n            ];\n            const playerPositions = [leftForgePosition, rightForgePosition];\n            const mirrorPositions = [mirrorPositionsLeft, mirrorPositionsRight];\n            for (let i = 0; i < game.players.length; i++) {\n                const player = game.players[i];\n                const forgePosition = (_b = playerPositions[i]) !== null && _b !== void 0 ? _b : leftForgePosition;\n                const mirrorPositionSet = (_c = mirrorPositions[i]) !== null && _c !== void 0 ? _c : mirrorPositionsLeft;\n                player.stellarForge = null;\n                player.solarMirrors = [];\n                game.initializePlayer(player, forgePosition, mirrorPositionSet);\n            }\n            if (game.players.length >= 2) {\n                const player = game.players[0];\n                const enemyPlayer = game.players[1];\n                if (player.stellarForge && enemyPlayer.stellarForge) {\n                    player.stellarForge.initializeDefaultPath(enemyPlayer.stellarForge.position);\n                    enemyPlayer.stellarForge.initializeDefaultPath(player.stellarForge.position);\n                }\n            }\n            game.asteroids = [];\n            game.spaceDust = [];\n            return game;\n        }\n        // Reinitialize asteroids based on map (keeps strategic asteroids from createStandardGame)\n        // Clear only the random asteroids (first 10), keep the strategic ones (last 2)\n        const strategicAsteroids = game.asteroids.slice(-2); // Keep last 2 strategic asteroids\n        game.asteroids = [];\n        game.initializeAsteroids(map.numAsteroids, map.mapSize, map.mapSize);\n        // For standard map, add strategic asteroids back\n        if (map.id === 'standard') {\n            game.asteroids.push(...strategicAsteroids);\n        }\n        // Reinitialize space dust\n        game.spaceDust = [];\n        const particleCount = map.id === 'test-level' ? 3000 : _constants__WEBPACK_IMPORTED_MODULE_3__.SPACE_DUST_PARTICLE_COUNT;\n        game.initializeSpaceDust(particleCount, map.mapSize, map.mapSize, colorScheme === null || colorScheme === void 0 ? void 0 : colorScheme.spaceDustPalette);\n        return game;\n    }\n    setupInputHandlers(canvas) {\n        // Helper function to detect mobile/tablet devices\n        const isMobileDevice = () => {\n            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)\n                || ('ontouchstart' in window);\n        };\n        const getCanvasPosition = (clientX, clientY) => {\n            const rect = canvas.getBoundingClientRect();\n            return {\n                x: clientX - rect.left,\n                y: clientY - rect.top\n            };\n        };\n        // Touch/Mouse support for mobile and desktop\n        let isPanning = false;\n        let isMouseDown = false;\n        let lastX = 0;\n        let lastY = 0;\n        let lastMouseX = 0;\n        let lastMouseY = 0;\n        let lastPinchDistance = 0;\n        // Edge panning constants (desktop only)\n        const EDGE_PAN_THRESHOLD = 20; // pixels from edge\n        const EDGE_PAN_SPEED = 5; // pixels per frame\n        // Mobile touch constants\n        const PINCH_ZOOM_THRESHOLD = 1; // minimum pixel change to trigger zoom\n        // Store mobile detection result\n        const isMobile = isMobileDevice();\n        // Keyboard panning state\n        const keysPressed = new Set();\n        // Mouse wheel zoom - zoom towards cursor\n        canvas.addEventListener('wheel', (e) => {\n            e.preventDefault();\n            if (this.showInGameMenu) {\n                const menuPos = getCanvasPosition(e.clientX, e.clientY);\n                const didScrollMenu = this.renderer.handleInGameMenuScroll(menuPos.x, menuPos.y, e.deltaY);\n                if (didScrollMenu) {\n                    return;\n                }\n            }\n            const screenPos = getCanvasPosition(e.clientX, e.clientY);\n            // Get world position under mouse before zoom\n            const worldPosBeforeZoom = this.renderer.screenToWorld(screenPos.x, screenPos.y);\n            // Apply zoom\n            const zoomDelta = e.deltaY > 0 ? 0.9 : 1.1;\n            const oldZoom = this.renderer.zoom;\n            this.renderer.setZoom(oldZoom * zoomDelta);\n            // Get world position under mouse after zoom\n            const worldPosAfterZoom = this.renderer.screenToWorld(screenPos.x, screenPos.y);\n            // Adjust camera to keep world position under cursor the same\n            const currentCamera = this.renderer.camera;\n            this.renderer.setCameraPositionWithoutParallax(new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(currentCamera.x + (worldPosBeforeZoom.x - worldPosAfterZoom.x), currentCamera.y + (worldPosBeforeZoom.y - worldPosAfterZoom.y)));\n        });\n        // Touch/Mouse selection and pan\n        const startDrag = (x, y) => {\n            lastX = x;\n            lastY = y;\n            this.selectionStartScreen = new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(x, y);\n            this.isSelecting = false;\n            // Start warp gate hold timer\n            const worldPos = this.renderer.screenToWorld(x, y);\n            this.startHold(worldPos);\n        };\n        const moveDrag = (x, y, isTwoFinger = false) => {\n            var _a;\n            if (!isMouseDown) {\n                // Not dragging, just tracking mouse position\n                lastX = x;\n                lastY = y;\n                return;\n            }\n            const dx = x - lastX;\n            const dy = y - lastY;\n            const totalMovement = Math.sqrt(dx * dx + dy * dy);\n            // Two-finger touch should always pan the camera immediately (no threshold)\n            // This provides smooth, native-like panning behavior on mobile devices\n            if (isTwoFinger) {\n                if (!isPanning) {\n                    isPanning = true;\n                    this.cancelHold();\n                    this.renderer.selectionStart = null;\n                    this.renderer.selectionEnd = null;\n                }\n                // Update camera position (inverted for natural panning)\n                const currentCamera = this.renderer.camera;\n                this.renderer.setCameraPosition(new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(currentCamera.x - dx / this.renderer.zoom, currentCamera.y - dy / this.renderer.zoom));\n            }\n            else if (totalMovement > _constants__WEBPACK_IMPORTED_MODULE_3__.CLICK_DRAG_THRESHOLD) {\n                // Single-finger/mouse drag needs a threshold to distinguish from taps\n                // Check if only hero units are selected - if so, show arrow instead of selection box\n                const hasOnlyHeroUnits = this.hasOnlyHeroUnitsSelected();\n                if (!this.isSelecting && !isPanning && !this.isDraggingHeroArrow && !this.isDrawingPath) {\n                    if (this.selectedBase && this.selectedBase.isSelected) {\n                        // Drawing a path from the selected base\n                        this.isDrawingPath = true;\n                        this.pathPoints = [];\n                        this.renderer.pathPreviewForge = this.selectedBase;\n                        this.renderer.pathPreviewPoints = this.pathPoints;\n                        this.cancelHold();\n                    }\n                    else if (this.selectedUnits.size > 0 && this.selectionStartScreen) {\n                        // Check if drag started near selected units - if so, draw movement path\n                        const dragStartWorld = this.renderer.screenToWorld(this.selectionStartScreen.x, this.selectionStartScreen.y);\n                        if (this.isDragStartNearSelectedUnits(dragStartWorld)) {\n                            // Drawing a movement path for selected units\n                            this.isDrawingPath = true;\n                            this.pathPoints = [];\n                            this.renderer.pathPreviewForge = null; // No forge for unit paths\n                            this.renderer.pathPreviewPoints = this.pathPoints;\n                            this.cancelHold();\n                        }\n                        else if (hasOnlyHeroUnits) {\n                            // For hero units away from units, use arrow dragging mode\n                            this.isDraggingHeroArrow = true;\n                            this.cancelHold();\n                        }\n                        else {\n                            // For regular (non-hero) units when drag doesn't start near them, use selection rectangle\n                            this.isSelecting = true;\n                            this.cancelHold();\n                        }\n                    }\n                    else if (hasOnlyHeroUnits) {\n                        // For hero units, use arrow dragging mode\n                        this.isDraggingHeroArrow = true;\n                        this.cancelHold();\n                    }\n                    else {\n                        // For regular units or no selection, use selection rectangle\n                        this.isSelecting = true;\n                        this.cancelHold();\n                    }\n                }\n            }\n            // Update visual feedback continuously (not just when threshold exceeded)\n            // This fixes the janky rectangle/arrow update issue\n            if (this.isSelecting) {\n                // Update selection rectangle (for normal unit selection)\n                this.renderer.selectionStart = this.selectionStartScreen;\n                this.renderer.selectionEnd = new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(x, y);\n            }\n            else if (this.isDraggingHeroArrow) {\n                // Update arrow direction (for hero ability casting)\n                this.renderer.abilityArrowStart = this.selectionStartScreen;\n                this.renderer.abilityArrowEnd = new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(x, y);\n            }\n            else if (this.isDrawingPath) {\n                // Collect path waypoints as we drag\n                const worldPos = this.renderer.screenToWorld(x, y);\n                // Add waypoint if we've moved far enough from the last one\n                if (this.pathPoints.length === 0 ||\n                    this.pathPoints[this.pathPoints.length - 1].distanceTo(worldPos) > _constants__WEBPACK_IMPORTED_MODULE_3__.MIN_WAYPOINT_DISTANCE) {\n                    // Check if this position is inside a solid object\n                    const isInsideSolid = ((_a = this.game) === null || _a === void 0 ? void 0 : _a.checkCollision(worldPos, 0)) || false;\n                    if (!isInsideSolid) {\n                        // Only add waypoint if not inside solid object\n                        this.pathPoints.push(new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(worldPos.x, worldPos.y));\n                    }\n                }\n                // pathPreviewForge was already set when initiating path drawing (selectedBase for base paths, null for unit paths)\n                this.renderer.pathPreviewPoints = this.pathPoints;\n                this.renderer.pathPreviewEnd = new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(worldPos.x, worldPos.y);\n            }\n            lastX = x;\n            lastY = y;\n        };\n        const endDrag = () => {\n            // Check if this was a simple click (no dragging)\n            const wasClick = this.selectionStartScreen &&\n                Math.abs(lastX - this.selectionStartScreen.x) < _constants__WEBPACK_IMPORTED_MODULE_3__.CLICK_DRAG_THRESHOLD &&\n                Math.abs(lastY - this.selectionStartScreen.y) < _constants__WEBPACK_IMPORTED_MODULE_3__.CLICK_DRAG_THRESHOLD;\n            // Handle UI clicks first\n            if (wasClick && this.game) {\n                const winner = this.game.checkVictoryConditions();\n                // Check menu button click (top-left, 60x60 area including margin)\n                if (!winner && !this.game.isCountdownActive && lastX <= 70 && lastY <= 70) {\n                    this.toggleInGameMenu();\n                    isPanning = false;\n                    isMouseDown = false;\n                    this.isSelecting = false;\n                    this.selectionStartScreen = null;\n                    this.renderer.selectionStart = null;\n                    this.renderer.selectionEnd = null;\n                    this.endHold();\n                    return;\n                }\n                // Check in-game menu clicks\n                if (this.showInGameMenu && !winner) {\n                    const menuAction = this.renderer.getInGameMenuAction(lastX, lastY);\n                    if (menuAction) {\n                        switch (menuAction.type) {\n                            case 'resume':\n                                this.toggleInGameMenu();\n                                break;\n                            case 'toggleInfo':\n                                this.toggleInfo();\n                                break;\n                            case 'surrender':\n                                this.surrender();\n                                break;\n                            case 'tab':\n                                this.renderer.setInGameMenuTab(menuAction.tab);\n                                break;\n                            case 'graphicsVariant':\n                                this.renderer.setGraphicsVariant(menuAction.key, menuAction.variant);\n                                break;\n                            case 'damageDisplayMode':\n                                this.renderer.damageDisplayMode = menuAction.mode;\n                                if (this.game) {\n                                    this.game.damageDisplayMode = menuAction.mode;\n                                }\n                                break;\n                            case 'healthDisplayMode':\n                                this.renderer.healthDisplayMode = menuAction.mode;\n                                break;\n                            default:\n                                break;\n                        }\n                        isPanning = false;\n                        isMouseDown = false;\n                        this.isSelecting = false;\n                        this.selectionStartScreen = null;\n                        this.renderer.selectionStart = null;\n                        this.renderer.selectionEnd = null;\n                        this.endHold();\n                        return;\n                    }\n                }\n                // Check end-game Continue button\n                if (winner) {\n                    const dpr = window.devicePixelRatio || 1;\n                    const screenWidth = this.renderer.canvas.width / dpr;\n                    const screenHeight = this.renderer.canvas.height / dpr;\n                    const panelHeight = 450;\n                    const panelY = 130;\n                    const buttonWidth = 300;\n                    const buttonHeight = 60;\n                    const buttonX = (screenWidth - buttonWidth) / 2;\n                    const buttonY = panelY + panelHeight + 30;\n                    if (lastX >= buttonX && lastX <= buttonX + buttonWidth &&\n                        lastY >= buttonY && lastY <= buttonY + buttonHeight) {\n                        this.returnToMainMenu();\n                        isPanning = false;\n                        isMouseDown = false;\n                        this.isSelecting = false;\n                        this.selectionStartScreen = null;\n                        this.renderer.selectionStart = null;\n                        this.renderer.selectionEnd = null;\n                        this.endHold();\n                        return;\n                    }\n                }\n            }\n            // Create tap visual effect for clicks\n            if (wasClick && this.selectionStartScreen) {\n                this.renderer.createTapEffect(lastX, lastY);\n            }\n            if (this.game && wasClick) {\n                const worldPos = this.renderer.screenToWorld(lastX, lastY);\n                const player = this.game.players[0]; // Assume player 1 is human\n                // Check if clicked on stellar forge\n                if (player.stellarForge && player.stellarForge.containsPoint(worldPos)) {\n                    if (player.stellarForge.isSelected) {\n                        // Deselect forge\n                        player.stellarForge.isSelected = false;\n                        this.selectedBase = null;\n                        this.clearPathPreview();\n                        console.log('Stellar Forge deselected');\n                    }\n                    else {\n                        // Select forge, deselect units, mirrors, and buildings\n                        player.stellarForge.isSelected = true;\n                        this.selectedBase = player.stellarForge;\n                        this.selectedUnits.clear();\n                        this.selectedMirrors.clear();\n                        this.renderer.selectedUnits = this.selectedUnits;\n                        // Deselect all mirrors\n                        for (const mirror of player.solarMirrors) {\n                            mirror.isSelected = false;\n                        }\n                        // Deselect all buildings\n                        for (const building of player.buildings) {\n                            building.isSelected = false;\n                        }\n                        this.selectedBuildings.clear();\n                        this.clearPathPreview();\n                        console.log('Stellar Forge selected');\n                    }\n                    isPanning = false;\n                    isMouseDown = false;\n                    this.isSelecting = false;\n                    this.selectionStartScreen = null;\n                    this.renderer.selectionStart = null;\n                    this.renderer.selectionEnd = null;\n                    this.endHold();\n                    return;\n                }\n                // Check if clicked on a solar mirror\n                let clickedMirror = null;\n                for (const mirror of player.solarMirrors) {\n                    if (mirror.containsPoint(worldPos)) {\n                        clickedMirror = mirror;\n                        break;\n                    }\n                }\n                if (clickedMirror) {\n                    if (clickedMirror.isSelected) {\n                        // Deselect mirror\n                        clickedMirror.isSelected = false;\n                        this.selectedMirrors.delete(clickedMirror);\n                        this.clearPathPreview();\n                        console.log('Solar Mirror deselected');\n                    }\n                    else {\n                        // Select mirror, deselect forge, units, and buildings\n                        clickedMirror.isSelected = true;\n                        this.selectedMirrors.clear();\n                        this.selectedMirrors.add(clickedMirror);\n                        if (player.stellarForge) {\n                            player.stellarForge.isSelected = false;\n                        }\n                        this.selectedBase = null;\n                        this.selectedUnits.clear();\n                        this.renderer.selectedUnits = this.selectedUnits;\n                        // Deselect other mirrors\n                        for (const mirror of player.solarMirrors) {\n                            if (mirror !== clickedMirror) {\n                                mirror.isSelected = false;\n                            }\n                        }\n                        // Deselect all buildings\n                        for (const building of player.buildings) {\n                            building.isSelected = false;\n                        }\n                        this.selectedBuildings.clear();\n                        this.clearPathPreview();\n                        console.log('Solar Mirror selected');\n                    }\n                    isPanning = false;\n                    isMouseDown = false;\n                    this.isSelecting = false;\n                    this.selectionStartScreen = null;\n                    this.renderer.selectionStart = null;\n                    this.renderer.selectionEnd = null;\n                    this.endHold();\n                    return;\n                }\n                // Check if clicked on a building\n                let clickedBuilding = null;\n                for (const building of player.buildings) {\n                    if (building.containsPoint(worldPos)) {\n                        clickedBuilding = building;\n                        break;\n                    }\n                }\n                if (clickedBuilding) {\n                    if (clickedBuilding.isSelected) {\n                        // Deselect building\n                        clickedBuilding.isSelected = false;\n                        this.selectedBuildings.delete(clickedBuilding);\n                        console.log('Building deselected');\n                    }\n                    else {\n                        // Select building, deselect forge, units, and mirrors\n                        clickedBuilding.isSelected = true;\n                        this.selectedBuildings.clear();\n                        this.selectedBuildings.add(clickedBuilding);\n                        if (player.stellarForge) {\n                            player.stellarForge.isSelected = false;\n                        }\n                        this.selectedBase = null;\n                        this.selectedUnits.clear();\n                        this.renderer.selectedUnits = this.selectedUnits;\n                        // Deselect all mirrors\n                        for (const mirror of player.solarMirrors) {\n                            mirror.isSelected = false;\n                        }\n                        this.selectedMirrors.clear();\n                        this.clearPathPreview();\n                        console.log('Building selected');\n                    }\n                    isPanning = false;\n                    isMouseDown = false;\n                    this.isSelecting = false;\n                    this.selectionStartScreen = null;\n                    this.renderer.selectionStart = null;\n                    this.renderer.selectionEnd = null;\n                    this.endHold();\n                    return;\n                }\n                // Check if clicked on a warp gate button\n                for (const gate of this.game.warpGates) {\n                    if (!gate.isComplete)\n                        continue;\n                    // Check if player owns this gate\n                    if (gate.owner !== player)\n                        continue;\n                    // Convert gate position to screen space\n                    const gateScreenPos = this.renderer.worldToScreen(gate.position);\n                    // Calculate button positions in screen space (matching renderer)\n                    const maxRadius = _constants__WEBPACK_IMPORTED_MODULE_3__.WARP_GATE_RADIUS * this.renderer.zoom;\n                    const buttonRadius = _constants__WEBPACK_IMPORTED_MODULE_3__.WARP_GATE_BUTTON_RADIUS * this.renderer.zoom;\n                    const buttonDistance = maxRadius + _constants__WEBPACK_IMPORTED_MODULE_3__.WARP_GATE_BUTTON_OFFSET * this.renderer.zoom;\n                    const angles = [0, Math.PI / 2, Math.PI, 3 * Math.PI / 2];\n                    const labels = ['Cannon', 'Swirler', 'Foundry', 'Locked'];\n                    for (let i = 0; i < 4; i++) {\n                        const angle = angles[i];\n                        // Calculate button position in screen space\n                        const buttonScreenX = gateScreenPos.x + Math.cos(angle) * buttonDistance;\n                        const buttonScreenY = gateScreenPos.y + Math.sin(angle) * buttonDistance;\n                        // Check distance in screen space\n                        const dx = lastX - buttonScreenX;\n                        const dy = lastY - buttonScreenY;\n                        const distance = Math.sqrt(dx * dx + dy * dy);\n                        if (distance <= buttonRadius) {\n                            // Convert button screen position to world position for the wave effect\n                            const buttonWorldPos = this.renderer.screenToWorld(buttonScreenX, buttonScreenY);\n                            this.renderer.createProductionButtonWave(buttonWorldPos);\n                            console.log(`Warp gate button clicked: ${labels[i]} (index ${i}) | energy=${player.energy.toFixed(1)}`);\n                            // Button clicked!\n                            if (i === 0) {\n                                // First button - create Cannon building\n                                if (player.spendEnergy(_constants__WEBPACK_IMPORTED_MODULE_3__.MINIGUN_COST)) {\n                                    const minigun = new _game_core__WEBPACK_IMPORTED_MODULE_0__.Minigun(new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(gate.position.x, gate.position.y), player);\n                                    player.buildings.push(minigun);\n                                    console.log(`Cannon building queued at warp gate (${gate.position.x.toFixed(0)}, ${gate.position.y.toFixed(0)})`);\n                                    // Emit shockwave when building starts warping in\n                                    this.scatterParticles(gate.position);\n                                    // Remove the warp gate (implode effect)\n                                    const gateIndex = this.game.warpGates.indexOf(gate);\n                                    if (gateIndex > -1) {\n                                        this.game.warpGates.splice(gateIndex, 1);\n                                    }\n                                    if (this.currentWarpGate === gate) {\n                                        this.currentWarpGate = null;\n                                    }\n                                    this.implodeParticles(gate.position);\n                                }\n                                else {\n                                    console.log('Not enough energy to build Cannon');\n                                }\n                            }\n                            else if (i === 1) {\n                                // Second button - create Space Dust Swirler building\n                                if (player.spendEnergy(_constants__WEBPACK_IMPORTED_MODULE_3__.SWIRLER_COST)) {\n                                    const swirler = new _game_core__WEBPACK_IMPORTED_MODULE_0__.SpaceDustSwirler(new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(gate.position.x, gate.position.y), player);\n                                    player.buildings.push(swirler);\n                                    console.log(`Space Dust Swirler building queued at warp gate (${gate.position.x.toFixed(0)}, ${gate.position.y.toFixed(0)})`);\n                                    // Emit shockwave when building starts warping in\n                                    this.scatterParticles(gate.position);\n                                    // Remove the warp gate (implode effect)\n                                    const gateIndex = this.game.warpGates.indexOf(gate);\n                                    if (gateIndex > -1) {\n                                        this.game.warpGates.splice(gateIndex, 1);\n                                    }\n                                    if (this.currentWarpGate === gate) {\n                                        this.currentWarpGate = null;\n                                    }\n                                    this.implodeParticles(gate.position);\n                                }\n                                else {\n                                    console.log('Not enough energy to build Space Dust Swirler');\n                                }\n                            }\n                            else if (i === 2) {\n                                // Third button (bottom) - create Foundry building\n                                // Check if player already has a Foundry\n                                const hasSubFactory = player.buildings.some((building) => building instanceof _game_core__WEBPACK_IMPORTED_MODULE_0__.SubsidiaryFactory);\n                                if (hasSubFactory) {\n                                    console.log('Only one Foundry can exist at a time');\n                                }\n                                else if (player.spendEnergy(_constants__WEBPACK_IMPORTED_MODULE_3__.SUBSIDIARY_FACTORY_COST)) {\n                                    const subFactory = new _game_core__WEBPACK_IMPORTED_MODULE_0__.SubsidiaryFactory(new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(gate.position.x, gate.position.y), player);\n                                    player.buildings.push(subFactory);\n                                    console.log(`Foundry building queued at warp gate (${gate.position.x.toFixed(0)}, ${gate.position.y.toFixed(0)})`);\n                                    // Emit shockwave when building starts warping in\n                                    this.scatterParticles(gate.position);\n                                    // Remove the warp gate (implode effect)\n                                    const gateIndex = this.game.warpGates.indexOf(gate);\n                                    if (gateIndex > -1) {\n                                        this.game.warpGates.splice(gateIndex, 1);\n                                    }\n                                    if (this.currentWarpGate === gate) {\n                                        this.currentWarpGate = null;\n                                    }\n                                    this.implodeParticles(gate.position);\n                                }\n                                else {\n                                    console.log('Not enough energy to build Foundry');\n                                }\n                            }\n                            // Other buttons can be added later for different building types\n                            isPanning = false;\n                            isMouseDown = false;\n                            this.isSelecting = false;\n                            this.selectionStartScreen = null;\n                            this.renderer.selectionStart = null;\n                            this.renderer.selectionEnd = null;\n                            this.endHold();\n                            return;\n                        }\n                    }\n                }\n                if (player.stellarForge && player.stellarForge.isSelected && this.renderer.selectedHeroNames.length > 0) {\n                    const clickedHero = this.getClickedHeroButton(lastX, lastY, player.stellarForge, this.renderer.selectedHeroNames);\n                    if (clickedHero) {\n                        const clickedHeroName = clickedHero.heroName;\n                        this.renderer.createProductionButtonWave(clickedHero.buttonPos);\n                        const heroUnitType = this.getHeroUnitType(clickedHeroName);\n                        let isHeroQueued = false;\n                        if (heroUnitType) {\n                            const isHeroAlive = this.isHeroUnitAlive(player, heroUnitType);\n                            const isHeroProducing = this.isHeroUnitQueuedOrProducing(player.stellarForge, heroUnitType);\n                            console.log(`Hero button clicked: ${clickedHeroName} | unitType=${heroUnitType} | alive=${isHeroAlive} | producing=${isHeroProducing} | energy=${player.energy.toFixed(1)}`);\n                            if (isHeroAlive) {\n                                console.log(`${clickedHeroName} is already active`);\n                            }\n                            else if (isHeroProducing) {\n                                console.log(`${clickedHeroName} is already being produced`);\n                            }\n                            else if (player.spendEnergy(_constants__WEBPACK_IMPORTED_MODULE_3__.HERO_UNIT_COST)) {\n                                player.stellarForge.enqueueHeroUnit(heroUnitType);\n                                player.stellarForge.startHeroProductionIfIdle();\n                                console.log(`Queued hero ${clickedHeroName} for forging`);\n                                isHeroQueued = true;\n                            }\n                            else {\n                                console.log('Not enough energy to forge hero');\n                            }\n                        }\n                        if (isHeroQueued) {\n                            player.stellarForge.isSelected = false;\n                            this.selectedBase = null;\n                            this.selectedUnits.clear();\n                            this.selectedMirrors.clear();\n                            this.renderer.selectedUnits = this.selectedUnits;\n                            // Deselect all buildings\n                            for (const building of player.buildings) {\n                                building.isSelected = false;\n                            }\n                            this.selectedBuildings.clear();\n                            this.clearPathPreview();\n                        }\n                        isPanning = false;\n                        isMouseDown = false;\n                        this.isSelecting = false;\n                        this.selectionStartScreen = null;\n                        this.renderer.selectionStart = null;\n                        this.renderer.selectionEnd = null;\n                        this.endHold();\n                        return;\n                    }\n                }\n                // If forge is selected and clicked elsewhere, move it\n                if (player.stellarForge && player.stellarForge.isSelected) {\n                    player.stellarForge.setTarget(worldPos);\n                    player.stellarForge.isSelected = false; // Auto-deselect after setting target\n                    this.selectedBase = null;\n                    this.selectedUnits.clear();\n                    this.selectedMirrors.clear();\n                    this.renderer.selectedUnits = this.selectedUnits;\n                    // Deselect all buildings\n                    for (const building of player.buildings) {\n                        building.isSelected = false;\n                    }\n                    this.selectedBuildings.clear();\n                    console.log(`Stellar Forge moving to (${worldPos.x.toFixed(0)}, ${worldPos.y.toFixed(0)})`);\n                    isPanning = false;\n                    isMouseDown = false;\n                    this.isSelecting = false;\n                    this.selectionStartScreen = null;\n                    this.renderer.selectionStart = null;\n                    this.renderer.selectionEnd = null;\n                    this.endHold();\n                    return;\n                }\n                // If a mirror is selected and clicked elsewhere, move it\n                const selectedMirror = player.solarMirrors.find(m => m.isSelected);\n                if (selectedMirror) {\n                    selectedMirror.setTarget(worldPos);\n                    selectedMirror.isSelected = false; // Auto-deselect after setting target\n                    this.selectedBase = null;\n                    this.selectedUnits.clear();\n                    this.selectedMirrors.clear();\n                    this.renderer.selectedUnits = this.selectedUnits;\n                    // Deselect all buildings\n                    for (const building of player.buildings) {\n                        building.isSelected = false;\n                    }\n                    this.selectedBuildings.clear();\n                    console.log(`Solar Mirror moving to (${worldPos.x.toFixed(0)}, ${worldPos.y.toFixed(0)})`);\n                    isPanning = false;\n                    isMouseDown = false;\n                    this.isSelecting = false;\n                    this.selectionStartScreen = null;\n                    this.renderer.selectionStart = null;\n                    this.renderer.selectionEnd = null;\n                    this.endHold();\n                    return;\n                }\n            }\n            // If we were selecting, finalize the selection\n            if (this.isSelecting && this.selectionStartScreen && this.game) {\n                const endPos = new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(lastX, lastY);\n                this.selectUnitsInRectangle(this.selectionStartScreen, endPos);\n            }\n            else if (this.isDrawingPath && this.pathPoints.length > 0 && this.game) {\n                // Finalize the path drawing\n                if (this.selectedBase && this.selectedBase.isSelected) {\n                    // Path for base (minion spawning)\n                    this.selectedBase.setMinionPath(this.pathPoints);\n                    console.log(`Base path set with ${this.pathPoints.length} waypoints`);\n                }\n                else if (this.selectedUnits.size > 0) {\n                    // Path for selected units\n                    console.log(`Unit movement path set with ${this.pathPoints.length} waypoints for ${this.selectedUnits.size} unit(s)`);\n                    // Increment move order counter\n                    this.moveOrderCounter++;\n                    // Set path for all selected units\n                    for (const unit of this.selectedUnits) {\n                        // All units now support path following\n                        unit.setPath(this.pathPoints);\n                        unit.moveOrder = this.moveOrderCounter;\n                    }\n                    // Deselect units and buildings after setting path\n                    this.selectedUnits.clear();\n                    this.renderer.selectedUnits = this.selectedUnits;\n                    const player = this.game.players[0];\n                    if (player) {\n                        for (const building of player.buildings) {\n                            building.isSelected = false;\n                        }\n                        this.selectedBuildings.clear();\n                    }\n                }\n                this.clearPathPreview();\n            }\n            else if (!this.isSelecting && (this.selectedUnits.size > 0 || this.selectedMirrors.size > 0 || this.selectedBase) && this.selectionStartScreen && this.game) {\n                // If units, mirrors, or base are selected and player dragged/clicked\n                const endPos = new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(lastX, lastY);\n                const totalMovement = this.selectionStartScreen.distanceTo(endPos);\n                const abilityDragThreshold = Math.max(_constants__WEBPACK_IMPORTED_MODULE_3__.CLICK_DRAG_THRESHOLD, _constants__WEBPACK_IMPORTED_MODULE_3__.ABILITY_ARROW_MIN_LENGTH);\n                const hasOnlyHeroUnits = this.hasOnlyHeroUnitsSelected();\n                const shouldUseAbility = this.selectedUnits.size > 0 && ((!hasOnlyHeroUnits && totalMovement >= _constants__WEBPACK_IMPORTED_MODULE_3__.CLICK_DRAG_THRESHOLD) ||\n                    (hasOnlyHeroUnits && this.isDraggingHeroArrow && totalMovement >= abilityDragThreshold));\n                // If dragged significantly, use ability (for units only)\n                if (shouldUseAbility) {\n                    // Only create swipe effect for non-hero units\n                    if (!hasOnlyHeroUnits) {\n                        this.renderer.createSwipeEffect(this.selectionStartScreen.x, this.selectionStartScreen.y, endPos.x, endPos.y);\n                    }\n                    // Calculate swipe direction\n                    const dx = endPos.x - this.selectionStartScreen.x;\n                    const dy = endPos.y - this.selectionStartScreen.y;\n                    const distance = Math.sqrt(dx * dx + dy * dy);\n                    const direction = new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(dx / distance, dy / distance);\n                    // Activate ability for all selected units\n                    let anyAbilityUsed = false;\n                    for (const unit of this.selectedUnits) {\n                        if (unit.useAbility(direction)) {\n                            anyAbilityUsed = true;\n                        }\n                    }\n                    if (anyAbilityUsed) {\n                        console.log(`Ability activated in direction (${direction.x.toFixed(2)}, ${direction.y.toFixed(2)})`);\n                    }\n                    // Deselect all units after using ability\n                    this.selectedUnits.clear();\n                    this.renderer.selectedUnits = this.selectedUnits;\n                }\n                else {\n                    // If movement was minimal or only mirrors/base selected, set movement targets\n                    const worldPos = this.renderer.screenToWorld(lastX, lastY);\n                    // Increment move order counter\n                    this.moveOrderCounter++;\n                    // Set rally point for all selected units\n                    for (const unit of this.selectedUnits) {\n                        const rallyPoint = new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(worldPos.x, worldPos.y);\n                        if (unit instanceof _game_core__WEBPACK_IMPORTED_MODULE_0__.Starling) {\n                            unit.setManualRallyPoint(rallyPoint);\n                        }\n                        else {\n                            unit.rallyPoint = rallyPoint;\n                        }\n                        unit.moveOrder = this.moveOrderCounter;\n                    }\n                    // Set target for all selected mirrors\n                    for (const mirror of this.selectedMirrors) {\n                        mirror.setTarget(new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(worldPos.x, worldPos.y));\n                        mirror.moveOrder = this.moveOrderCounter;\n                        mirror.isSelected = false;\n                    }\n                    // Set target for selected base\n                    if (this.selectedBase) {\n                        this.selectedBase.setTarget(new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(worldPos.x, worldPos.y));\n                        this.selectedBase.moveOrder = this.moveOrderCounter;\n                        this.selectedBase.isSelected = false;\n                    }\n                    // Deselect all units immediately\n                    this.selectedUnits.clear();\n                    this.selectedMirrors.clear();\n                    this.selectedBase = null;\n                    this.renderer.selectedUnits = this.selectedUnits;\n                    console.log(`Movement target set at (${worldPos.x.toFixed(0)}, ${worldPos.y.toFixed(0)}) - Move order #${this.moveOrderCounter}`);\n                }\n            }\n            isPanning = false;\n            isMouseDown = false;\n            this.isSelecting = false;\n            this.isDraggingHeroArrow = false;\n            this.isDrawingPath = false;\n            this.pathPoints = [];\n            this.selectionStartScreen = null;\n            this.renderer.selectionStart = null;\n            this.renderer.selectionEnd = null;\n            this.renderer.abilityArrowStart = null;\n            this.renderer.abilityArrowEnd = null;\n            this.endHold();\n        };\n        // Mouse events\n        canvas.addEventListener('mousedown', (e) => {\n            isMouseDown = true;\n            const screenPos = getCanvasPosition(e.clientX, e.clientY);\n            startDrag(screenPos.x, screenPos.y);\n        });\n        canvas.addEventListener('mousemove', (e) => {\n            const screenPos = getCanvasPosition(e.clientX, e.clientY);\n            lastMouseX = screenPos.x;\n            lastMouseY = screenPos.y;\n            moveDrag(screenPos.x, screenPos.y, false);\n        });\n        canvas.addEventListener('mouseup', () => {\n            endDrag();\n        });\n        canvas.addEventListener('mouseleave', () => {\n            endDrag();\n        });\n        // Touch events - pinch zoom and center-point panning with two fingers, one finger for selection\n        canvas.addEventListener('touchstart', (e) => {\n            if (e.touches.length === 1) {\n                e.preventDefault();\n                isMouseDown = true;\n                const touchPos = getCanvasPosition(e.touches[0].clientX, e.touches[0].clientY);\n                startDrag(touchPos.x, touchPos.y);\n            }\n            else if (e.touches.length === 2) {\n                e.preventDefault();\n                // Two finger touch - prepare for panning and zooming\n                isMouseDown = true;\n                isPanning = false;\n                const touch1 = getCanvasPosition(e.touches[0].clientX, e.touches[0].clientY);\n                const touch2 = getCanvasPosition(e.touches[1].clientX, e.touches[1].clientY);\n                // Calculate center point between two touches\n                lastX = (touch1.x + touch2.x) / 2;\n                lastY = (touch1.y + touch2.y) / 2;\n                // Calculate initial distance for pinch zoom\n                const dx = touch2.x - touch1.x;\n                const dy = touch2.y - touch1.y;\n                lastPinchDistance = Math.sqrt(dx * dx + dy * dy);\n                this.cancelHold();\n            }\n        }, { passive: false });\n        canvas.addEventListener('touchmove', (e) => {\n            if (e.touches.length === 1 && isMouseDown) {\n                e.preventDefault();\n                const touchPos = getCanvasPosition(e.touches[0].clientX, e.touches[0].clientY);\n                moveDrag(touchPos.x, touchPos.y, false);\n            }\n            else if (e.touches.length === 2) {\n                e.preventDefault();\n                const touch1 = getCanvasPosition(e.touches[0].clientX, e.touches[0].clientY);\n                const touch2 = getCanvasPosition(e.touches[1].clientX, e.touches[1].clientY);\n                // Calculate current center point\n                const currentX = (touch1.x + touch2.x) / 2;\n                const currentY = (touch1.y + touch2.y) / 2;\n                // Calculate current distance for pinch zoom\n                const dx = touch2.x - touch1.x;\n                const dy = touch2.y - touch1.y;\n                const currentPinchDistance = Math.sqrt(dx * dx + dy * dy);\n                // Handle pinch zoom if distance changed significantly\n                if (Math.abs(currentPinchDistance - lastPinchDistance) > PINCH_ZOOM_THRESHOLD) {\n                    // Get world position under pinch center before zoom\n                    const worldPosBeforeZoom = this.renderer.screenToWorld(currentX, currentY);\n                    // Apply zoom based on pinch distance change\n                    const zoomDelta = currentPinchDistance / lastPinchDistance;\n                    const oldZoom = this.renderer.zoom;\n                    this.renderer.setZoom(oldZoom * zoomDelta);\n                    // Get world position under pinch center after zoom\n                    const worldPosAfterZoom = this.renderer.screenToWorld(currentX, currentY);\n                    // Adjust camera to keep world position under pinch center the same\n                    const currentCamera = this.renderer.camera;\n                    this.renderer.setCameraPositionWithoutParallax(new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(currentCamera.x + (worldPosBeforeZoom.x - worldPosAfterZoom.x), currentCamera.y + (worldPosBeforeZoom.y - worldPosAfterZoom.y)));\n                    lastPinchDistance = currentPinchDistance;\n                }\n                // Two finger drag - pan the camera\n                moveDrag(currentX, currentY, true);\n            }\n        }, { passive: false });\n        canvas.addEventListener('touchend', (e) => {\n            if (e.touches.length === 1) {\n                const touchPos = getCanvasPosition(e.touches[0].clientX, e.touches[0].clientY);\n                lastX = touchPos.x;\n                lastY = touchPos.y;\n                lastMouseX = touchPos.x;\n                lastMouseY = touchPos.y;\n            }\n            else if (e.changedTouches.length > 0) {\n                const touchPos = getCanvasPosition(e.changedTouches[0].clientX, e.changedTouches[0].clientY);\n                lastX = touchPos.x;\n                lastY = touchPos.y;\n                lastMouseX = touchPos.x;\n                lastMouseY = touchPos.y;\n            }\n            if (e.touches.length === 0) {\n                // All touches ended\n                endDrag();\n                lastPinchDistance = 0;\n            }\n            else if (e.touches.length === 1) {\n                // One touch remaining, transition from two-finger to one-finger mode\n                isPanning = false;\n                lastPinchDistance = 0;\n            }\n        });\n        canvas.addEventListener('touchcancel', () => {\n            endDrag();\n            lastPinchDistance = 0;\n        });\n        // Keyboard controls (WASD and arrow keys) - Desktop only\n        const KEYBOARD_PAN_SPEED = 10;\n        window.addEventListener('keydown', (e) => {\n            const key = e.key.toLowerCase();\n            // ESC key toggles in-game menu\n            if (key === 'escape' && this.game && !this.game.isCountdownActive) {\n                const winner = this.game.checkVictoryConditions();\n                if (!winner) {\n                    e.preventDefault();\n                    this.toggleInGameMenu();\n                    return;\n                }\n            }\n            if (['w', 'a', 's', 'd', 'arrowup', 'arrowdown', 'arrowleft', 'arrowright'].includes(key)) {\n                e.preventDefault();\n                keysPressed.add(key);\n            }\n        });\n        window.addEventListener('keyup', (e) => {\n            const key = e.key.toLowerCase();\n            keysPressed.delete(key);\n        });\n        // Update camera based on keyboard input and edge panning\n        const updateCameraPanning = () => {\n            // Early exit if no game is active\n            if (!this.game) {\n                requestAnimationFrame(updateCameraPanning);\n                return;\n            }\n            // Early exit if no input is active\n            const hasKeyboardInput = keysPressed.size > 0;\n            // Disable edge panning on mobile devices\n            const dpr = window.devicePixelRatio || 1;\n            const screenWidth = canvas.width / dpr;\n            const screenHeight = canvas.height / dpr;\n            const hasEdgeInput = !isMobile && !isMouseDown && !isPanning && (lastMouseX < EDGE_PAN_THRESHOLD ||\n                lastMouseX > screenWidth - EDGE_PAN_THRESHOLD ||\n                lastMouseY < EDGE_PAN_THRESHOLD ||\n                lastMouseY > screenHeight - EDGE_PAN_THRESHOLD);\n            if (hasKeyboardInput || hasEdgeInput) {\n                const currentCamera = this.renderer.camera;\n                let dx = 0;\n                let dy = 0;\n                // Keyboard panning\n                if (keysPressed.has('w') || keysPressed.has('arrowup'))\n                    dy -= KEYBOARD_PAN_SPEED;\n                if (keysPressed.has('s') || keysPressed.has('arrowdown'))\n                    dy += KEYBOARD_PAN_SPEED;\n                if (keysPressed.has('a') || keysPressed.has('arrowleft'))\n                    dx -= KEYBOARD_PAN_SPEED;\n                if (keysPressed.has('d') || keysPressed.has('arrowright'))\n                    dx += KEYBOARD_PAN_SPEED;\n                // Edge panning (only if not dragging with mouse and not on mobile)\n                if (hasEdgeInput) {\n                    if (lastMouseX < EDGE_PAN_THRESHOLD)\n                        dx -= EDGE_PAN_SPEED;\n                    if (lastMouseX > screenWidth - EDGE_PAN_THRESHOLD)\n                        dx += EDGE_PAN_SPEED;\n                    if (lastMouseY < EDGE_PAN_THRESHOLD)\n                        dy -= EDGE_PAN_SPEED;\n                    if (lastMouseY > screenHeight - EDGE_PAN_THRESHOLD)\n                        dy += EDGE_PAN_SPEED;\n                }\n                if (dx !== 0 || dy !== 0) {\n                    this.renderer.setCameraPosition(new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(currentCamera.x + dx / this.renderer.zoom, currentCamera.y + dy / this.renderer.zoom));\n                }\n            }\n            requestAnimationFrame(updateCameraPanning);\n        };\n        updateCameraPanning();\n    }\n    startHold(worldPos) {\n        if (!this.game)\n            return;\n        const player = this.game.players[0]; // Assume player 1 is the human player\n        if (!player.stellarForge)\n            return;\n        // Check if any buildings with guns are selected\n        const hasSelectedShootingBuildings = Array.from(this.selectedBuildings).some((building) => building.canShoot());\n        if (hasSelectedShootingBuildings) {\n            // Building control: Set target for all selected buildings that can shoot\n            for (const building of this.selectedBuildings) {\n                if (building.canShoot()) {\n                    // Find the nearest enemy to the hold position\n                    const enemies = [];\n                    // Get all enemy units and buildings\n                    for (const otherPlayer of this.game.players) {\n                        if (otherPlayer === player)\n                            continue;\n                        enemies.push(...otherPlayer.units);\n                        enemies.push(...otherPlayer.buildings);\n                        if (otherPlayer.stellarForge) {\n                            enemies.push(otherPlayer.stellarForge);\n                        }\n                    }\n                    // Find nearest enemy to the hold position\n                    let nearestEnemy = null;\n                    let minDistance = Infinity;\n                    for (const enemy of enemies) {\n                        const distance = worldPos.distanceTo(enemy.position);\n                        if (distance < minDistance) {\n                            minDistance = distance;\n                            nearestEnemy = enemy;\n                        }\n                    }\n                    // Set target for the building\n                    if (nearestEnemy) {\n                        building.target = nearestEnemy;\n                        console.log(`Building targeting enemy at (${nearestEnemy.position.x.toFixed(0)}, ${nearestEnemy.position.y.toFixed(0)})`);\n                    }\n                }\n            }\n            return;\n        }\n        // Check if any mirrors are selected\n        const hasSelectedMirrors = this.selectedMirrors.size > 0;\n        if (hasSelectedMirrors) {\n            // Mirror-based warp gate: check if any selected mirror has line of sight to hold position\n            let canCreateWarpGate = false;\n            for (const mirror of this.selectedMirrors) {\n                // Mirror must be powered (have line of sight to light source)\n                if (!mirror.hasLineOfSightToLight(this.game.suns, this.game.asteroids))\n                    continue;\n                // Check line of sight from mirror to hold position\n                const ray = new _game_core__WEBPACK_IMPORTED_MODULE_0__.LightRay(mirror.position, new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(worldPos.x - mirror.position.x, worldPos.y - mirror.position.y).normalize(), 1.0);\n                let hasLineOfSight = true;\n                for (const asteroid of this.game.asteroids) {\n                    if (ray.intersectsPolygon(asteroid.getWorldVertices())) {\n                        hasLineOfSight = false;\n                        break;\n                    }\n                }\n                if (hasLineOfSight) {\n                    canCreateWarpGate = true;\n                    break;\n                }\n            }\n            if (canCreateWarpGate) {\n                this.holdStartTime = Date.now();\n                this.holdPosition = worldPos;\n                this.isUsingMirrorsForWarpGate = true;\n                console.log('Starting mirror-based warp gate at', worldPos);\n            }\n        }\n        else {\n            // Normal warp gate: check if position is in player's influence\n            const distance = worldPos.distanceTo(player.stellarForge.position);\n            if (distance < _constants__WEBPACK_IMPORTED_MODULE_3__.INFLUENCE_RADIUS) {\n                this.holdStartTime = Date.now();\n                this.holdPosition = worldPos;\n                this.isUsingMirrorsForWarpGate = false;\n            }\n        }\n    }\n    selectUnitsInRectangle(screenStart, screenEnd) {\n        if (!this.game)\n            return;\n        // Convert screen coordinates to world coordinates\n        const worldStart = this.renderer.screenToWorld(screenStart.x, screenStart.y);\n        const worldEnd = this.renderer.screenToWorld(screenEnd.x, screenEnd.y);\n        // Calculate rectangle bounds\n        const minX = Math.min(worldStart.x, worldEnd.x);\n        const maxX = Math.max(worldStart.x, worldEnd.x);\n        const minY = Math.min(worldStart.y, worldEnd.y);\n        const maxY = Math.max(worldStart.y, worldEnd.y);\n        // Clear previous selection\n        this.selectedUnits.clear();\n        this.selectedMirrors.clear();\n        this.selectedBase = null;\n        // Get the player's units (assume player 1 is the human player)\n        const player = this.game.players[0];\n        if (!player || player.isDefeated())\n            return;\n        // Deselect all buildings\n        for (const building of player.buildings) {\n            building.isSelected = false;\n        }\n        this.selectedBuildings.clear();\n        // Select units within the rectangle\n        for (const unit of player.units) {\n            if (unit.position.x >= minX && unit.position.x <= maxX &&\n                unit.position.y >= minY && unit.position.y <= maxY) {\n                this.selectedUnits.add(unit);\n            }\n        }\n        // Select solar mirrors within the rectangle\n        for (const mirror of player.solarMirrors) {\n            if (mirror.position.x >= minX && mirror.position.x <= maxX &&\n                mirror.position.y >= minY && mirror.position.y <= maxY) {\n                this.selectedMirrors.add(mirror);\n                mirror.isSelected = true;\n            }\n            else {\n                mirror.isSelected = false;\n            }\n        }\n        // Select base if within rectangle and no units are selected\n        if (player.stellarForge &&\n            player.stellarForge.position.x >= minX && player.stellarForge.position.x <= maxX &&\n            player.stellarForge.position.y >= minY && player.stellarForge.position.y <= maxY &&\n            this.selectedUnits.size === 0) {\n            this.selectedBase = player.stellarForge;\n            player.stellarForge.isSelected = true;\n        }\n        else if (player.stellarForge) {\n            player.stellarForge.isSelected = false;\n        }\n        // Update renderer's selected units\n        this.renderer.selectedUnits = this.selectedUnits;\n        // Log selection for debugging\n        console.log(`Selected ${this.selectedUnits.size} units, ${this.selectedMirrors.size} mirrors, ${this.selectedBase ? '1 base' : '0 bases'}`);\n    }\n    cancelHold() {\n        if (!this.game)\n            return;\n        if (this.currentWarpGate) {\n            this.currentWarpGate.cancel();\n            this.implodeParticles(this.currentWarpGate.position); // Changed from scatterParticles to implodeParticles\n            const index = this.game.warpGates.indexOf(this.currentWarpGate);\n            if (index > -1) {\n                this.game.warpGates.splice(index, 1);\n            }\n        }\n        this.holdStartTime = null;\n        this.holdPosition = null;\n        this.currentWarpGate = null;\n        this.isUsingMirrorsForWarpGate = false;\n    }\n    endHold() {\n        this.holdStartTime = null;\n        this.holdPosition = null;\n        this.isUsingMirrorsForWarpGate = false;\n        // Don't remove currentWarpGate here, it might still be charging\n    }\n    /**\n     * Apply radial force to particles (helper function)\n     * @param position Center position\n     * @param outward If true, pushes particles outward (explosion). If false, pulls inward (implosion)\n     */\n    applyRadialForceToParticles(position, outward) {\n        if (!this.game)\n            return;\n        for (const particle of this.game.spaceDust) {\n            const distance = particle.position.distanceTo(position);\n            if (distance < _constants__WEBPACK_IMPORTED_MODULE_3__.PARTICLE_SCATTER_RADIUS) {\n                // Calculate direction: outward from center or inward to center\n                const direction = new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(outward ? (particle.position.x - position.x) : (position.x - particle.position.x), outward ? (particle.position.y - position.y) : (position.y - particle.position.y)).normalize();\n                particle.applyForce(new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(direction.x * _constants__WEBPACK_IMPORTED_MODULE_3__.PARTICLE_SCATTER_FORCE, direction.y * _constants__WEBPACK_IMPORTED_MODULE_3__.PARTICLE_SCATTER_FORCE));\n            }\n        }\n    }\n    scatterParticles(position) {\n        // Scatter nearby particles (explosion - outward push)\n        this.applyRadialForceToParticles(position, true);\n    }\n    implodeParticles(position) {\n        // Pull nearby particles inward (implosion - inward pull)\n        this.applyRadialForceToParticles(position, false);\n    }\n    update(deltaTime) {\n        if (!this.game)\n            return;\n        // Don't update game logic if paused\n        if (this.isPaused)\n            return;\n        // Check if game has ended\n        const winner = this.game.checkVictoryConditions();\n        if (winner && this.game.isRunning) {\n            this.game.isRunning = false;\n        }\n        if (this.game.isRunning) {\n            this.game.update(deltaTime);\n        }\n        // Update warp gate hold mechanic\n        if (this.holdStartTime && this.holdPosition) {\n            const holdDuration = (Date.now() - this.holdStartTime) / 1000;\n            if (holdDuration >= _constants__WEBPACK_IMPORTED_MODULE_3__.WARP_GATE_INITIAL_DELAY && !this.currentWarpGate) {\n                // Create warp gate after initial delay\n                const player = this.game.players[0];\n                this.currentWarpGate = new _game_core__WEBPACK_IMPORTED_MODULE_0__.WarpGate(this.holdPosition, player);\n                this.currentWarpGate.startCharging();\n                this.game.warpGates.push(this.currentWarpGate);\n            }\n        }\n        // Update current warp gate\n        if (this.currentWarpGate) {\n            const isStillHolding = this.holdStartTime !== null && this.holdPosition !== null;\n            // Calculate charge multiplier based on mirrors if using mirror-based warp gate\n            let chargeMultiplier = 1.0;\n            if (this.isUsingMirrorsForWarpGate && isStillHolding) {\n                const player = this.game.players[0];\n                let totalMirrorPower = 0;\n                for (const mirror of this.selectedMirrors) {\n                    // Check if mirror is powered\n                    if (!mirror.hasLineOfSightToLight(this.game.suns, this.game.asteroids))\n                        continue;\n                    // Check if mirror has line of sight to warp gate\n                    const ray = new _game_core__WEBPACK_IMPORTED_MODULE_0__.LightRay(mirror.position, new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(this.currentWarpGate.position.x - mirror.position.x, this.currentWarpGate.position.y - mirror.position.y).normalize(), 1.0);\n                    let hasLineOfSight = true;\n                    for (const asteroid of this.game.asteroids) {\n                        if (ray.intersectsPolygon(asteroid.getWorldVertices())) {\n                            hasLineOfSight = false;\n                            break;\n                        }\n                    }\n                    if (hasLineOfSight) {\n                        // Calculate mirror power based on distance to closest sun\n                        const closestSun = this.game.suns.reduce((closest, sun) => {\n                            const distToSun = mirror.position.distanceTo(sun.position);\n                            const distToClosest = closest ? mirror.position.distanceTo(closest.position) : Infinity;\n                            return distToSun < distToClosest ? sun : closest;\n                        }, null);\n                        if (closestSun) {\n                            const distanceToSun = mirror.position.distanceTo(closestSun.position);\n                            const distanceMultiplier = Math.max(1.0, _constants__WEBPACK_IMPORTED_MODULE_3__.MIRROR_PROXIMITY_MULTIPLIER * (1.0 - Math.min(1.0, distanceToSun / _constants__WEBPACK_IMPORTED_MODULE_3__.MIRROR_MAX_GLOW_DISTANCE)));\n                            totalMirrorPower += distanceMultiplier;\n                        }\n                    }\n                }\n                // Charge multiplier increases with more mirrors/power\n                // Base is 0.5x (slower than normal), each mirror adds power\n                chargeMultiplier = 0.5 + (totalMirrorPower * 0.5);\n            }\n            this.currentWarpGate.update(deltaTime, isStillHolding, chargeMultiplier);\n            if (this.currentWarpGate.shouldEmitShockwave()) {\n                this.scatterParticles(this.currentWarpGate.position);\n                this.renderer.createWarpGateShockwave(this.currentWarpGate.position);\n            }\n        }\n    }\n    render() {\n        if (this.game) {\n            this.renderer.render(this.game);\n        }\n    }\n    gameLoop(currentTime) {\n        if (!this.isRunning)\n            return;\n        // Calculate delta time in seconds\n        const deltaTime = this.lastTime === 0 ? 0 : (currentTime - this.lastTime) / 1000;\n        this.lastTime = currentTime;\n        // Update and render (cap delta time to prevent huge jumps)\n        this.update(Math.min(deltaTime, 0.1));\n        this.render();\n        // Continue loop\n        requestAnimationFrame((time) => this.gameLoop(time));\n    }\n    start() {\n        if (!this.game)\n            return;\n        this.isRunning = true;\n        this.lastTime = 0;\n        requestAnimationFrame((time) => this.gameLoop(time));\n    }\n    stop() {\n        this.isRunning = false;\n    }\n}\n// Start game when DOM is loaded\ndocument.addEventListener('DOMContentLoaded', () => {\n    const controller = new GameController();\n    // Expose for dev/testing purposes\n    window.gameController = controller;\n});\n\n\n//# sourceURL=webpack://sol/./src/main.ts?\n}");

/***/ },

/***/ "./src/menu.ts"
/*!*********************!*\
  !*** ./src/menu.ts ***!
  \*********************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   COLOR_SCHEMES: () => (/* binding */ COLOR_SCHEMES),\n/* harmony export */   MainMenu: () => (/* binding */ MainMenu)\n/* harmony export */ });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"./src/constants.ts\");\n/* harmony import */ var _game_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./game-core */ \"./src/game-core.ts\");\n/* harmony import */ var _network__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./network */ \"./src/network.ts\");\n/**\n * Main Menu for SoL game\n */\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\nclass BackgroundParticleLayer {\n    constructor(container) {\n        this.particles = [];\n        this.attractionMatrix = [];\n        this.animationFrameId = null;\n        this.isActive = false;\n        this.lastColorChangeMs = 0;\n        this.edgeGlows = {\n            top: [0, 0, 0],\n            right: [0, 0, 0],\n            bottom: [0, 0, 0],\n            left: [0, 0, 0]\n        };\n        this.gradientColors = [\n            [138, 43, 226], // Blue Violet\n            [147, 51, 234], // Purple\n            [219, 39, 119], // Pink\n            [236, 72, 153], // Light Pink\n            [59, 130, 246], // Blue\n            [14, 165, 233], // Sky Blue\n            [168, 85, 247], // Violet\n            [192, 132, 252] // Light Purple\n        ];\n        this.canvas = document.createElement('canvas');\n        this.canvas.style.position = 'fixed';\n        this.canvas.style.top = '0';\n        this.canvas.style.left = '0';\n        this.canvas.style.width = '100%';\n        this.canvas.style.height = '100%';\n        this.canvas.style.pointerEvents = 'none';\n        this.canvas.style.zIndex = '-1';\n        const context = this.canvas.getContext('2d');\n        if (!context) {\n            throw new Error('Unable to create background particle canvas context. This may be due to browser compatibility or system limitations.');\n        }\n        this.context = context;\n        container.appendChild(this.canvas);\n        this.resize();\n        this.initializeParticles();\n        this.initializeAttractionMatrix();\n        this.start();\n    }\n    initializeParticles() {\n        const width = this.canvas.width / (window.devicePixelRatio || 1);\n        const height = this.canvas.height / (window.devicePixelRatio || 1);\n        this.particles = [];\n        for (let i = 0; i < BackgroundParticleLayer.PARTICLE_COUNT; i++) {\n            const color = this.gradientColors[i % this.gradientColors.length];\n            const particle = {\n                x: Math.random() * width,\n                y: Math.random() * height,\n                velocityX: (Math.random() - 0.5) * 0.5,\n                velocityY: (Math.random() - 0.5) * 0.5,\n                colorR: color[0],\n                colorG: color[1],\n                colorB: color[2],\n                targetColorR: color[0],\n                targetColorG: color[1],\n                targetColorB: color[2],\n                radius: BackgroundParticleLayer.PARTICLE_RADIUS\n            };\n            this.particles.push(particle);\n        }\n    }\n    initializeAttractionMatrix() {\n        this.attractionMatrix = [];\n        for (let i = 0; i < BackgroundParticleLayer.PARTICLE_COUNT; i++) {\n            this.attractionMatrix[i] = [];\n            for (let j = 0; j < BackgroundParticleLayer.PARTICLE_COUNT; j++) {\n                if (i === j) {\n                    this.attractionMatrix[i][j] = 0;\n                }\n                else {\n                    // Random attraction (-0.5 to 0.5): negative = repulsion, positive = attraction\n                    this.attractionMatrix[i][j] = (Math.random() - 0.5) * BackgroundParticleLayer.ATTRACTION_STRENGTH;\n                }\n            }\n        }\n    }\n    resize() {\n        const devicePixelRatio = window.devicePixelRatio || 1;\n        const width = window.innerWidth;\n        const height = window.innerHeight;\n        this.canvas.width = Math.round(width * devicePixelRatio);\n        this.canvas.height = Math.round(height * devicePixelRatio);\n        this.context.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);\n    }\n    start() {\n        if (this.isActive) {\n            return;\n        }\n        this.isActive = true;\n        this.lastColorChangeMs = performance.now();\n        this.animate();\n    }\n    stop() {\n        this.isActive = false;\n        if (this.animationFrameId !== null) {\n            cancelAnimationFrame(this.animationFrameId);\n            this.animationFrameId = null;\n        }\n    }\n    animate() {\n        if (!this.isActive) {\n            return;\n        }\n        const nowMs = performance.now();\n        // Periodically change target colors for smooth transitions\n        if (nowMs - this.lastColorChangeMs >= BackgroundParticleLayer.COLOR_CHANGE_INTERVAL_MS) {\n            this.updateTargetColors();\n            this.lastColorChangeMs = nowMs;\n        }\n        this.updateParticles();\n        this.render();\n        this.animationFrameId = requestAnimationFrame(() => this.animate());\n    }\n    updateTargetColors() {\n        for (let i = 0; i < this.particles.length; i++) {\n            const colorIndex = Math.floor(Math.random() * this.gradientColors.length);\n            const color = this.gradientColors[colorIndex];\n            this.particles[i].targetColorR = color[0];\n            this.particles[i].targetColorG = color[1];\n            this.particles[i].targetColorB = color[2];\n        }\n    }\n    updateParticles() {\n        const width = this.canvas.width / (window.devicePixelRatio || 1);\n        const height = this.canvas.height / (window.devicePixelRatio || 1);\n        // Reset edge glows\n        this.edgeGlows.top = [0, 0, 0];\n        this.edgeGlows.right = [0, 0, 0];\n        this.edgeGlows.bottom = [0, 0, 0];\n        this.edgeGlows.left = [0, 0, 0];\n        // Apply attraction/repulsion forces\n        for (let i = 0; i < this.particles.length; i++) {\n            const p1 = this.particles[i];\n            for (let j = 0; j < this.particles.length; j++) {\n                if (i === j)\n                    continue;\n                const p2 = this.particles[j];\n                const dx = p2.x - p1.x;\n                const dy = p2.y - p1.y;\n                const distance = Math.sqrt(dx * dx + dy * dy);\n                if (distance > 0) {\n                    const force = this.attractionMatrix[i][j];\n                    const forceX = (dx / distance) * force;\n                    const forceY = (dy / distance) * force;\n                    p1.velocityX += forceX;\n                    p1.velocityY += forceY;\n                }\n            }\n            // Apply edge repulsion\n            const edgeRepulsion = BackgroundParticleLayer.EDGE_REPULSION_DISTANCE;\n            const edgeStrength = BackgroundParticleLayer.EDGE_REPULSION_STRENGTH;\n            // Left edge\n            if (p1.x < edgeRepulsion) {\n                const force = (1 - p1.x / edgeRepulsion) * edgeStrength;\n                p1.velocityX += force;\n            }\n            // Right edge\n            if (p1.x > width - edgeRepulsion) {\n                const force = (1 - (width - p1.x) / edgeRepulsion) * edgeStrength;\n                p1.velocityX -= force;\n            }\n            // Top edge\n            if (p1.y < edgeRepulsion) {\n                const force = (1 - p1.y / edgeRepulsion) * edgeStrength;\n                p1.velocityY += force;\n            }\n            // Bottom edge\n            if (p1.y > height - edgeRepulsion) {\n                const force = (1 - (height - p1.y) / edgeRepulsion) * edgeStrength;\n                p1.velocityY -= force;\n            }\n            // Apply friction\n            p1.velocityX *= BackgroundParticleLayer.FRICTION;\n            p1.velocityY *= BackgroundParticleLayer.FRICTION;\n            // Limit velocity\n            const speed = Math.sqrt(p1.velocityX * p1.velocityX + p1.velocityY * p1.velocityY);\n            if (speed > BackgroundParticleLayer.MAX_VELOCITY) {\n                p1.velocityX = (p1.velocityX / speed) * BackgroundParticleLayer.MAX_VELOCITY;\n                p1.velocityY = (p1.velocityY / speed) * BackgroundParticleLayer.MAX_VELOCITY;\n            }\n            // Apply minimum velocity to keep particles moving\n            if (speed < BackgroundParticleLayer.MIN_VELOCITY) {\n                // Give particles a small random velocity if completely stopped\n                const angle = Math.random() * Math.PI * 2;\n                p1.velocityX = Math.cos(angle) * BackgroundParticleLayer.MIN_VELOCITY;\n                p1.velocityY = Math.sin(angle) * BackgroundParticleLayer.MIN_VELOCITY;\n            }\n            // Update position\n            p1.x += p1.velocityX;\n            p1.y += p1.velocityY;\n            // Keep particles on screen (bounce back instead of wrapping)\n            if (p1.x < 0) {\n                p1.x = 0;\n                p1.velocityX = Math.abs(p1.velocityX);\n            }\n            if (p1.x > width) {\n                p1.x = width;\n                p1.velocityX = -Math.abs(p1.velocityX);\n            }\n            if (p1.y < 0) {\n                p1.y = 0;\n                p1.velocityY = Math.abs(p1.velocityY);\n            }\n            if (p1.y > height) {\n                p1.y = height;\n                p1.velocityY = -Math.abs(p1.velocityY);\n            }\n            // Calculate edge glow contributions\n            const glowDistance = BackgroundParticleLayer.EDGE_GLOW_DISTANCE;\n            const r = Math.round(p1.colorR);\n            const g = Math.round(p1.colorG);\n            const b = Math.round(p1.colorB);\n            // Top edge glow\n            if (p1.y < glowDistance) {\n                const intensity = (1 - p1.y / glowDistance);\n                this.edgeGlows.top[0] += r * intensity;\n                this.edgeGlows.top[1] += g * intensity;\n                this.edgeGlows.top[2] += b * intensity;\n            }\n            // Bottom edge glow\n            if (p1.y > height - glowDistance) {\n                const intensity = (1 - (height - p1.y) / glowDistance);\n                this.edgeGlows.bottom[0] += r * intensity;\n                this.edgeGlows.bottom[1] += g * intensity;\n                this.edgeGlows.bottom[2] += b * intensity;\n            }\n            // Left edge glow\n            if (p1.x < glowDistance) {\n                const intensity = (1 - p1.x / glowDistance);\n                this.edgeGlows.left[0] += r * intensity;\n                this.edgeGlows.left[1] += g * intensity;\n                this.edgeGlows.left[2] += b * intensity;\n            }\n            // Right edge glow\n            if (p1.x > width - glowDistance) {\n                const intensity = (1 - (width - p1.x) / glowDistance);\n                this.edgeGlows.right[0] += r * intensity;\n                this.edgeGlows.right[1] += g * intensity;\n                this.edgeGlows.right[2] += b * intensity;\n            }\n            // Smoothly transition colors\n            p1.colorR += (p1.targetColorR - p1.colorR) * BackgroundParticleLayer.COLOR_TRANSITION_SPEED;\n            p1.colorG += (p1.targetColorG - p1.colorG) * BackgroundParticleLayer.COLOR_TRANSITION_SPEED;\n            p1.colorB += (p1.targetColorB - p1.colorB) * BackgroundParticleLayer.COLOR_TRANSITION_SPEED;\n        }\n    }\n    render() {\n        const width = this.canvas.width / (window.devicePixelRatio || 1);\n        const height = this.canvas.height / (window.devicePixelRatio || 1);\n        // Clear with black background\n        this.context.fillStyle = '#000000';\n        this.context.fillRect(0, 0, width, height);\n        // Draw edge glows first (under particles)\n        this.context.globalCompositeOperation = 'screen';\n        this.context.filter = 'blur(40px)';\n        const glowHeight = 60;\n        const glowWidth = 60;\n        // Normalize and draw edge glows\n        const maxGlow = BackgroundParticleLayer.EDGE_GLOW_NORMALIZATION;\n        // Top edge\n        const topR = Math.min(255, Math.round(this.edgeGlows.top[0] / maxGlow * 255));\n        const topG = Math.min(255, Math.round(this.edgeGlows.top[1] / maxGlow * 255));\n        const topB = Math.min(255, Math.round(this.edgeGlows.top[2] / maxGlow * 255));\n        if (topR + topG + topB > 0) {\n            const gradient = this.context.createLinearGradient(0, 0, 0, glowHeight);\n            gradient.addColorStop(0, `rgba(${topR}, ${topG}, ${topB}, 0.6)`);\n            gradient.addColorStop(1, `rgba(${topR}, ${topG}, ${topB}, 0)`);\n            this.context.fillStyle = gradient;\n            this.context.fillRect(0, 0, width, glowHeight);\n        }\n        // Bottom edge\n        const bottomR = Math.min(255, Math.round(this.edgeGlows.bottom[0] / maxGlow * 255));\n        const bottomG = Math.min(255, Math.round(this.edgeGlows.bottom[1] / maxGlow * 255));\n        const bottomB = Math.min(255, Math.round(this.edgeGlows.bottom[2] / maxGlow * 255));\n        if (bottomR + bottomG + bottomB > 0) {\n            const gradient = this.context.createLinearGradient(0, height - glowHeight, 0, height);\n            gradient.addColorStop(0, `rgba(${bottomR}, ${bottomG}, ${bottomB}, 0)`);\n            gradient.addColorStop(1, `rgba(${bottomR}, ${bottomG}, ${bottomB}, 0.6)`);\n            this.context.fillStyle = gradient;\n            this.context.fillRect(0, height - glowHeight, width, glowHeight);\n        }\n        // Left edge\n        const leftR = Math.min(255, Math.round(this.edgeGlows.left[0] / maxGlow * 255));\n        const leftG = Math.min(255, Math.round(this.edgeGlows.left[1] / maxGlow * 255));\n        const leftB = Math.min(255, Math.round(this.edgeGlows.left[2] / maxGlow * 255));\n        if (leftR + leftG + leftB > 0) {\n            const gradient = this.context.createLinearGradient(0, 0, glowWidth, 0);\n            gradient.addColorStop(0, `rgba(${leftR}, ${leftG}, ${leftB}, 0.6)`);\n            gradient.addColorStop(1, `rgba(${leftR}, ${leftG}, ${leftB}, 0)`);\n            this.context.fillStyle = gradient;\n            this.context.fillRect(0, 0, glowWidth, height);\n        }\n        // Right edge\n        const rightR = Math.min(255, Math.round(this.edgeGlows.right[0] / maxGlow * 255));\n        const rightG = Math.min(255, Math.round(this.edgeGlows.right[1] / maxGlow * 255));\n        const rightB = Math.min(255, Math.round(this.edgeGlows.right[2] / maxGlow * 255));\n        if (rightR + rightG + rightB > 0) {\n            const gradient = this.context.createLinearGradient(width - glowWidth, 0, width, 0);\n            gradient.addColorStop(0, `rgba(${rightR}, ${rightG}, ${rightB}, 0)`);\n            gradient.addColorStop(1, `rgba(${rightR}, ${rightG}, ${rightB}, 0.6)`);\n            this.context.fillStyle = gradient;\n            this.context.fillRect(width - glowWidth, 0, glowWidth, height);\n        }\n        // Draw particles with blur effect (reduced blur for better performance)\n        this.context.filter = 'blur(60px)';\n        this.context.globalCompositeOperation = 'screen';\n        for (const particle of this.particles) {\n            const gradient = this.context.createRadialGradient(particle.x, particle.y, 0, particle.x, particle.y, particle.radius);\n            const r = Math.round(particle.colorR);\n            const g = Math.round(particle.colorG);\n            const b = Math.round(particle.colorB);\n            gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0.4)`);\n            gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);\n            this.context.fillStyle = gradient;\n            this.context.beginPath();\n            this.context.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);\n            this.context.fill();\n        }\n        this.context.filter = 'none';\n        this.context.globalCompositeOperation = 'source-over';\n    }\n    destroy() {\n        this.stop();\n        if (this.canvas.parentElement) {\n            this.canvas.parentElement.removeChild(this.canvas);\n        }\n    }\n}\nBackgroundParticleLayer.PARTICLE_COUNT = 24;\nBackgroundParticleLayer.PARTICLE_RADIUS = 75; // 30% of original 250\nBackgroundParticleLayer.MAX_VELOCITY = 0.3;\nBackgroundParticleLayer.MIN_VELOCITY = 0.02;\nBackgroundParticleLayer.FRICTION = 0.98;\nBackgroundParticleLayer.COLOR_TRANSITION_SPEED = 0.002;\nBackgroundParticleLayer.ATTRACTION_STRENGTH = 0.15;\nBackgroundParticleLayer.COLOR_CHANGE_INTERVAL_MS = 8000;\nBackgroundParticleLayer.EDGE_REPULSION_DISTANCE = 300;\nBackgroundParticleLayer.EDGE_REPULSION_STRENGTH = 0.05;\nBackgroundParticleLayer.EDGE_GLOW_DISTANCE = 400;\n// Normalization factor for edge glow intensity scaled by particle count\n// Higher particle count requires higher normalization to maintain visual consistency\nBackgroundParticleLayer.EDGE_GLOW_NORMALIZATION = BackgroundParticleLayer.PARTICLE_COUNT * 350;\nclass MenuAtmosphereLayer {\n    constructor(container, sunSpritePath) {\n        this.asteroids = [];\n        this.animationFrameId = null;\n        this.isActive = false;\n        this.widthPx = 0;\n        this.heightPx = 0;\n        this.container = container;\n        this.canvas = document.createElement('canvas');\n        this.canvas.style.position = 'fixed';\n        this.canvas.style.top = '0';\n        this.canvas.style.left = '0';\n        this.canvas.style.width = '100%';\n        this.canvas.style.height = '100%';\n        this.canvas.style.pointerEvents = 'none';\n        this.canvas.style.zIndex = '0';\n        this.canvas.style.opacity = '0.2';\n        const context = this.canvas.getContext('2d');\n        if (!context) {\n            throw new Error('Unable to create menu atmosphere canvas context.');\n        }\n        this.context = context;\n        this.sunSprite = new Image();\n        this.sunSprite.src = sunSpritePath;\n        this.container.appendChild(this.canvas);\n        this.resize();\n        this.initializeAsteroids();\n        this.start();\n    }\n    start() {\n        if (this.isActive) {\n            return;\n        }\n        this.isActive = true;\n        this.animate();\n    }\n    stop() {\n        this.isActive = false;\n        if (this.animationFrameId !== null) {\n            cancelAnimationFrame(this.animationFrameId);\n            this.animationFrameId = null;\n        }\n    }\n    resize() {\n        const devicePixelRatio = window.devicePixelRatio || 1;\n        const width = window.innerWidth;\n        const height = window.innerHeight;\n        this.widthPx = width;\n        this.heightPx = height;\n        this.canvas.width = Math.round(width * devicePixelRatio);\n        this.canvas.height = Math.round(height * devicePixelRatio);\n        this.context.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);\n    }\n    destroy() {\n        this.stop();\n        if (this.canvas.parentElement) {\n            this.canvas.parentElement.removeChild(this.canvas);\n        }\n    }\n    initializeAsteroids() {\n        this.asteroids = [];\n        for (let i = 0; i < MenuAtmosphereLayer.ASTEROID_COUNT; i++) {\n            this.asteroids.push(this.createAsteroid());\n        }\n    }\n    createAsteroid() {\n        const radiusPx = this.randomRange(MenuAtmosphereLayer.ASTEROID_MIN_RADIUS_PX, MenuAtmosphereLayer.ASTEROID_MAX_RADIUS_PX);\n        const position = this.createSpawnPosition();\n        const velocity = this.createVelocity();\n        const rotationSpeedRad = this.randomRange(MenuAtmosphereLayer.ASTEROID_ROTATION_MIN_RAD, MenuAtmosphereLayer.ASTEROID_ROTATION_MAX_RAD);\n        const points = [];\n        const pointCount = 7 + Math.floor(Math.random() * 4);\n        for (let i = 0; i < pointCount; i++) {\n            points.push({\n                angleRad: (Math.PI * 2 * i) / pointCount,\n                radiusScale: 0.7 + Math.random() * 0.5,\n            });\n        }\n        return {\n            x: position.x,\n            y: position.y,\n            radiusPx,\n            velocityX: velocity.x,\n            velocityY: velocity.y,\n            rotationRad: Math.random() * Math.PI * 2,\n            rotationSpeedRad: rotationSpeedRad * (Math.random() > 0.5 ? 1 : -1),\n            points,\n        };\n    }\n    createSpawnPosition() {\n        const margin = MenuAtmosphereLayer.BOUNDS_MARGIN_PX;\n        const sideRoll = Math.random();\n        if (sideRoll < 0.5) {\n            return {\n                x: this.randomRange(-margin, this.widthPx + margin),\n                y: this.randomRange(-margin * 0.6, this.heightPx * 0.7),\n            };\n        }\n        return {\n            x: this.randomRange(-margin, this.widthPx * 0.7),\n            y: this.randomRange(-margin, this.heightPx + margin),\n        };\n    }\n    createVelocity() {\n        const speed = this.randomRange(MenuAtmosphereLayer.ASTEROID_SPEED_MIN, MenuAtmosphereLayer.ASTEROID_SPEED_MAX);\n        const angleRad = Math.random() * Math.PI * 2;\n        return {\n            x: Math.cos(angleRad) * speed,\n            y: Math.sin(angleRad) * speed,\n        };\n    }\n    animate() {\n        if (!this.isActive) {\n            return;\n        }\n        this.updateAsteroids();\n        this.render();\n        this.animationFrameId = requestAnimationFrame(() => this.animate());\n    }\n    updateAsteroids() {\n        const margin = MenuAtmosphereLayer.BOUNDS_MARGIN_PX;\n        const minX = -margin;\n        const minY = -margin;\n        const maxX = this.widthPx + margin;\n        const maxY = this.heightPx + margin;\n        for (const asteroid of this.asteroids) {\n            asteroid.x += asteroid.velocityX;\n            asteroid.y += asteroid.velocityY;\n            asteroid.rotationRad += asteroid.rotationSpeedRad;\n            if (asteroid.x < minX || asteroid.x > maxX || asteroid.y < minY || asteroid.y > maxY) {\n                const spawn = this.createSpawnPosition();\n                const velocity = this.createVelocity();\n                asteroid.x = spawn.x;\n                asteroid.y = spawn.y;\n                asteroid.velocityX = velocity.x;\n                asteroid.velocityY = velocity.y;\n            }\n        }\n    }\n    render() {\n        this.context.clearRect(0, 0, this.widthPx, this.heightPx);\n        this.renderSunGlow();\n        this.renderAsteroids();\n    }\n    renderSunGlow() {\n        const sunCenter = this.getSunCenter();\n        const gradient = this.context.createRadialGradient(sunCenter.x, sunCenter.y, MenuAtmosphereLayer.SUN_RADIUS_PX * 0.35, sunCenter.x, sunCenter.y, MenuAtmosphereLayer.SUN_GLOW_RADIUS_PX);\n        gradient.addColorStop(0, 'rgba(255, 240, 200, 0.9)');\n        gradient.addColorStop(0.4, 'rgba(255, 200, 120, 0.5)');\n        gradient.addColorStop(0.7, 'rgba(255, 150, 80, 0.25)');\n        gradient.addColorStop(1, 'rgba(255, 120, 40, 0)');\n        this.context.fillStyle = gradient;\n        this.context.beginPath();\n        this.context.arc(sunCenter.x, sunCenter.y, MenuAtmosphereLayer.SUN_GLOW_RADIUS_PX, 0, Math.PI * 2);\n        this.context.fill();\n        if (this.sunSprite.complete && this.sunSprite.naturalWidth > 0) {\n            const diameterPx = MenuAtmosphereLayer.SUN_RADIUS_PX * 2;\n            this.context.drawImage(this.sunSprite, sunCenter.x - MenuAtmosphereLayer.SUN_RADIUS_PX, sunCenter.y - MenuAtmosphereLayer.SUN_RADIUS_PX, diameterPx, diameterPx);\n        }\n        else {\n            this.context.fillStyle = 'rgba(255, 215, 120, 0.95)';\n            this.context.beginPath();\n            this.context.arc(sunCenter.x, sunCenter.y, MenuAtmosphereLayer.SUN_RADIUS_PX, 0, Math.PI * 2);\n            this.context.fill();\n        }\n    }\n    renderAsteroids() {\n        const sunCenter = this.getSunCenter();\n        for (const asteroid of this.asteroids) {\n            const points = this.getAsteroidPoints(asteroid);\n            // Dropshadow removed per requirements\n            this.renderAsteroidBody(asteroid, points);\n        }\n    }\n    renderAsteroidShadow(asteroid, points, sunCenter) {\n        const shadowOffset = this.getShadowOffset(asteroid, sunCenter);\n        const shadowLength = MenuAtmosphereLayer.SHADOW_LENGTH_BASE_PX +\n            asteroid.radiusPx * MenuAtmosphereLayer.SHADOW_LENGTH_MULTIPLIER;\n        this.context.fillStyle = 'rgba(20, 14, 12, 0.45)';\n        this.context.beginPath();\n        for (let i = 0; i < points.length; i++) {\n            const point = points[i];\n            if (i === 0) {\n                this.context.moveTo(point.x, point.y);\n            }\n            else {\n                this.context.lineTo(point.x, point.y);\n            }\n        }\n        for (let i = points.length - 1; i >= 0; i--) {\n            const point = points[i];\n            this.context.lineTo(point.x + shadowOffset.x * shadowLength, point.y + shadowOffset.y * shadowLength);\n        }\n        this.context.closePath();\n        this.context.fill();\n    }\n    renderAsteroidBody(asteroid, points) {\n        this.context.fillStyle = 'rgba(170, 160, 140, 0.8)';\n        this.context.beginPath();\n        for (let i = 0; i < points.length; i++) {\n            const point = points[i];\n            if (i === 0) {\n                this.context.moveTo(point.x, point.y);\n            }\n            else {\n                this.context.lineTo(point.x, point.y);\n            }\n        }\n        this.context.closePath();\n        this.context.fill();\n        this.context.strokeStyle = 'rgba(120, 105, 90, 0.65)';\n        this.context.lineWidth = 1;\n        this.context.stroke();\n    }\n    getSunCenter() {\n        return {\n            x: MenuAtmosphereLayer.SUN_RADIUS_PX + MenuAtmosphereLayer.SUN_OFFSET_X_PX,\n            y: MenuAtmosphereLayer.SUN_RADIUS_PX + MenuAtmosphereLayer.SUN_OFFSET_Y_PX,\n        };\n    }\n    getShadowOffset(asteroid, sunCenter) {\n        const deltaX = asteroid.x - sunCenter.x;\n        const deltaY = asteroid.y - sunCenter.y;\n        const distance = Math.max(1, Math.hypot(deltaX, deltaY));\n        const normX = deltaX / distance;\n        const normY = deltaY / distance;\n        return {\n            x: normX,\n            y: normY,\n        };\n    }\n    getAsteroidPoints(asteroid) {\n        const points = [];\n        const basePoints = asteroid.points;\n        for (let i = 0; i < basePoints.length; i++) {\n            const point = basePoints[i];\n            const angleRad = point.angleRad + asteroid.rotationRad;\n            const radiusPx = asteroid.radiusPx * point.radiusScale;\n            points.push({\n                x: asteroid.x + Math.cos(angleRad) * radiusPx,\n                y: asteroid.y + Math.sin(angleRad) * radiusPx,\n            });\n        }\n        return points;\n    }\n    randomRange(min, max) {\n        return min + Math.random() * (max - min);\n    }\n}\nMenuAtmosphereLayer.ASTEROID_COUNT = 14;\nMenuAtmosphereLayer.ASTEROID_MIN_RADIUS_PX = 6;\nMenuAtmosphereLayer.ASTEROID_MAX_RADIUS_PX = 16;\nMenuAtmosphereLayer.ASTEROID_SPEED_MIN = 0.06;\nMenuAtmosphereLayer.ASTEROID_SPEED_MAX = 0.18;\nMenuAtmosphereLayer.ASTEROID_ROTATION_MIN_RAD = 0.004;\nMenuAtmosphereLayer.ASTEROID_ROTATION_MAX_RAD = 0.014;\nMenuAtmosphereLayer.SUN_RADIUS_PX = 120;\nMenuAtmosphereLayer.SUN_GLOW_RADIUS_PX = 320;\nMenuAtmosphereLayer.SUN_OFFSET_X_PX = -28;\nMenuAtmosphereLayer.SUN_OFFSET_Y_PX = -22;\nMenuAtmosphereLayer.SHADOW_LENGTH_BASE_PX = 120;\nMenuAtmosphereLayer.SHADOW_LENGTH_MULTIPLIER = 7.5;\nMenuAtmosphereLayer.BOUNDS_MARGIN_PX = 80;\nclass ParticleMenuLayer {\n    constructor(container) {\n        this.particles = [];\n        this.animationFrameId = null;\n        this.isActive = false;\n        this.needsTargetRefresh = false;\n        this.lastTargetRefreshMs = 0;\n        this.targetRefreshContainer = null;\n        this.densityMultiplier = 1;\n        this.desiredParticleCount = 0;\n        this.menuContentElement = null;\n        this.particleOpacity = ParticleMenuLayer.BASE_PARTICLE_OPACITY;\n        this.menuOpacity = 1;\n        this.transitionStartMs = null;\n        this.container = container;\n        this.canvas = document.createElement('canvas');\n        this.canvas.style.position = 'fixed';\n        this.canvas.style.top = '0';\n        this.canvas.style.left = '0';\n        this.canvas.style.width = '100%';\n        this.canvas.style.height = '100%';\n        this.canvas.style.pointerEvents = 'none';\n        this.canvas.style.zIndex = '2';\n        const context = this.canvas.getContext('2d');\n        if (!context) {\n            throw new Error('Unable to create menu particle canvas context.');\n        }\n        this.context = context;\n        this.offscreenCanvas = document.createElement('canvas');\n        const offscreenContext = this.offscreenCanvas.getContext('2d');\n        if (!offscreenContext) {\n            throw new Error('Unable to create offscreen particle canvas context.');\n        }\n        this.offscreenContext = offscreenContext;\n        this.container.appendChild(this.canvas);\n        // Defer initial resize to ensure container has layout dimensions\n        requestAnimationFrame(() => {\n            try {\n                this.resize();\n            }\n            catch (error) {\n                console.error('Failed to resize particle canvas:', error);\n            }\n        });\n        this.start();\n    }\n    start() {\n        if (this.isActive) {\n            return;\n        }\n        this.isActive = true;\n        this.animate();\n    }\n    stop() {\n        this.isActive = false;\n        if (this.animationFrameId !== null) {\n            cancelAnimationFrame(this.animationFrameId);\n            this.animationFrameId = null;\n        }\n    }\n    resize() {\n        const rect = this.container.getBoundingClientRect();\n        const devicePixelRatio = window.devicePixelRatio || 1;\n        const width = rect.width || window.innerWidth;\n        const height = rect.height || window.innerHeight;\n        this.canvas.width = Math.round(width * devicePixelRatio);\n        this.canvas.height = Math.round(height * devicePixelRatio);\n        this.context.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);\n    }\n    setMenuContentElement(element) {\n        this.menuContentElement = element;\n        this.applyMenuOpacity();\n    }\n    requestTargetRefresh(container) {\n        this.needsTargetRefresh = true;\n        this.targetRefreshContainer = container;\n    }\n    clearTargets() {\n        this.setTargets([]);\n    }\n    setDensityMultiplier(multiplier) {\n        this.densityMultiplier = Math.max(0.5, multiplier);\n    }\n    startTransition() {\n        this.transitionStartMs = performance.now();\n    }\n    animate() {\n        if (!this.isActive) {\n            return;\n        }\n        const nowMs = performance.now();\n        if (this.needsTargetRefresh\n            && this.targetRefreshContainer\n            && nowMs - this.lastTargetRefreshMs >= ParticleMenuLayer.REFRESH_INTERVAL_MS) {\n            this.updateTargetsFromElements(this.targetRefreshContainer);\n            this.lastTargetRefreshMs = nowMs;\n            this.needsTargetRefresh = false;\n        }\n        this.updateParticles(nowMs);\n        this.renderParticles();\n        this.animationFrameId = requestAnimationFrame(() => this.animate());\n    }\n    updateTargetsFromElements(container) {\n        const targets = this.collectTargets(container);\n        this.setTargets(targets);\n    }\n    setTargets(targets) {\n        const updatedParticles = [];\n        const targetCount = targets.length;\n        if (targetCount === 0) {\n            this.particles = updatedParticles;\n            this.desiredParticleCount = 0;\n            return;\n        }\n        this.desiredParticleCount = targetCount;\n        const desiredCount = this.desiredParticleCount;\n        const existingParticles = this.particles.slice();\n        if (existingParticles.length > desiredCount) {\n            existingParticles.length = desiredCount;\n        }\n        while (existingParticles.length < desiredCount) {\n            const seed = targets[existingParticles.length % targetCount];\n            existingParticles.push(this.createParticle(seed.x, seed.y, seed.color));\n        }\n        for (let i = 0; i < desiredCount; i++) {\n            const target = targets[i % targetCount];\n            const particle = existingParticles[i];\n            const relocatedTarget = this.getRelocatedTarget(target);\n            particle.targetX = relocatedTarget.x;\n            particle.targetY = relocatedTarget.y;\n            particle.baseTargetX = relocatedTarget.x;\n            particle.baseTargetY = relocatedTarget.y;\n            const targetColor = this.parseColor(target.color);\n            particle.targetColorR = targetColor.r;\n            particle.targetColorG = targetColor.g;\n            particle.targetColorB = targetColor.b;\n            particle.sizePx = ParticleMenuLayer.PARTICLE_SIZE_PX;\n            updatedParticles.push(particle);\n        }\n        this.particles = updatedParticles;\n    }\n    createParticle(x, y, color) {\n        const driftPhase = Math.random() * Math.PI * 2;\n        const driftRadiusPx = ParticleMenuLayer.DRIFT_RADIUS_MIN_PX\n            + Math.random() * (ParticleMenuLayer.DRIFT_RADIUS_MAX_PX - ParticleMenuLayer.DRIFT_RADIUS_MIN_PX);\n        const speedMultiplier = 0.8 + Math.random() * 0.4; // Random value between 0.8 and 1.2\n        const parsedColor = this.parseColor(color);\n        return {\n            x,\n            y,\n            velocityX: 0,\n            velocityY: 0,\n            targetX: x,\n            targetY: y,\n            baseTargetX: x,\n            baseTargetY: y,\n            colorR: parsedColor.r,\n            colorG: parsedColor.g,\n            colorB: parsedColor.b,\n            targetColorR: parsedColor.r,\n            targetColorG: parsedColor.g,\n            targetColorB: parsedColor.b,\n            sizePx: ParticleMenuLayer.PARTICLE_SIZE_PX,\n            driftPhase,\n            driftRadiusPx,\n            speedMultiplier,\n        };\n    }\n    getRelocatedTarget(target) {\n        const minDistancePx = ParticleMenuLayer.RELOCATE_MIN_DISTANCE_PX;\n        const maxDistancePx = ParticleMenuLayer.RELOCATE_MAX_DISTANCE_PX;\n        const distancePx = minDistancePx + Math.random() * (maxDistancePx - minDistancePx);\n        const angleRad = Math.random() * Math.PI * 2;\n        return {\n            x: target.x + Math.cos(angleRad) * distancePx,\n            y: target.y + Math.sin(angleRad) * distancePx,\n        };\n    }\n    updateParticles(nowMs) {\n        this.updateTransition(nowMs);\n        const driftTime = nowMs * ParticleMenuLayer.DRIFT_SPEED;\n        for (const particle of this.particles) {\n            const particleDriftTime = driftTime * particle.speedMultiplier;\n            const driftX = Math.cos(particle.driftPhase + particleDriftTime) * particle.driftRadiusPx;\n            const driftY = Math.sin(particle.driftPhase + particleDriftTime) * particle.driftRadiusPx;\n            particle.baseTargetX = particle.targetX + driftX;\n            particle.baseTargetY = particle.targetY + driftY;\n            const deltaX = particle.baseTargetX - particle.x;\n            const deltaY = particle.baseTargetY - particle.y;\n            const positionSmoothing = ParticleMenuLayer.POSITION_SMOOTHING * particle.speedMultiplier;\n            particle.velocityX += deltaX * positionSmoothing;\n            particle.velocityY += deltaY * positionSmoothing;\n            particle.velocityX *= 0.82;\n            particle.velocityY *= 0.82;\n            particle.x += particle.velocityX;\n            particle.y += particle.velocityY;\n            particle.colorR += (particle.targetColorR - particle.colorR) * ParticleMenuLayer.COLOR_SMOOTHING;\n            particle.colorG += (particle.targetColorG - particle.colorG) * ParticleMenuLayer.COLOR_SMOOTHING;\n            particle.colorB += (particle.targetColorB - particle.colorB) * ParticleMenuLayer.COLOR_SMOOTHING;\n        }\n    }\n    updateTransition(nowMs) {\n        if (this.transitionStartMs === null) {\n            this.particleOpacity = ParticleMenuLayer.BASE_PARTICLE_OPACITY;\n            this.menuOpacity = 1;\n            this.applyMenuOpacity();\n            return;\n        }\n        const elapsedMs = nowMs - this.transitionStartMs;\n        const totalDurationMs = ParticleMenuLayer.TRANSITION_DURATION_MS;\n        const halfDurationMs = totalDurationMs / 2;\n        if (elapsedMs >= totalDurationMs) {\n            this.transitionStartMs = null;\n            this.particleOpacity = ParticleMenuLayer.BASE_PARTICLE_OPACITY;\n            this.menuOpacity = 1;\n            this.applyMenuOpacity();\n            return;\n        }\n        if (elapsedMs <= halfDurationMs) {\n            const progress = elapsedMs / halfDurationMs;\n            this.particleOpacity = ParticleMenuLayer.BASE_PARTICLE_OPACITY\n                + (ParticleMenuLayer.PEAK_PARTICLE_OPACITY - ParticleMenuLayer.BASE_PARTICLE_OPACITY) * progress;\n            this.menuOpacity = 1 - progress;\n        }\n        else {\n            const progress = (elapsedMs - halfDurationMs) / halfDurationMs;\n            this.particleOpacity = ParticleMenuLayer.PEAK_PARTICLE_OPACITY\n                + (ParticleMenuLayer.BASE_PARTICLE_OPACITY - ParticleMenuLayer.PEAK_PARTICLE_OPACITY) * progress;\n            this.menuOpacity = progress;\n        }\n        this.applyMenuOpacity();\n    }\n    applyMenuOpacity() {\n        if (this.menuContentElement) {\n            this.menuContentElement.style.opacity = this.menuOpacity.toFixed(3);\n        }\n    }\n    renderParticles() {\n        const rect = this.container.getBoundingClientRect();\n        const width = rect.width || window.innerWidth;\n        const height = rect.height || window.innerHeight;\n        this.context.clearRect(0, 0, width, height);\n        this.context.globalCompositeOperation = 'lighter';\n        this.context.globalAlpha = this.particleOpacity;\n        for (const particle of this.particles) {\n            const red = Math.min(255, Math.max(0, Math.round(particle.colorR)));\n            const green = Math.min(255, Math.max(0, Math.round(particle.colorG)));\n            const blue = Math.min(255, Math.max(0, Math.round(particle.colorB)));\n            this.context.fillStyle = `rgb(${red}, ${green}, ${blue})`;\n            this.context.beginPath();\n            this.context.arc(particle.x, particle.y, particle.sizePx, 0, Math.PI * 2);\n            this.context.fill();\n        }\n        this.context.globalAlpha = 1;\n        this.context.globalCompositeOperation = 'source-over';\n    }\n    collectTargets(container) {\n        const elements = Array.from(container.querySelectorAll('[data-particle-text], [data-particle-box]'));\n        const targets = [];\n        for (const element of elements) {\n            if (element.dataset.particleText !== undefined) {\n                targets.push(...this.collectTextTargets(element));\n            }\n            if (element.dataset.particleBox !== undefined) {\n                targets.push(...this.collectBoxTargets(element));\n            }\n        }\n        return targets;\n    }\n    collectTextTargets(element) {\n        var _a;\n        const text = (_a = element.textContent) === null || _a === void 0 ? void 0 : _a.trim();\n        if (!text) {\n            return [];\n        }\n        const rect = element.getBoundingClientRect();\n        if (rect.width <= 0 || rect.height <= 0) {\n            return [];\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const fontSizePx = Number.parseFloat(computedStyle.fontSize) || 16;\n        const fontFamily = computedStyle.fontFamily || 'Arial, sans-serif';\n        const fontWeight = computedStyle.fontWeight || '600';\n        const textColor = element.dataset.particleColor || '#FFFFFF';\n        const baseSpacingPx = Math.max(3, Math.round(fontSizePx / 7.5));\n        const spacingPx = Math.max(2, Math.round(baseSpacingPx / this.densityMultiplier));\n        this.offscreenCanvas.width = Math.ceil(rect.width);\n        this.offscreenCanvas.height = Math.ceil(rect.height);\n        this.offscreenContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height);\n        this.offscreenContext.font = `${fontWeight} ${fontSizePx}px ${fontFamily}`;\n        this.offscreenContext.textAlign = 'center';\n        this.offscreenContext.textBaseline = 'middle';\n        this.offscreenContext.fillStyle = '#FFFFFF';\n        this.offscreenContext.fillText(text, this.offscreenCanvas.width / 2, this.offscreenCanvas.height / 2);\n        const imageData = this.offscreenContext.getImageData(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height);\n        const data = imageData.data;\n        const targets = [];\n        const startX = spacingPx / 2;\n        const startY = spacingPx / 2;\n        for (let y = startY; y < this.offscreenCanvas.height; y += spacingPx) {\n            for (let x = startX; x < this.offscreenCanvas.width; x += spacingPx) {\n                const index = (Math.floor(y) * this.offscreenCanvas.width + Math.floor(x)) * 4 + 3;\n                if (data[index] > 80) {\n                    targets.push({\n                        x: rect.left + x,\n                        y: rect.top + y,\n                        color: textColor,\n                    });\n                }\n            }\n        }\n        return targets;\n    }\n    collectBoxTargets(element) {\n        const rect = element.getBoundingClientRect();\n        if (rect.width <= 0 || rect.height <= 0) {\n            return [];\n        }\n        const color = element.dataset.particleColor || '#FFFFFF';\n        const baseSpacingPx = Math.max(6, Math.round(Math.min(rect.width, rect.height) / 12));\n        const spacingPx = Math.max(3, Math.round(baseSpacingPx / this.densityMultiplier));\n        const targets = [];\n        const left = rect.left;\n        const right = rect.right;\n        const top = rect.top;\n        const bottom = rect.bottom;\n        for (let x = left; x <= right; x += spacingPx) {\n            targets.push({ x, y: top, color });\n            targets.push({ x, y: bottom, color });\n        }\n        for (let y = top; y <= bottom; y += spacingPx) {\n            targets.push({ x: left, y, color });\n            targets.push({ x: right, y, color });\n        }\n        return targets;\n    }\n    parseColor(color) {\n        const trimmed = color.trim();\n        if (trimmed.startsWith('#')) {\n            const hex = trimmed.slice(1);\n            if (hex.length === 3) {\n                const r = Number.parseInt(hex[0] + hex[0], 16);\n                const g = Number.parseInt(hex[1] + hex[1], 16);\n                const b = Number.parseInt(hex[2] + hex[2], 16);\n                return { r, g, b };\n            }\n            if (hex.length === 6) {\n                const r = Number.parseInt(hex.slice(0, 2), 16);\n                const g = Number.parseInt(hex.slice(2, 4), 16);\n                const b = Number.parseInt(hex.slice(4, 6), 16);\n                return { r, g, b };\n            }\n        }\n        return { r: 255, g: 255, b: 255 };\n    }\n}\nParticleMenuLayer.REFRESH_INTERVAL_MS = 140;\nParticleMenuLayer.POSITION_SMOOTHING = 0.08 / 14;\nParticleMenuLayer.DRIFT_SPEED = 0.0007 / 6;\nParticleMenuLayer.DRIFT_RADIUS_MIN_PX = 0.03;\nParticleMenuLayer.DRIFT_RADIUS_MAX_PX = 0.11;\nParticleMenuLayer.COLOR_SMOOTHING = 0.08;\nParticleMenuLayer.PARTICLE_SIZE_PX = 1.6;\nParticleMenuLayer.RELOCATE_MIN_DISTANCE_PX = 4;\nParticleMenuLayer.RELOCATE_MAX_DISTANCE_PX = 12;\nParticleMenuLayer.BASE_PARTICLE_OPACITY = 0.15;\nParticleMenuLayer.PEAK_PARTICLE_OPACITY = 0.4;\nParticleMenuLayer.TRANSITION_DURATION_MS = 600;\nconst COLOR_SCHEMES = {\n    'SpaceBlack': {\n        id: 'SpaceBlack',\n        name: 'Space Black',\n        background: '#000000',\n        asteroidColors: {\n            fillStart: '#878787',\n            fillEnd: '#505050',\n            strokeStart: '#9B9B9B',\n            strokeEnd: '#646464'\n        },\n        spaceDustPalette: {\n            neutral: ['#5a5a5a', '#6c6c6c', '#7f7f7f', '#8f8f8f'],\n            accent: ['#5b6c8f', '#6a5f8f', '#7a6aa6']\n        },\n        sunCore: {\n            inner: 'rgba(255, 255, 255, 1)', // #FFFFFF white-hot center\n            mid: 'rgba(255, 230, 120, 1)', // #FFE678\n            outer: 'rgba(255, 180, 50, 0.9)' // #FFB432\n        },\n        sunGlow: {\n            outerGlow1: 'rgba(255, 220, 100, 0.8)', // #FFDC64\n            outerGlow2: 'rgba(255, 180, 50, 0.4)', // #FFB432\n            outerGlow3: 'rgba(255, 140, 30, 0.2)', // #FF8C1E\n            outerGlow4: 'rgba(255, 100, 0, 0)' // #FF6400 (fade)\n        },\n        sunLightRays: {\n            nearCenter: 'rgba(255, 245, 215, 0.35)', // #FFF5D7 soft warm cream\n            mid: 'rgba(255, 220, 170, 0.18)', // #FFDCAA warm peach\n            edge: 'rgba(255, 200, 140, 0)' // #FFC88C fades to transparent\n        },\n        lensFlareHalo: 'rgba(255, 240, 200, 0.15)' // #FFF0C8\n    },\n    'ColdIce': {\n        id: 'ColdIce',\n        name: 'Cold Ice',\n        background: '#0B1426',\n        asteroidColors: {\n            fillStart: '#4A3B6E',\n            fillEnd: '#7B63A6',\n            strokeStart: '#6A52A0',\n            strokeEnd: '#B39DE6'\n        },\n        spaceDustPalette: {\n            neutral: ['#6D717B', '#7C808A', '#8A8D97', '#9A9EB0'],\n            accent: ['#6C5A91', '#7B66A8', '#8B75C3', '#9A82D6']\n        },\n        sunCore: {\n            inner: 'rgba(230, 245, 255, 1)', // soft icy white\n            mid: 'rgba(190, 220, 255, 0.95)', // pale blue\n            outer: 'rgba(150, 200, 255, 0.85)' // light blue edge\n        },\n        sunGlow: {\n            outerGlow1: 'rgba(200, 230, 255, 0.75)',\n            outerGlow2: 'rgba(160, 210, 255, 0.45)',\n            outerGlow3: 'rgba(120, 190, 255, 0.25)',\n            outerGlow4: 'rgba(80, 170, 255, 0)'\n        },\n        sunLightRays: {\n            nearCenter: 'rgba(220, 240, 255, 0.35)',\n            mid: 'rgba(170, 215, 255, 0.18)',\n            edge: 'rgba(130, 190, 255, 0)'\n        },\n        lensFlareHalo: 'rgba(210, 235, 255, 0.18)'\n    },\n    'DeepSpace': {\n        id: 'DeepSpace',\n        name: 'Deep Space',\n        background: '#0A0A1E',\n        asteroidColors: {\n            fillStart: '#4A4A7E',\n            fillEnd: '#2E2E5A',\n            strokeStart: '#6A6A9E',\n            strokeEnd: '#4A4A7A'\n        },\n        spaceDustPalette: {\n            neutral: ['#3A3A5E', '#4A4A6E', '#5A5A7E', '#6A6A8E'],\n            accent: ['#5A4A8F', '#6A5A9F', '#7A6AAF', '#8A7ABF']\n        },\n        sunCore: {\n            inner: 'rgba(220, 200, 255, 1)', // soft purple-white\n            mid: 'rgba(180, 150, 230, 0.95)', // lavender\n            outer: 'rgba(140, 100, 200, 0.85)' // purple edge\n        },\n        sunGlow: {\n            outerGlow1: 'rgba(170, 140, 230, 0.75)',\n            outerGlow2: 'rgba(140, 110, 200, 0.45)',\n            outerGlow3: 'rgba(110, 80, 170, 0.25)',\n            outerGlow4: 'rgba(80, 50, 140, 0)'\n        },\n        sunLightRays: {\n            nearCenter: 'rgba(200, 180, 240, 0.35)',\n            mid: 'rgba(160, 130, 210, 0.18)',\n            edge: 'rgba(120, 90, 180, 0)'\n        },\n        lensFlareHalo: 'rgba(190, 170, 230, 0.18)'\n    },\n    'RedGiant': {\n        id: 'RedGiant',\n        name: 'Red Giant',\n        background: '#1A0A0A',\n        asteroidColors: {\n            fillStart: '#8A5A5A',\n            fillEnd: '#5A3030',\n            strokeStart: '#AA7A7A',\n            strokeEnd: '#7A4A4A'\n        },\n        spaceDustPalette: {\n            neutral: ['#6A4A4A', '#7A5A5A', '#8A6A6A', '#9A7A7A'],\n            accent: ['#8F5A4A', '#9F6A5A', '#AF7A6A', '#BF8A7A']\n        },\n        sunCore: {\n            inner: 'rgba(255, 240, 200, 1)', // warm white-yellow\n            mid: 'rgba(255, 160, 80, 0.95)', // bright orange\n            outer: 'rgba(255, 100, 60, 0.85)' // red-orange edge\n        },\n        sunGlow: {\n            outerGlow1: 'rgba(255, 140, 80, 0.75)',\n            outerGlow2: 'rgba(240, 100, 60, 0.45)',\n            outerGlow3: 'rgba(220, 60, 40, 0.25)',\n            outerGlow4: 'rgba(200, 40, 20, 0)'\n        },\n        sunLightRays: {\n            nearCenter: 'rgba(255, 200, 150, 0.35)',\n            mid: 'rgba(255, 140, 90, 0.18)',\n            edge: 'rgba(240, 100, 60, 0)'\n        },\n        lensFlareHalo: 'rgba(255, 180, 120, 0.18)'\n    },\n    'Nebula': {\n        id: 'Nebula',\n        name: 'Nebula',\n        background: '#150A1A',\n        asteroidColors: {\n            fillStart: '#7A4A7A',\n            fillEnd: '#5A2A5A',\n            strokeStart: '#9A6A9A',\n            strokeEnd: '#7A4A7A'\n        },\n        spaceDustPalette: {\n            neutral: ['#6A4A6A', '#7A5A7A', '#8A6A8A', '#9A7A9A'],\n            accent: ['#8F4A7A', '#9F5A8A', '#AF6A9A', '#BF7AAA']\n        },\n        sunCore: {\n            inner: 'rgba(255, 220, 255, 1)', // soft pink-white\n            mid: 'rgba(240, 150, 220, 0.95)', // bright pink\n            outer: 'rgba(200, 100, 180, 0.85)' // magenta edge\n        },\n        sunGlow: {\n            outerGlow1: 'rgba(230, 140, 210, 0.75)',\n            outerGlow2: 'rgba(200, 100, 180, 0.45)',\n            outerGlow3: 'rgba(170, 70, 150, 0.25)',\n            outerGlow4: 'rgba(140, 50, 120, 0)'\n        },\n        sunLightRays: {\n            nearCenter: 'rgba(240, 180, 230, 0.35)',\n            mid: 'rgba(210, 130, 190, 0.18)',\n            edge: 'rgba(180, 90, 160, 0)'\n        },\n        lensFlareHalo: 'rgba(230, 160, 210, 0.18)'\n    },\n    'GreenAurora': {\n        id: 'GreenAurora',\n        name: 'Green Aurora',\n        background: '#0A1A14',\n        asteroidColors: {\n            fillStart: '#4A7A5A',\n            fillEnd: '#2A5A3A',\n            strokeStart: '#6A9A7A',\n            strokeEnd: '#4A7A5A'\n        },\n        spaceDustPalette: {\n            neutral: ['#4A6A5A', '#5A7A6A', '#6A8A7A', '#7A9A8A'],\n            accent: ['#4A8F6A', '#5A9F7A', '#6AAF8A', '#7ABF9A']\n        },\n        sunCore: {\n            inner: 'rgba(220, 255, 230, 1)', // soft mint-white\n            mid: 'rgba(160, 240, 180, 0.95)', // bright mint green\n            outer: 'rgba(100, 200, 140, 0.85)' // teal-green edge\n        },\n        sunGlow: {\n            outerGlow1: 'rgba(140, 230, 170, 0.75)',\n            outerGlow2: 'rgba(100, 200, 140, 0.45)',\n            outerGlow3: 'rgba(70, 170, 110, 0.25)',\n            outerGlow4: 'rgba(50, 140, 80, 0)'\n        },\n        sunLightRays: {\n            nearCenter: 'rgba(180, 240, 210, 0.35)',\n            mid: 'rgba(130, 210, 170, 0.18)',\n            edge: 'rgba(90, 180, 130, 0)'\n        },\n        lensFlareHalo: 'rgba(160, 230, 190, 0.18)'\n    }\n};\nclass MainMenu {\n    constructor() {\n        this.backgroundParticleLayer = null;\n        this.atmosphereLayer = null;\n        this.menuParticleLayer = null;\n        this.resizeHandler = null;\n        this.onStartCallback = null;\n        this.currentScreen = 'main';\n        this.carouselMenu = null;\n        this.factionCarousel = null;\n        this.testLevelButton = null;\n        this.lanServerListTimeout = null; // Track timeout for cleanup\n        this.networkManager = null; // Network manager for LAN play\n        // Hero unit data with complete stats\n        this.heroUnits = [\n            // Radiant faction heroes\n            {\n                id: 'radiant-marine', name: 'Marine', description: 'Rapid-fire ranged specialist', faction: _game_core__WEBPACK_IMPORTED_MODULE_1__.Faction.RADIANT,\n                maxHealth: _constants__WEBPACK_IMPORTED_MODULE_0__.MARINE_MAX_HEALTH, attackDamage: _constants__WEBPACK_IMPORTED_MODULE_0__.MARINE_ATTACK_DAMAGE, attackSpeed: _constants__WEBPACK_IMPORTED_MODULE_0__.MARINE_ATTACK_SPEED,\n                attackRange: _constants__WEBPACK_IMPORTED_MODULE_0__.MARINE_ATTACK_RANGE, attackIgnoresDefense: false, defense: 10, regen: 4,\n                abilityDescription: 'Bullet storm: fires a spread of shots toward a target direction'\n            },\n            {\n                id: 'radiant-grave', name: 'Grave', description: 'Gravitic sentinel with orbiting projectiles', faction: _game_core__WEBPACK_IMPORTED_MODULE_1__.Faction.RADIANT,\n                maxHealth: _constants__WEBPACK_IMPORTED_MODULE_0__.GRAVE_MAX_HEALTH, attackDamage: _constants__WEBPACK_IMPORTED_MODULE_0__.GRAVE_ATTACK_DAMAGE, attackSpeed: _constants__WEBPACK_IMPORTED_MODULE_0__.GRAVE_ATTACK_SPEED,\n                attackRange: _constants__WEBPACK_IMPORTED_MODULE_0__.GRAVE_ATTACK_RANGE * _constants__WEBPACK_IMPORTED_MODULE_0__.GRAVE_HERO_ATTACK_RANGE_MULTIPLIER,\n                attackIgnoresDefense: false, defense: 18, regen: 3,\n                abilityDescription: 'Orbits gravitic shards that launch at targets and return'\n            },\n            {\n                id: 'radiant-ray', name: 'Ray', description: 'Bouncing beam marks targets', faction: _game_core__WEBPACK_IMPORTED_MODULE_1__.Faction.RADIANT,\n                maxHealth: _constants__WEBPACK_IMPORTED_MODULE_0__.RAY_MAX_HEALTH, attackDamage: _constants__WEBPACK_IMPORTED_MODULE_0__.RAY_ATTACK_DAMAGE, attackSpeed: _constants__WEBPACK_IMPORTED_MODULE_0__.RAY_ATTACK_SPEED,\n                attackRange: _constants__WEBPACK_IMPORTED_MODULE_0__.RAY_ATTACK_RANGE, attackIgnoresDefense: true, defense: 8, regen: 5,\n                abilityDescription: 'Solar ricochet: beam bounces between multiple enemies'\n            },\n            {\n                id: 'radiant-influence-ball', name: 'Influence Ball', description: 'Deploys temporary influence zones', faction: _game_core__WEBPACK_IMPORTED_MODULE_1__.Faction.RADIANT,\n                maxHealth: _constants__WEBPACK_IMPORTED_MODULE_0__.INFLUENCE_BALL_MAX_HEALTH, attackDamage: _constants__WEBPACK_IMPORTED_MODULE_0__.INFLUENCE_BALL_ATTACK_DAMAGE, attackSpeed: _constants__WEBPACK_IMPORTED_MODULE_0__.INFLUENCE_BALL_ATTACK_SPEED,\n                attackRange: _constants__WEBPACK_IMPORTED_MODULE_0__.INFLUENCE_BALL_ATTACK_RANGE, attackIgnoresDefense: false, defense: 12, regen: 6,\n                abilityDescription: 'Influence surge: expand an influence zone at target location'\n            },\n            {\n                id: 'radiant-turret-deployer', name: 'Turret Deployer', description: 'Deploys automated turrets on asteroids', faction: _game_core__WEBPACK_IMPORTED_MODULE_1__.Faction.RADIANT,\n                maxHealth: _constants__WEBPACK_IMPORTED_MODULE_0__.TURRET_DEPLOYER_MAX_HEALTH, attackDamage: _constants__WEBPACK_IMPORTED_MODULE_0__.TURRET_DEPLOYER_ATTACK_DAMAGE, attackSpeed: _constants__WEBPACK_IMPORTED_MODULE_0__.TURRET_DEPLOYER_ATTACK_SPEED,\n                attackRange: _constants__WEBPACK_IMPORTED_MODULE_0__.TURRET_DEPLOYER_ATTACK_RANGE, attackIgnoresDefense: false, defense: 14, regen: 4,\n                abilityDescription: 'Deploy turret: places a turret on a nearby asteroid'\n            },\n            {\n                id: 'radiant-driller', name: 'Driller', description: 'Burrows through asteroids to flank', faction: _game_core__WEBPACK_IMPORTED_MODULE_1__.Faction.RADIANT,\n                maxHealth: _constants__WEBPACK_IMPORTED_MODULE_0__.DRILLER_MAX_HEALTH, attackDamage: _constants__WEBPACK_IMPORTED_MODULE_0__.DRILLER_ATTACK_DAMAGE, attackSpeed: _constants__WEBPACK_IMPORTED_MODULE_0__.DRILLER_ATTACK_SPEED,\n                attackRange: _constants__WEBPACK_IMPORTED_MODULE_0__.DRILLER_ATTACK_RANGE, attackIgnoresDefense: false, defense: 16, regen: 3,\n                abilityDescription: 'Drill charge: tunnels through an asteroid toward the target'\n            },\n            {\n                id: 'radiant-dagger', name: 'Dagger', description: 'Cloaked assassin with burst damage', faction: _game_core__WEBPACK_IMPORTED_MODULE_1__.Faction.RADIANT,\n                maxHealth: _constants__WEBPACK_IMPORTED_MODULE_0__.DAGGER_MAX_HEALTH, attackDamage: _constants__WEBPACK_IMPORTED_MODULE_0__.DAGGER_ATTACK_DAMAGE, attackSpeed: _constants__WEBPACK_IMPORTED_MODULE_0__.DAGGER_ATTACK_SPEED,\n                attackRange: _constants__WEBPACK_IMPORTED_MODULE_0__.DAGGER_ATTACK_RANGE, attackIgnoresDefense: false, defense: 5, regen: 3,\n                abilityDescription: 'Shadow strike: short-range burst attack, reveals Dagger for 8 seconds'\n            },\n            {\n                id: 'radiant-beam', name: 'Beam', description: 'Sniper with distance-based damage multiplier', faction: _game_core__WEBPACK_IMPORTED_MODULE_1__.Faction.RADIANT,\n                maxHealth: _constants__WEBPACK_IMPORTED_MODULE_0__.BEAM_MAX_HEALTH, attackDamage: _constants__WEBPACK_IMPORTED_MODULE_0__.BEAM_ATTACK_DAMAGE, attackSpeed: _constants__WEBPACK_IMPORTED_MODULE_0__.BEAM_ATTACK_SPEED,\n                attackRange: _constants__WEBPACK_IMPORTED_MODULE_0__.BEAM_ATTACK_RANGE, attackIgnoresDefense: true, defense: 6, regen: 3,\n                abilityDescription: 'Precision shot: long-range beam that does more damage at greater distances'\n            },\n            {\n                id: 'radiant-mortar', name: 'Mortar', description: 'Siege unit with splash damage', faction: _game_core__WEBPACK_IMPORTED_MODULE_1__.Faction.RADIANT,\n                maxHealth: _constants__WEBPACK_IMPORTED_MODULE_0__.MORTAR_MAX_HEALTH, attackDamage: _constants__WEBPACK_IMPORTED_MODULE_0__.MORTAR_ATTACK_DAMAGE, attackSpeed: _constants__WEBPACK_IMPORTED_MODULE_0__.MORTAR_ATTACK_SPEED,\n                attackRange: _constants__WEBPACK_IMPORTED_MODULE_0__.MORTAR_ATTACK_RANGE, attackIgnoresDefense: false, defense: 14, regen: 2,\n                abilityDescription: 'Siege mode: temporarily becomes immobile but gains increased range and damage'\n            },\n            {\n                id: 'radiant-preist', name: 'Preist', description: 'Support healer with dual beams', faction: _game_core__WEBPACK_IMPORTED_MODULE_1__.Faction.RADIANT,\n                maxHealth: _constants__WEBPACK_IMPORTED_MODULE_0__.PREIST_MAX_HEALTH, attackDamage: 0, attackSpeed: 0,\n                attackRange: _constants__WEBPACK_IMPORTED_MODULE_0__.PREIST_HEALING_RANGE, attackIgnoresDefense: false, defense: 18, regen: 4,\n                abilityDescription: 'Healing bomb: launches a projectile that explodes into healing particles'\n            },\n            {\n                id: 'radiant-tank', name: 'Tank', description: 'Extremely tough defensive unit with projectile shield', faction: _game_core__WEBPACK_IMPORTED_MODULE_1__.Faction.RADIANT,\n                maxHealth: _constants__WEBPACK_IMPORTED_MODULE_0__.TANK_MAX_HEALTH, attackDamage: 0, attackSpeed: 0,\n                attackRange: 0, attackIgnoresDefense: false, defense: _constants__WEBPACK_IMPORTED_MODULE_0__.TANK_DEFENSE, regen: 3,\n                abilityDescription: 'Crescent wave: sends a slow 90-degree wave that stuns all units and erases projectiles'\n            }\n        ];\n        this.availableMaps = [\n            {\n                id: 'standard',\n                name: 'Standard Battle',\n                description: 'Classic 1v1 map with a single sun at the center. Balanced gameplay with moderate obstacles.',\n                numSuns: 1,\n                numAsteroids: 10,\n                mapSize: 2000\n            },\n            {\n                id: 'test-level',\n                name: 'Test Level',\n                description: 'Minimal layout for AI testing with a single sun, mirrored bases, and no asteroids.',\n                numSuns: 1,\n                numAsteroids: 0,\n                mapSize: 2000\n            },\n            {\n                id: 'twin-suns',\n                name: 'Twin Suns',\n                description: 'Two suns create complex lighting patterns. Control multiple light sources for economic dominance.',\n                numSuns: 2,\n                numAsteroids: 12,\n                mapSize: 2500\n            },\n            {\n                id: 'asteroid-field',\n                name: 'Asteroid Field',\n                description: 'Dense asteroid field creates tactical challenges. Careful mirror placement is crucial.',\n                numSuns: 1,\n                numAsteroids: 20,\n                mapSize: 2000\n            },\n            {\n                id: 'open-space',\n                name: 'Open Space',\n                description: 'Minimal obstacles in a vast arena. Pure strategic combat with fewer terrain advantages.',\n                numSuns: 1,\n                numAsteroids: 5,\n                mapSize: 3000\n            }\n        ];\n        this.baseLoadouts = [\n            // Radiant faction bases\n            { id: 'radiant-standard', name: 'Standard Forge', description: 'Balanced base with standard production', faction: _game_core__WEBPACK_IMPORTED_MODULE_1__.Faction.RADIANT },\n            { id: 'radiant-fortified', name: 'Fortified Forge', description: 'Enhanced defensive capabilities with thicker armor', faction: _game_core__WEBPACK_IMPORTED_MODULE_1__.Faction.RADIANT },\n            { id: 'radiant-rapid', name: 'Rapid Forge', description: 'Faster production speed at the cost of durability', faction: _game_core__WEBPACK_IMPORTED_MODULE_1__.Faction.RADIANT },\n            // Aurum faction bases\n            { id: 'aurum-standard', name: 'Standard Vault', description: 'Balanced base with standard production', faction: _game_core__WEBPACK_IMPORTED_MODULE_1__.Faction.AURUM },\n            { id: 'aurum-wealth', name: 'Wealth Vault', description: 'Increased resource generation capacity', faction: _game_core__WEBPACK_IMPORTED_MODULE_1__.Faction.AURUM },\n            { id: 'aurum-compact', name: 'Compact Vault', description: 'Smaller footprint, easier to defend', faction: _game_core__WEBPACK_IMPORTED_MODULE_1__.Faction.AURUM },\n            // Solari faction bases\n            { id: 'solari-standard', name: 'Standard Temple', description: 'Balanced base with standard production', faction: _game_core__WEBPACK_IMPORTED_MODULE_1__.Faction.SOLARI },\n            { id: 'solari-solar', name: 'Solar Temple', description: 'Enhanced solar collection efficiency', faction: _game_core__WEBPACK_IMPORTED_MODULE_1__.Faction.SOLARI },\n            { id: 'solari-titan', name: 'Titan Temple', description: 'Massive health pool, slower to build', faction: _game_core__WEBPACK_IMPORTED_MODULE_1__.Faction.SOLARI },\n        ];\n        this.spawnLoadouts = [\n            // Radiant faction spawns\n            { id: 'radiant-standard', name: 'Standard Starlings', description: 'Balanced minions with standard stats', faction: _game_core__WEBPACK_IMPORTED_MODULE_1__.Faction.RADIANT },\n            { id: 'radiant-swarm', name: 'Swarm Starlings', description: 'More units but weaker individually', faction: _game_core__WEBPACK_IMPORTED_MODULE_1__.Faction.RADIANT },\n            { id: 'radiant-elite', name: 'Elite Starlings', description: 'Fewer units but stronger and more durable', faction: _game_core__WEBPACK_IMPORTED_MODULE_1__.Faction.RADIANT },\n            // Aurum faction spawns\n            { id: 'aurum-standard', name: 'Standard Drones', description: 'Balanced minions with standard stats', faction: _game_core__WEBPACK_IMPORTED_MODULE_1__.Faction.AURUM },\n            { id: 'aurum-harvester', name: 'Harvester Drones', description: 'Gather resources more efficiently', faction: _game_core__WEBPACK_IMPORTED_MODULE_1__.Faction.AURUM },\n            { id: 'aurum-assault', name: 'Assault Drones', description: 'Higher damage output for aggressive play', faction: _game_core__WEBPACK_IMPORTED_MODULE_1__.Faction.AURUM },\n            // Solari faction spawns\n            { id: 'solari-standard', name: 'Standard Zealots', description: 'Balanced minions with standard stats', faction: _game_core__WEBPACK_IMPORTED_MODULE_1__.Faction.SOLARI },\n            { id: 'solari-guardian', name: 'Guardian Zealots', description: 'Tankier units focused on defense', faction: _game_core__WEBPACK_IMPORTED_MODULE_1__.Faction.SOLARI },\n            { id: 'solari-blazing', name: 'Blazing Zealots', description: 'Fast-moving units with fire damage', faction: _game_core__WEBPACK_IMPORTED_MODULE_1__.Faction.SOLARI },\n        ];\n        // Initialize default settings\n        this.settings = {\n            selectedMap: this.availableMaps[0],\n            difficulty: 'normal',\n            soundEnabled: true,\n            musicEnabled: true,\n            isBattleStatsInfoEnabled: false,\n            selectedFaction: _game_core__WEBPACK_IMPORTED_MODULE_1__.Faction.RADIANT,\n            selectedHeroes: ['radiant-marine'],\n            selectedHeroNames: [],\n            playerColor: '#66B3FF', // Somewhat light blue\n            enemyColor: '#FF6B6B', // Slightly light red\n            selectedBaseLoadout: null,\n            selectedSpawnLoadout: null,\n            colorScheme: 'SpaceBlack', // Default color scheme\n            damageDisplayMode: 'damage', // Default to showing damage numbers\n            healthDisplayMode: 'bar', // Default to showing health bars\n            graphicsQuality: 'high', // Default to high graphics\n            username: this.getOrGenerateUsername(), // Load or generate username\n            gameMode: 'ai' // Default to AI mode\n        };\n        this.ensureDefaultHeroSelection();\n        this.menuElement = this.createMenuElement();\n        document.body.appendChild(this.menuElement);\n    }\n    createMenuElement() {\n        const menu = document.createElement('div');\n        menu.id = 'mainMenu';\n        menu.style.position = 'fixed';\n        menu.style.top = '0';\n        menu.style.left = '0';\n        menu.style.width = '100%';\n        menu.style.height = '100%';\n        menu.style.boxSizing = 'border-box';\n        menu.style.backgroundColor = 'transparent';\n        menu.style.zIndex = '1000';\n        menu.style.fontFamily = '\"Doto\", Arial, sans-serif';\n        menu.style.fontWeight = '300';\n        menu.style.fontSize = '24px';\n        menu.style.color = '#FFFFFF';\n        menu.style.overflowY = 'auto';\n        menu.style.overflowX = 'hidden';\n        menu.style.isolation = 'isolate';\n        const content = document.createElement('div');\n        content.style.position = 'relative';\n        content.style.zIndex = '1';\n        content.style.width = '100%';\n        content.style.minHeight = '100%';\n        content.style.padding = '24px 16px';\n        content.style.boxSizing = 'border-box';\n        content.style.display = 'flex';\n        content.style.flexDirection = 'column';\n        content.style.justifyContent = 'center';\n        content.style.alignItems = 'center';\n        menu.appendChild(content);\n        this.contentElement = content;\n        this.backgroundParticleLayer = new BackgroundParticleLayer(menu);\n        this.atmosphereLayer = new MenuAtmosphereLayer(menu, this.resolveAssetPath('ASSETS/sprites/environment/centralSun.svg'));\n        this.menuParticleLayer = new ParticleMenuLayer(menu);\n        this.menuParticleLayer.setMenuContentElement(content);\n        this.testLevelButton = this.createTestLevelButton();\n        menu.appendChild(this.testLevelButton);\n        // Render main screen content into the menu element\n        this.renderMainScreenContent(content);\n        this.resizeHandler = () => {\n            var _a, _b;\n            (_a = this.backgroundParticleLayer) === null || _a === void 0 ? void 0 : _a.resize();\n            (_b = this.atmosphereLayer) === null || _b === void 0 ? void 0 : _b.resize();\n            if (!this.menuParticleLayer) {\n                return;\n            }\n            this.menuParticleLayer.resize();\n            this.menuParticleLayer.requestTargetRefresh(this.contentElement);\n        };\n        window.addEventListener('resize', this.resizeHandler);\n        menu.addEventListener('scroll', () => {\n            var _a;\n            (_a = this.menuParticleLayer) === null || _a === void 0 ? void 0 : _a.requestTargetRefresh(this.contentElement);\n        });\n        return menu;\n    }\n    createTestLevelButton() {\n        const button = document.createElement('button');\n        button.textContent = 'TEST LEVEL';\n        button.type = 'button';\n        button.style.position = 'absolute';\n        button.style.top = '20px';\n        button.style.right = '20px';\n        button.style.padding = '10px 16px';\n        button.style.borderRadius = '6px';\n        button.style.border = '1px solid rgba(255, 255, 255, 0.6)';\n        button.style.backgroundColor = 'rgba(20, 20, 20, 0.7)';\n        button.style.color = '#FFFFFF';\n        button.style.fontFamily = 'Arial, sans-serif';\n        button.style.fontWeight = '500';\n        button.style.fontSize = '14px';\n        button.style.letterSpacing = '0.08em';\n        button.style.cursor = 'pointer';\n        button.style.zIndex = '2';\n        button.style.transition = 'background-color 0.2s ease, border-color 0.2s ease';\n        button.addEventListener('mouseenter', () => {\n            button.style.backgroundColor = 'rgba(60, 60, 60, 0.85)';\n            button.style.borderColor = '#FFD700';\n        });\n        button.addEventListener('mouseleave', () => {\n            button.style.backgroundColor = 'rgba(20, 20, 20, 0.7)';\n            button.style.borderColor = 'rgba(255, 255, 255, 0.6)';\n        });\n        button.addEventListener('click', () => {\n            const testMap = this.availableMaps.find(map => map.id === 'test-level');\n            if (!testMap) {\n                return;\n            }\n            this.settings.selectedMap = testMap;\n            this.hide();\n            if (this.onStartCallback) {\n                this.ensureDefaultHeroSelection();\n                this.onStartCallback(this.settings);\n            }\n        });\n        return button;\n    }\n    setTestLevelButtonVisible(isVisible) {\n        if (!this.testLevelButton) {\n            return;\n        }\n        this.testLevelButton.style.display = isVisible ? 'block' : 'none';\n    }\n    getSelectedHeroNames() {\n        return this.heroUnits\n            .filter(hero => this.settings.selectedHeroes.includes(hero.id))\n            .map(hero => hero.name);\n    }\n    getDefaultHeroIdsForFaction(faction) {\n        void faction;\n        return ['radiant-marine'];\n    }\n    ensureDefaultHeroSelection() {\n        if (this.settings.selectedHeroes.length === 0) {\n            const defaultHeroes = this.getDefaultHeroIdsForFaction(this.settings.selectedFaction);\n            if (defaultHeroes.length > 0) {\n                this.settings.selectedHeroes = [...defaultHeroes];\n            }\n        }\n        this.settings.selectedHeroNames = this.getSelectedHeroNames();\n    }\n    /**\n     * Generate a random username in the format \"player#XXXX\"\n     */\n    generateRandomUsername() {\n        const randomNumber = Math.floor(Math.random() * 10000);\n        return `player#${randomNumber.toString().padStart(4, '0')}`;\n    }\n    /**\n     * Get username from localStorage or generate a new one\n     */\n    getOrGenerateUsername() {\n        const storedUsername = localStorage.getItem('sol_username');\n        if (storedUsername && storedUsername.trim() !== '') {\n            return storedUsername;\n        }\n        const newUsername = this.generateRandomUsername();\n        localStorage.setItem('sol_username', newUsername);\n        return newUsername;\n    }\n    /**\n     * Save username to localStorage\n     */\n    saveUsername(username) {\n        localStorage.setItem('sol_username', username);\n        this.settings.username = username;\n    }\n    resolveAssetPath(path) {\n        if (!path.startsWith('ASSETS/')) {\n            return path;\n        }\n        const isDistBuild = window.location.pathname.includes('/dist/');\n        return isDistBuild ? `../${path}` : path;\n    }\n    clearMenu() {\n        if (this.carouselMenu) {\n            this.carouselMenu.destroy();\n            this.carouselMenu = null;\n        }\n        if (this.factionCarousel) {\n            this.factionCarousel.destroy();\n            this.factionCarousel = null;\n        }\n        if (this.contentElement) {\n            this.contentElement.innerHTML = '';\n            this.contentElement.style.justifyContent = 'center';\n        }\n        // Clear any pending timeouts\n        if (this.lanServerListTimeout !== null) {\n            clearTimeout(this.lanServerListTimeout);\n            this.lanServerListTimeout = null;\n        }\n        this.setTestLevelButtonVisible(false);\n    }\n    setMenuParticleDensity(multiplier) {\n        var _a;\n        const densityScale = 2;\n        (_a = this.menuParticleLayer) === null || _a === void 0 ? void 0 : _a.setDensityMultiplier(multiplier * densityScale);\n    }\n    startMenuTransition() {\n        var _a;\n        (_a = this.menuParticleLayer) === null || _a === void 0 ? void 0 : _a.startTransition();\n    }\n    renderMainScreen(container) {\n        this.clearMenu();\n        this.renderMainScreenContent(container);\n    }\n    renderMainScreenContent(container) {\n        var _a;\n        this.setTestLevelButtonVisible(true);\n        this.setMenuParticleDensity(1.6);\n        const screenWidth = window.innerWidth;\n        const isCompactLayout = screenWidth < 600;\n        container.style.justifyContent = 'flex-start';\n        // Title graphic - raised a little\n        const titleGraphic = document.createElement('img');\n        titleGraphic.src = this.resolveAssetPath('ASSETS/sprites/menu/titleGraphic.svg');\n        titleGraphic.alt = 'Speed of Light RTS';\n        titleGraphic.style.width = isCompactLayout ? '300px' : '480px';\n        titleGraphic.style.maxWidth = '90%';\n        titleGraphic.style.height = 'auto';\n        titleGraphic.style.marginBottom = isCompactLayout ? '6px' : '12px';\n        titleGraphic.style.alignSelf = 'center';\n        container.appendChild(titleGraphic);\n        // Create carousel menu container\n        const carouselContainer = document.createElement('div');\n        carouselContainer.style.width = '100%';\n        carouselContainer.style.maxWidth = isCompactLayout ? '100%' : '900px';\n        carouselContainer.style.padding = isCompactLayout ? '0 10px' : '0';\n        carouselContainer.style.marginTop = '0';\n        carouselContainer.style.marginBottom = isCompactLayout ? '18px' : '20px';\n        container.appendChild(carouselContainer);\n        // Create carousel menu with main menu options\n        const menuOptions = [\n            {\n                id: 'loadout',\n                name: 'LOADOUT',\n                description: 'Select faction & heroes'\n            },\n            {\n                id: 'start',\n                name: 'START',\n                description: 'Begin game'\n            },\n            {\n                id: 'maps',\n                name: 'MAPS',\n                description: 'Select map'\n            },\n            {\n                id: 'settings',\n                name: 'SETTINGS',\n                description: 'Configure game'\n            }\n        ];\n        this.carouselMenu = new CarouselMenuView(carouselContainer, menuOptions, 1, 'rgba(0, 0, 0, 0.5)'); // Default to \"START\" button\n        this.carouselMenu.onRender(() => {\n            var _a;\n            (_a = this.menuParticleLayer) === null || _a === void 0 ? void 0 : _a.requestTargetRefresh(this.contentElement);\n        });\n        this.carouselMenu.onNavigate(() => {\n            var _a;\n            this.startMenuTransition();\n            (_a = this.menuParticleLayer) === null || _a === void 0 ? void 0 : _a.requestTargetRefresh(this.contentElement);\n        });\n        this.carouselMenu.onSelect((option) => {\n            switch (option.id) {\n                case 'loadout':\n                    this.currentScreen = 'faction-select';\n                    this.startMenuTransition();\n                    this.renderFactionSelectionScreen(this.contentElement);\n                    break;\n                case 'start':\n                    this.currentScreen = 'game-mode-select';\n                    this.startMenuTransition();\n                    this.renderGameModeSelectionScreen(this.contentElement);\n                    break;\n                case 'maps':\n                    this.currentScreen = 'maps';\n                    this.startMenuTransition();\n                    this.renderMapSelectionScreen(this.contentElement);\n                    break;\n                case 'settings':\n                    this.currentScreen = 'settings';\n                    this.startMenuTransition();\n                    this.renderSettingsScreen(this.contentElement);\n                    break;\n            }\n        });\n        (_a = this.menuParticleLayer) === null || _a === void 0 ? void 0 : _a.requestTargetRefresh(this.contentElement);\n    }\n    renderMapSelectionScreen(container) {\n        var _a;\n        this.clearMenu();\n        this.setMenuParticleDensity(1.6);\n        const screenWidth = window.innerWidth;\n        const isCompactLayout = screenWidth < 600;\n        // Title\n        const title = document.createElement('h2');\n        title.textContent = 'Select Map';\n        title.style.fontSize = isCompactLayout ? '32px' : '48px';\n        title.style.marginBottom = isCompactLayout ? '20px' : '30px';\n        title.style.color = '#FFD700';\n        title.style.textAlign = 'center';\n        title.style.maxWidth = '100%';\n        title.style.fontWeight = '300';\n        title.dataset.particleText = 'true';\n        title.dataset.particleColor = '#FFD700';\n        container.appendChild(title);\n        // Map grid\n        const mapGrid = document.createElement('div');\n        mapGrid.style.display = 'grid';\n        mapGrid.style.gridTemplateColumns = `repeat(auto-fit, minmax(${isCompactLayout ? 220 : 300}px, 1fr))`;\n        mapGrid.style.gap = '20px';\n        mapGrid.style.maxWidth = '900px';\n        mapGrid.style.padding = '20px';\n        mapGrid.style.marginBottom = '30px';\n        for (const map of this.availableMaps) {\n            const mapCard = document.createElement('div');\n            mapCard.style.backgroundColor = 'rgba(255, 255, 255, 0.05)';\n            mapCard.style.border = '2px solid transparent';\n            mapCard.style.borderRadius = '10px';\n            mapCard.style.padding = '20px';\n            mapCard.style.cursor = 'pointer';\n            mapCard.style.transition = 'all 0.3s';\n            mapCard.dataset.particleBox = 'true';\n            mapCard.dataset.particleColor = map.id === this.settings.selectedMap.id ? '#FFD700' : '#66B3FF';\n            mapCard.addEventListener('mouseenter', () => {\n                if (map.id !== this.settings.selectedMap.id) {\n                    mapCard.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';\n                    mapCard.style.transform = 'scale(1.02)';\n                }\n            });\n            mapCard.addEventListener('mouseleave', () => {\n                mapCard.style.backgroundColor = 'rgba(255, 255, 255, 0.05)';\n                mapCard.style.transform = 'scale(1)';\n            });\n            mapCard.addEventListener('click', () => {\n                this.settings.selectedMap = map;\n                this.renderMapSelectionScreen(this.contentElement);\n            });\n            // Map name\n            const mapName = document.createElement('h3');\n            mapName.textContent = map.name;\n            mapName.style.fontSize = '28px';\n            mapName.style.marginBottom = '10px';\n            mapName.style.color = map.id === this.settings.selectedMap.id ? '#FFD700' : '#FFFFFF';\n            mapName.style.fontWeight = '300';\n            mapName.dataset.particleText = 'true';\n            mapName.dataset.particleColor = map.id === this.settings.selectedMap.id ? '#FFF2B3' : '#E0F2FF';\n            mapCard.appendChild(mapName);\n            // Map description\n            const mapDesc = document.createElement('p');\n            mapDesc.textContent = map.description;\n            mapDesc.style.fontSize = '24px';\n            mapDesc.style.lineHeight = '1.5';\n            mapDesc.style.marginBottom = '15px';\n            mapDesc.style.color = '#CCCCCC';\n            mapDesc.style.fontWeight = '300';\n            mapDesc.dataset.particleText = 'true';\n            mapDesc.dataset.particleColor = '#CCCCCC';\n            mapCard.appendChild(mapDesc);\n            // Map stats\n            const mapStats = document.createElement('div');\n            mapStats.style.fontSize = '24px';\n            mapStats.style.color = '#888888';\n            mapStats.innerHTML = `\n                <div> Suns: ${map.numSuns}</div>\n                <div> Asteroids: ${map.numAsteroids}</div>\n                <div> Size: ${map.mapSize}px</div>\n            `;\n            mapCard.appendChild(mapStats);\n            mapGrid.appendChild(mapCard);\n        }\n        container.appendChild(mapGrid);\n        // Back button\n        const backButton = this.createButton('BACK', () => {\n            this.currentScreen = 'main';\n            this.startMenuTransition();\n            this.renderMainScreen(this.contentElement);\n        }, '#666666');\n        container.appendChild(backButton);\n        (_a = this.menuParticleLayer) === null || _a === void 0 ? void 0 : _a.requestTargetRefresh(this.contentElement);\n    }\n    renderLANScreen(container) {\n        var _a;\n        this.clearMenu();\n        this.setMenuParticleDensity(1.6);\n        const screenWidth = window.innerWidth;\n        const isCompactLayout = screenWidth < 600;\n        // Title\n        const title = document.createElement('h2');\n        title.textContent = 'LAN Play';\n        title.style.fontSize = isCompactLayout ? '32px' : '48px';\n        title.style.marginBottom = isCompactLayout ? '20px' : '30px';\n        title.style.color = '#FFD700';\n        title.style.textAlign = 'center';\n        title.style.maxWidth = '100%';\n        title.style.fontWeight = '300';\n        title.dataset.particleText = 'true';\n        title.dataset.particleColor = '#FFD700';\n        container.appendChild(title);\n        // Host server button\n        const hostButton = this.createButton('HOST SERVER', () => {\n            this.showHostLobbyDialog();\n        }, '#00AA00');\n        hostButton.style.marginBottom = '20px';\n        hostButton.style.padding = '15px 40px';\n        hostButton.style.fontSize = '28px';\n        container.appendChild(hostButton);\n        // Join server button\n        const joinButton = this.createButton('JOIN SERVER', () => {\n            this.showJoinLobbyDialog();\n        }, '#0088FF');\n        joinButton.style.marginBottom = '40px';\n        joinButton.style.padding = '15px 40px';\n        joinButton.style.fontSize = '28px';\n        container.appendChild(joinButton);\n        // Info section\n        const infoContainer = document.createElement('div');\n        infoContainer.style.maxWidth = '600px';\n        infoContainer.style.width = '100%';\n        infoContainer.style.padding = '20px';\n        infoContainer.style.backgroundColor = 'rgba(0, 0, 0, 0.3)';\n        infoContainer.style.borderRadius = '10px';\n        infoContainer.style.border = '2px solid rgba(255, 255, 255, 0.2)';\n        infoContainer.style.marginBottom = '30px';\n        const infoTitle = document.createElement('h3');\n        infoTitle.textContent = 'How LAN Play Works';\n        infoTitle.style.fontSize = '24px';\n        infoTitle.style.marginBottom = '15px';\n        infoTitle.style.color = '#FFD700';\n        infoTitle.style.textAlign = 'center';\n        infoContainer.appendChild(infoTitle);\n        const infoText = document.createElement('p');\n        infoText.innerHTML = `\n            <strong>For Host:</strong><br>\n            1. Click \"HOST SERVER\" to create a lobby<br>\n            2. Share the connection code with other players<br>\n            3. Wait for players to join<br>\n            4. Start the game when ready<br><br>\n            <strong>For Client:</strong><br>\n            1. Click \"JOIN SERVER\"<br>\n            2. Enter the connection code from the host<br>\n            3. Wait in lobby for host to start the game\n        `;\n        infoText.style.color = '#CCCCCC';\n        infoText.style.fontSize = '16px';\n        infoText.style.lineHeight = '1.6';\n        infoContainer.appendChild(infoText);\n        container.appendChild(infoContainer);\n        // Back button\n        const backButton = this.createButton('BACK', () => {\n            this.currentScreen = 'game-mode-select';\n            this.startMenuTransition();\n            this.renderGameModeSelectionScreen(this.contentElement);\n        }, '#666666');\n        container.appendChild(backButton);\n        (_a = this.menuParticleLayer) === null || _a === void 0 ? void 0 : _a.requestTargetRefresh(this.contentElement);\n    }\n    showHostLobbyDialog() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Initialize network manager\n            const playerId = `player_${Date.now()}`;\n            this.networkManager = new _network__WEBPACK_IMPORTED_MODULE_2__.NetworkManager(playerId);\n            // Create lobby\n            const lobbyName = `${this.settings.username}'s lobby`;\n            const lobby = this.networkManager.createLobby(lobbyName, this.settings.username, 2);\n            try {\n                // Generate connection offer\n                const offer = yield this.networkManager.createOfferForPeer('client');\n                const connectionCode = yield _network__WEBPACK_IMPORTED_MODULE_2__.LANSignaling.generateHostCode(offer, playerId, this.settings.username);\n                // Show lobby screen with connection code\n                this.renderHostLobbyScreen(lobby, connectionCode, playerId);\n            }\n            catch (error) {\n                console.error('Failed to create lobby:', error);\n                alert('Failed to create lobby. Please try again.');\n            }\n        });\n    }\n    showJoinLobbyDialog() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Prompt for connection code\n            const code = prompt('Enter the connection code from the host:');\n            if (!code)\n                return;\n            try {\n                // Parse connection code\n                const { offer, playerId: hostId, username: hostUsername } = _network__WEBPACK_IMPORTED_MODULE_2__.LANSignaling.parseHostCode(code);\n                // Initialize network manager\n                const playerId = `player_${Date.now()}`;\n                this.networkManager = new _network__WEBPACK_IMPORTED_MODULE_2__.NetworkManager(playerId);\n                // Create answer\n                const answer = yield this.networkManager.connectToPeer(hostId, offer);\n                const answerCode = yield _network__WEBPACK_IMPORTED_MODULE_2__.LANSignaling.generateAnswerCode(answer, playerId, this.settings.username);\n                // Show dialog with answer code\n                this.renderClientAnswerScreen(answerCode, hostUsername);\n            }\n            catch (error) {\n                console.error('Failed to join lobby:', error);\n                alert(`Failed to join lobby: ${error instanceof Error ? error.message : 'Unknown error'}`);\n            }\n        });\n    }\n    renderHostLobbyScreen(lobby, connectionCode, hostPlayerId) {\n        var _a;\n        this.clearMenu();\n        this.setMenuParticleDensity(1.6);\n        const screenWidth = window.innerWidth;\n        const isCompactLayout = screenWidth < 600;\n        // Title\n        const title = document.createElement('h2');\n        title.textContent = 'Lobby: ' + lobby.name;\n        title.style.fontSize = isCompactLayout ? '28px' : '36px';\n        title.style.marginBottom = '20px';\n        title.style.color = '#FFD700';\n        title.style.textAlign = 'center';\n        title.dataset.particleText = 'true';\n        title.dataset.particleColor = '#FFD700';\n        this.contentElement.appendChild(title);\n        // Connection code display\n        const codeContainer = document.createElement('div');\n        codeContainer.style.maxWidth = '600px';\n        codeContainer.style.width = '100%';\n        codeContainer.style.padding = '20px';\n        codeContainer.style.backgroundColor = 'rgba(0, 100, 0, 0.3)';\n        codeContainer.style.borderRadius = '10px';\n        codeContainer.style.border = '2px solid rgba(0, 255, 0, 0.3)';\n        codeContainer.style.marginBottom = '20px';\n        const codeLabel = document.createElement('p');\n        codeLabel.textContent = 'Share this connection code:';\n        codeLabel.style.color = '#CCCCCC';\n        codeLabel.style.fontSize = '18px';\n        codeLabel.style.marginBottom = '10px';\n        codeContainer.appendChild(codeLabel);\n        const codeText = document.createElement('textarea');\n        codeText.value = connectionCode;\n        codeText.readOnly = true;\n        codeText.style.width = '100%';\n        codeText.style.height = '80px';\n        codeText.style.padding = '10px';\n        codeText.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';\n        codeText.style.color = '#00FF00';\n        codeText.style.border = '1px solid rgba(255, 255, 255, 0.3)';\n        codeText.style.borderRadius = '5px';\n        codeText.style.fontSize = '14px';\n        codeText.style.fontFamily = 'monospace';\n        codeText.style.resize = 'none';\n        codeContainer.appendChild(codeText);\n        const copyButton = this.createButton('COPY CODE', () => __awaiter(this, void 0, void 0, function* () {\n            try {\n                yield navigator.clipboard.writeText(codeText.value);\n                alert('Connection code copied to clipboard!');\n            }\n            catch (err) {\n                // Fallback for older browsers\n                codeText.select();\n                document.execCommand('copy');\n                alert('Connection code copied to clipboard!');\n            }\n        }), '#008800');\n        copyButton.style.marginTop = '10px';\n        copyButton.style.padding = '10px 20px';\n        copyButton.style.fontSize = '16px';\n        codeContainer.appendChild(copyButton);\n        this.contentElement.appendChild(codeContainer);\n        // Waiting for answer code input\n        const answerContainer = document.createElement('div');\n        answerContainer.style.maxWidth = '600px';\n        answerContainer.style.width = '100%';\n        answerContainer.style.padding = '20px';\n        answerContainer.style.backgroundColor = 'rgba(0, 0, 100, 0.3)';\n        answerContainer.style.borderRadius = '10px';\n        answerContainer.style.border = '2px solid rgba(0, 100, 255, 0.3)';\n        answerContainer.style.marginBottom = '30px';\n        const answerLabel = document.createElement('p');\n        answerLabel.textContent = 'Paste the answer code from the client:';\n        answerLabel.style.color = '#CCCCCC';\n        answerLabel.style.fontSize = '18px';\n        answerLabel.style.marginBottom = '10px';\n        answerContainer.appendChild(answerLabel);\n        const answerInput = document.createElement('textarea');\n        answerInput.placeholder = 'Paste answer code here...';\n        answerInput.style.width = '100%';\n        answerInput.style.height = '80px';\n        answerInput.style.padding = '10px';\n        answerInput.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';\n        answerInput.style.color = '#FFFFFF';\n        answerInput.style.border = '1px solid rgba(255, 255, 255, 0.3)';\n        answerInput.style.borderRadius = '5px';\n        answerInput.style.fontSize = '14px';\n        answerInput.style.fontFamily = 'monospace';\n        answerInput.style.resize = 'none';\n        answerContainer.appendChild(answerInput);\n        const connectButton = this.createButton('CONNECT', () => __awaiter(this, void 0, void 0, function* () {\n            var _a;\n            const answerCode = answerInput.value.trim();\n            if (!answerCode) {\n                alert('Please paste the answer code from the client.');\n                return;\n            }\n            try {\n                const { answer, playerId: clientId, username: clientUsername } = _network__WEBPACK_IMPORTED_MODULE_2__.LANSignaling.parseAnswerCode(answerCode);\n                yield ((_a = this.networkManager) === null || _a === void 0 ? void 0 : _a.completeConnection(clientId, answer));\n                // Send lobby update to client\n                if (this.networkManager && this.networkManager.getLobby()) {\n                    const lobby = this.networkManager.getLobby();\n                    lobby.players.push({\n                        id: clientId,\n                        username: clientUsername,\n                        isHost: false,\n                        isReady: true\n                    });\n                    this.networkManager.broadcast({\n                        type: _network__WEBPACK_IMPORTED_MODULE_2__.MessageType.LOBBY_UPDATE,\n                        senderId: hostPlayerId,\n                        timestamp: Date.now(),\n                        data: lobby\n                    });\n                }\n                alert(`${clientUsername} connected! You can now start the game.`);\n            }\n            catch (error) {\n                console.error('Failed to connect client:', error);\n                alert(`Failed to connect: ${error instanceof Error ? error.message : 'Invalid answer code'}`);\n            }\n        }), '#0088FF');\n        connectButton.style.marginTop = '10px';\n        connectButton.style.padding = '10px 20px';\n        connectButton.style.fontSize = '16px';\n        answerContainer.appendChild(connectButton);\n        this.contentElement.appendChild(answerContainer);\n        // Start Game button (only for host)\n        const startGameButton = this.createButton('START GAME', () => {\n            if (!this.networkManager) {\n                alert('Network manager not initialized.');\n                return;\n            }\n            if (this.networkManager.getPeerCount() === 0) {\n                alert('Please wait for at least one player to connect before starting.');\n                return;\n            }\n            // Notify peers that game is starting\n            this.networkManager.startGame();\n            // Set game mode to LAN\n            this.settings.gameMode = 'lan';\n            // Pass network manager to settings\n            this.settings.networkManager = this.networkManager;\n            // Start the game\n            if (this.onStartCallback) {\n                this.hide();\n                this.onStartCallback(this.settings);\n            }\n        }, '#FF8800');\n        startGameButton.style.marginBottom = '20px';\n        startGameButton.style.padding = '15px 40px';\n        startGameButton.style.fontSize = '24px';\n        this.contentElement.appendChild(startGameButton);\n        // Cancel button\n        const cancelButton = this.createButton('CANCEL', () => {\n            if (this.networkManager) {\n                this.networkManager.disconnect();\n                this.networkManager = null;\n            }\n            this.currentScreen = 'lan';\n            this.startMenuTransition();\n            this.renderLANScreen(this.contentElement);\n        }, '#666666');\n        this.contentElement.appendChild(cancelButton);\n        (_a = this.menuParticleLayer) === null || _a === void 0 ? void 0 : _a.requestTargetRefresh(this.contentElement);\n    }\n    renderClientAnswerScreen(answerCode, hostUsername) {\n        var _a, _b;\n        this.clearMenu();\n        this.setMenuParticleDensity(1.6);\n        // Title\n        const title = document.createElement('h2');\n        title.textContent = `Joining ${hostUsername}'s Lobby`;\n        title.style.fontSize = '32px';\n        title.style.marginBottom = '20px';\n        title.style.color = '#FFD700';\n        title.style.textAlign = 'center';\n        title.dataset.particleText = 'true';\n        title.dataset.particleColor = '#FFD700';\n        this.contentElement.appendChild(title);\n        // Instructions\n        const instructions = document.createElement('p');\n        instructions.textContent = 'Send this answer code to the host:';\n        instructions.style.color = '#CCCCCC';\n        instructions.style.fontSize = '18px';\n        instructions.style.textAlign = 'center';\n        instructions.style.marginBottom = '20px';\n        this.contentElement.appendChild(instructions);\n        // Answer code display\n        const codeContainer = document.createElement('div');\n        codeContainer.style.maxWidth = '600px';\n        codeContainer.style.width = '100%';\n        codeContainer.style.padding = '20px';\n        codeContainer.style.backgroundColor = 'rgba(0, 0, 100, 0.3)';\n        codeContainer.style.borderRadius = '10px';\n        codeContainer.style.border = '2px solid rgba(0, 100, 255, 0.3)';\n        codeContainer.style.marginBottom = '30px';\n        const codeText = document.createElement('textarea');\n        codeText.value = answerCode;\n        codeText.readOnly = true;\n        codeText.style.width = '100%';\n        codeText.style.height = '80px';\n        codeText.style.padding = '10px';\n        codeText.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';\n        codeText.style.color = '#0088FF';\n        codeText.style.border = '1px solid rgba(255, 255, 255, 0.3)';\n        codeText.style.borderRadius = '5px';\n        codeText.style.fontSize = '14px';\n        codeText.style.fontFamily = 'monospace';\n        codeText.style.resize = 'none';\n        codeContainer.appendChild(codeText);\n        const copyButton = this.createButton('COPY CODE', () => __awaiter(this, void 0, void 0, function* () {\n            try {\n                yield navigator.clipboard.writeText(codeText.value);\n                alert('Answer code copied to clipboard!');\n            }\n            catch (err) {\n                // Fallback for older browsers\n                codeText.select();\n                document.execCommand('copy');\n                alert('Answer code copied to clipboard!');\n            }\n        }), '#0088FF');\n        copyButton.style.marginTop = '10px';\n        copyButton.style.padding = '10px 20px';\n        copyButton.style.fontSize = '16px';\n        codeContainer.appendChild(copyButton);\n        this.contentElement.appendChild(codeContainer);\n        // Waiting message\n        const waitingText = document.createElement('p');\n        waitingText.textContent = 'Waiting for host to complete connection...';\n        waitingText.style.color = '#888888';\n        waitingText.style.fontSize = '18px';\n        waitingText.style.textAlign = 'center';\n        waitingText.style.marginBottom = '30px';\n        this.contentElement.appendChild(waitingText);\n        // Listen for game start\n        (_a = this.networkManager) === null || _a === void 0 ? void 0 : _a.on(_network__WEBPACK_IMPORTED_MODULE_2__.NetworkEvent.MESSAGE_RECEIVED, (data) => {\n            if (data && data.type === _network__WEBPACK_IMPORTED_MODULE_2__.MessageType.GAME_START) {\n                // Hide menu and start game\n                if (this.onStartCallback) {\n                    this.settings.gameMode = 'lan';\n                    this.settings.networkManager = this.networkManager;\n                    this.hide();\n                    this.onStartCallback(this.settings);\n                }\n            }\n        });\n        // Cancel button\n        const cancelButton = this.createButton('CANCEL', () => {\n            if (this.networkManager) {\n                this.networkManager.disconnect();\n                this.networkManager = null;\n            }\n            this.currentScreen = 'lan';\n            this.startMenuTransition();\n            this.renderLANScreen(this.contentElement);\n        }, '#666666');\n        this.contentElement.appendChild(cancelButton);\n        (_b = this.menuParticleLayer) === null || _b === void 0 ? void 0 : _b.requestTargetRefresh(this.contentElement);\n    }\n    renderClientWaitingScreen() {\n        var _a;\n        this.clearMenu();\n        this.setMenuParticleDensity(1.6);\n        // Title\n        const title = document.createElement('h2');\n        title.textContent = 'Connecting to Host...';\n        title.style.fontSize = '36px';\n        title.style.marginBottom = '30px';\n        title.style.color = '#FFD700';\n        title.style.textAlign = 'center';\n        title.dataset.particleText = 'true';\n        title.dataset.particleColor = '#FFD700';\n        this.contentElement.appendChild(title);\n        // Info text\n        const infoText = document.createElement('p');\n        infoText.textContent = 'Waiting for host to complete the connection...';\n        infoText.style.color = '#CCCCCC';\n        infoText.style.fontSize = '20px';\n        infoText.style.textAlign = 'center';\n        infoText.style.marginBottom = '30px';\n        this.contentElement.appendChild(infoText);\n        // Cancel button\n        const cancelButton = this.createButton('CANCEL', () => {\n            if (this.networkManager) {\n                this.networkManager.disconnect();\n                this.networkManager = null;\n            }\n            this.currentScreen = 'lan';\n            this.startMenuTransition();\n            this.renderLANScreen(this.contentElement);\n        }, '#666666');\n        this.contentElement.appendChild(cancelButton);\n        (_a = this.menuParticleLayer) === null || _a === void 0 ? void 0 : _a.requestTargetRefresh(this.contentElement);\n    }\n    renderOnlinePlaceholderScreen(container) {\n        var _a;\n        this.clearMenu();\n        this.setMenuParticleDensity(1.6);\n        const screenWidth = window.innerWidth;\n        const isCompactLayout = screenWidth < 600;\n        // Title\n        const title = document.createElement('h2');\n        title.textContent = 'Online Play';\n        title.style.fontSize = isCompactLayout ? '32px' : '48px';\n        title.style.marginBottom = isCompactLayout ? '20px' : '30px';\n        title.style.color = '#FFD700';\n        title.style.textAlign = 'center';\n        title.style.maxWidth = '100%';\n        title.style.fontWeight = '300';\n        title.dataset.particleText = 'true';\n        title.dataset.particleColor = '#FFD700';\n        container.appendChild(title);\n        // Coming soon message\n        const message = document.createElement('div');\n        message.style.maxWidth = '600px';\n        message.style.padding = '40px';\n        message.style.backgroundColor = 'rgba(0, 0, 0, 0.3)';\n        message.style.borderRadius = '10px';\n        message.style.border = '2px solid rgba(255, 215, 0, 0.3)';\n        message.style.marginBottom = '30px';\n        const messageTitle = document.createElement('h3');\n        messageTitle.textContent = 'Coming Soon!';\n        messageTitle.style.fontSize = '32px';\n        messageTitle.style.color = '#FFD700';\n        messageTitle.style.textAlign = 'center';\n        messageTitle.style.marginBottom = '20px';\n        messageTitle.style.fontWeight = '300';\n        message.appendChild(messageTitle);\n        const messageText = document.createElement('p');\n        messageText.innerHTML = `\n            Online multiplayer is currently in development.<br><br>\n            <strong>Features:</strong><br>\n             Simple, efficient data transmission<br>\n             Prioritized for speed and minimal data size<br>\n             Cross-platform matchmaking<br>\n             Ranked and casual modes\n        `;\n        messageText.style.fontSize = '20px';\n        messageText.style.color = '#CCCCCC';\n        messageText.style.textAlign = 'center';\n        messageText.style.lineHeight = '1.6';\n        message.appendChild(messageText);\n        container.appendChild(message);\n        // Back button\n        const backButton = this.createButton('BACK', () => {\n            this.currentScreen = 'game-mode-select';\n            this.startMenuTransition();\n            this.renderGameModeSelectionScreen(this.contentElement);\n        }, '#666666');\n        container.appendChild(backButton);\n        (_a = this.menuParticleLayer) === null || _a === void 0 ? void 0 : _a.requestTargetRefresh(this.contentElement);\n    }\n    renderSettingsScreen(container) {\n        var _a;\n        this.clearMenu();\n        this.setMenuParticleDensity(1.6);\n        const screenWidth = window.innerWidth;\n        const isCompactLayout = screenWidth < 600;\n        // Title\n        const title = document.createElement('h2');\n        title.textContent = 'Settings';\n        title.style.fontSize = isCompactLayout ? '32px' : '48px';\n        title.style.marginBottom = isCompactLayout ? '20px' : '30px';\n        title.style.color = '#FFD700';\n        title.style.textAlign = 'center';\n        title.style.maxWidth = '100%';\n        title.style.fontWeight = '300';\n        title.dataset.particleText = 'true';\n        title.dataset.particleColor = '#FFD700';\n        container.appendChild(title);\n        // Settings container\n        const settingsContainer = document.createElement('div');\n        settingsContainer.style.maxWidth = '500px';\n        settingsContainer.style.width = '100%';\n        settingsContainer.style.padding = '20px';\n        // Difficulty setting\n        const difficultySection = this.createSettingSection('Difficulty', this.createSelect(['easy', 'normal', 'hard'], this.settings.difficulty, (value) => {\n            this.settings.difficulty = value;\n        }));\n        settingsContainer.appendChild(difficultySection);\n        // Username setting\n        const usernameSection = this.createSettingSection('Username', this.createTextInput(this.settings.username, (value) => {\n            this.saveUsername(value);\n        }, 'Enter your username'));\n        settingsContainer.appendChild(usernameSection);\n        // Sound setting\n        const soundSection = this.createSettingSection('Sound Effects', this.createToggle(this.settings.soundEnabled, (value) => {\n            this.settings.soundEnabled = value;\n        }));\n        settingsContainer.appendChild(soundSection);\n        // Music setting\n        const musicSection = this.createSettingSection('Music', this.createToggle(this.settings.musicEnabled, (value) => {\n            this.settings.musicEnabled = value;\n        }));\n        settingsContainer.appendChild(musicSection);\n        const battleStatsSection = this.createSettingSection('Battle Stats Info', this.createToggle(this.settings.isBattleStatsInfoEnabled, (value) => {\n            this.settings.isBattleStatsInfoEnabled = value;\n        }));\n        settingsContainer.appendChild(battleStatsSection);\n        // Player Color setting\n        const playerColorSection = this.createSettingSection('Player Color', this.createColorPicker(this.settings.playerColor, (value) => {\n            this.settings.playerColor = value;\n        }));\n        settingsContainer.appendChild(playerColorSection);\n        // Enemy Color setting\n        const enemyColorSection = this.createSettingSection('Enemy Color', this.createColorPicker(this.settings.enemyColor, (value) => {\n            this.settings.enemyColor = value;\n        }));\n        settingsContainer.appendChild(enemyColorSection);\n        // Graphics Quality setting\n        const graphicsQualitySection = this.createSettingSection('Graphics Quality', this.createSelect(['low', 'medium', 'high'], this.settings.graphicsQuality, (value) => {\n            this.settings.graphicsQuality = value;\n        }));\n        settingsContainer.appendChild(graphicsQualitySection);\n        // Color Scheme setting\n        const colorSchemeSection = this.createSettingSection('Color Scheme', this.createSelect(Object.keys(COLOR_SCHEMES), this.settings.colorScheme, (value) => {\n            this.settings.colorScheme = value;\n        }));\n        settingsContainer.appendChild(colorSchemeSection);\n        container.appendChild(settingsContainer);\n        // Back button\n        const backButton = this.createButton('BACK', () => {\n            this.currentScreen = 'main';\n            this.startMenuTransition();\n            this.renderMainScreen(this.contentElement);\n        }, '#666666');\n        backButton.style.marginTop = '30px';\n        container.appendChild(backButton);\n        (_a = this.menuParticleLayer) === null || _a === void 0 ? void 0 : _a.requestTargetRefresh(this.contentElement);\n    }\n    renderGameModeSelectionScreen(container) {\n        var _a;\n        this.clearMenu();\n        this.setMenuParticleDensity(1.6);\n        const screenWidth = window.innerWidth;\n        const isCompactLayout = screenWidth < 600;\n        // Title\n        const title = document.createElement('h2');\n        title.textContent = 'Select Game Mode';\n        title.style.fontSize = isCompactLayout ? '32px' : '48px';\n        title.style.marginBottom = isCompactLayout ? '20px' : '30px';\n        title.style.color = '#FFD700';\n        title.style.textAlign = 'center';\n        title.style.maxWidth = '100%';\n        title.style.fontWeight = '300';\n        title.dataset.particleText = 'true';\n        title.dataset.particleColor = '#FFD700';\n        container.appendChild(title);\n        // Create carousel menu container\n        const carouselContainer = document.createElement('div');\n        carouselContainer.style.width = '100%';\n        carouselContainer.style.maxWidth = isCompactLayout ? '100%' : '900px';\n        carouselContainer.style.padding = isCompactLayout ? '0 10px' : '0';\n        carouselContainer.style.marginBottom = isCompactLayout ? '18px' : '20px';\n        container.appendChild(carouselContainer);\n        // Create game mode options\n        const gameModeOptions = [\n            {\n                id: 'ai',\n                name: 'AI',\n                description: 'Play against computer opponent'\n            },\n            {\n                id: 'online',\n                name: 'ONLINE',\n                description: 'Play against players worldwide'\n            },\n            {\n                id: 'lan',\n                name: 'LAN',\n                description: 'Play on local network'\n            }\n        ];\n        // Default to AI mode (index 0)\n        this.carouselMenu = new CarouselMenuView(carouselContainer, gameModeOptions, 0);\n        this.carouselMenu.onRender(() => {\n            var _a;\n            (_a = this.menuParticleLayer) === null || _a === void 0 ? void 0 : _a.requestTargetRefresh(this.contentElement);\n        });\n        this.carouselMenu.onNavigate(() => {\n            var _a;\n            this.startMenuTransition();\n            (_a = this.menuParticleLayer) === null || _a === void 0 ? void 0 : _a.requestTargetRefresh(this.contentElement);\n        });\n        this.carouselMenu.onSelect((option) => {\n            this.settings.gameMode = option.id;\n            switch (option.id) {\n                case 'ai':\n                    // Start AI game directly\n                    this.hide();\n                    if (this.onStartCallback) {\n                        this.ensureDefaultHeroSelection();\n                        this.onStartCallback(this.settings);\n                    }\n                    break;\n                case 'online':\n                    // Show online play placeholder\n                    this.currentScreen = 'online';\n                    this.startMenuTransition();\n                    this.renderOnlinePlaceholderScreen(this.contentElement);\n                    break;\n                case 'lan':\n                    // Show LAN menu\n                    this.currentScreen = 'lan';\n                    this.startMenuTransition();\n                    this.renderLANScreen(this.contentElement);\n                    break;\n            }\n        });\n        // Back button\n        const backButton = this.createButton('BACK', () => {\n            this.currentScreen = 'main';\n            this.startMenuTransition();\n            this.renderMainScreen(this.contentElement);\n        }, '#666666');\n        backButton.style.marginTop = '30px';\n        container.appendChild(backButton);\n        (_a = this.menuParticleLayer) === null || _a === void 0 ? void 0 : _a.requestTargetRefresh(this.contentElement);\n    }\n    renderFactionSelectionScreen(container) {\n        var _a;\n        this.clearMenu();\n        this.setMenuParticleDensity(1.6);\n        const screenWidth = window.innerWidth;\n        const isCompactLayout = screenWidth < 600;\n        // Title\n        const title = document.createElement('h2');\n        title.textContent = 'Select Your Faction';\n        title.style.fontSize = isCompactLayout ? '32px' : '48px';\n        title.style.marginBottom = isCompactLayout ? '20px' : '30px';\n        title.style.color = '#FFD700';\n        title.style.textAlign = 'center';\n        title.style.maxWidth = '100%';\n        title.style.fontWeight = '300';\n        title.dataset.particleText = 'true';\n        title.dataset.particleColor = '#FFD700';\n        container.appendChild(title);\n        // Faction carousel\n        const carouselContainer = document.createElement('div');\n        carouselContainer.style.width = '100%';\n        carouselContainer.style.maxWidth = isCompactLayout ? '100%' : '900px';\n        carouselContainer.style.padding = isCompactLayout ? '0 10px' : '0';\n        carouselContainer.style.marginBottom = '30px';\n        container.appendChild(carouselContainer);\n        const factions = [\n            {\n                id: _game_core__WEBPACK_IMPORTED_MODULE_1__.Faction.RADIANT,\n                name: 'Radiant',\n                description: 'Well-Balanced, Ranged-Focused',\n                color: '#00AAFF'\n            },\n            {\n                id: _game_core__WEBPACK_IMPORTED_MODULE_1__.Faction.AURUM,\n                name: 'Aurum',\n                description: 'Fast-Paced, Melee-Focused',\n                color: '#FFD700'\n            },\n            {\n                id: _game_core__WEBPACK_IMPORTED_MODULE_1__.Faction.SOLARI,\n                name: 'Solari',\n                description: 'Complex Strategy, Ability-Focused',\n                color: '#FF6600'\n            }\n        ];\n        const selectedIndex = factions.findIndex((faction) => faction.id === this.settings.selectedFaction);\n        const initialIndex = selectedIndex >= 0 ? selectedIndex : 0;\n        if (!this.settings.selectedFaction && factions.length > 0) {\n            this.settings.selectedFaction = factions[initialIndex].id;\n        }\n        this.factionCarousel = new FactionCarouselView(carouselContainer, factions, initialIndex);\n        this.factionCarousel.onSelectionChange((option) => {\n            var _a;\n            if (this.settings.selectedFaction !== option.id) {\n                this.settings.selectedFaction = option.id;\n                this.settings.selectedHeroes = []; // Reset hero selection when faction changes\n                this.ensureDefaultHeroSelection();\n            }\n            (_a = this.menuParticleLayer) === null || _a === void 0 ? void 0 : _a.requestTargetRefresh(this.contentElement);\n        });\n        this.factionCarousel.onRender(() => {\n            var _a;\n            (_a = this.menuParticleLayer) === null || _a === void 0 ? void 0 : _a.requestTargetRefresh(this.contentElement);\n        });\n        // Action buttons\n        const buttonContainer = document.createElement('div');\n        buttonContainer.style.display = 'flex';\n        buttonContainer.style.gap = '20px';\n        buttonContainer.style.marginTop = '20px';\n        buttonContainer.style.flexWrap = 'wrap';\n        buttonContainer.style.justifyContent = 'center';\n        if (isCompactLayout) {\n            buttonContainer.style.flexDirection = 'column';\n            buttonContainer.style.alignItems = 'center';\n        }\n        // Continue button to loadout customization (only enabled if faction is selected)\n        if (this.settings.selectedFaction) {\n            const continueButton = this.createButton('CUSTOMIZE LOADOUT', () => {\n                this.currentScreen = 'loadout-customization';\n                this.startMenuTransition();\n                this.renderLoadoutCustomizationScreen(this.contentElement);\n            }, '#00FF88');\n            buttonContainer.appendChild(continueButton);\n        }\n        // Back button\n        const backButton = this.createButton('BACK', () => {\n            this.currentScreen = 'main';\n            this.startMenuTransition();\n            this.renderMainScreen(this.contentElement);\n        }, '#666666');\n        buttonContainer.appendChild(backButton);\n        container.appendChild(buttonContainer);\n        (_a = this.menuParticleLayer) === null || _a === void 0 ? void 0 : _a.requestTargetRefresh(this.contentElement);\n    }\n    renderLoadoutCustomizationScreen(container) {\n        var _a;\n        this.clearMenu();\n        this.setMenuParticleDensity(1.6);\n        const screenWidth = window.innerWidth;\n        const isCompactLayout = screenWidth < 600;\n        if (!this.settings.selectedFaction) {\n            // Should not happen, but safety fallback\n            this.currentScreen = 'faction-select';\n            this.renderFactionSelectionScreen(container);\n            return;\n        }\n        // Title\n        const title = document.createElement('h2');\n        title.textContent = 'Customize Loadout';\n        title.style.fontSize = isCompactLayout ? '32px' : '48px';\n        title.style.marginBottom = isCompactLayout ? '20px' : '30px';\n        title.style.color = '#FFD700';\n        title.style.textAlign = 'center';\n        title.style.maxWidth = '100%';\n        title.style.fontWeight = 'bold';\n        title.dataset.particleText = 'true';\n        title.dataset.particleColor = '#FFD700';\n        container.appendChild(title);\n        // Get faction-specific loadouts\n        const factionBaseLoadouts = this.baseLoadouts.filter(l => l.faction === this.settings.selectedFaction);\n        const factionSpawnLoadouts = this.spawnLoadouts.filter(l => l.faction === this.settings.selectedFaction);\n        // Set defaults if not selected\n        if (!this.settings.selectedBaseLoadout && factionBaseLoadouts.length > 0) {\n            this.settings.selectedBaseLoadout = factionBaseLoadouts[0].id;\n        }\n        if (!this.settings.selectedSpawnLoadout && factionSpawnLoadouts.length > 0) {\n            this.settings.selectedSpawnLoadout = factionSpawnLoadouts[0].id;\n        }\n        // Main content container\n        const contentContainer = document.createElement('div');\n        contentContainer.style.display = 'flex';\n        contentContainer.style.flexDirection = 'column';\n        contentContainer.style.gap = '40px';\n        contentContainer.style.width = '100%';\n        contentContainer.style.maxWidth = isCompactLayout ? '100%' : '800px';\n        contentContainer.style.padding = isCompactLayout ? '0 10px' : '0 20px';\n        container.appendChild(contentContainer);\n        // Base Loadout Section\n        this.createLoadoutSection(contentContainer, 'Base Loadout', factionBaseLoadouts, this.settings.selectedBaseLoadout, (loadoutId) => { this.settings.selectedBaseLoadout = loadoutId; }, isCompactLayout);\n        // Spawn Loadout Section\n        this.createLoadoutSection(contentContainer, 'Spawn Loadout', factionSpawnLoadouts, this.settings.selectedSpawnLoadout, (loadoutId) => { this.settings.selectedSpawnLoadout = loadoutId; }, isCompactLayout);\n        // Hero Loadout Section (link to hero selection)\n        const heroSection = document.createElement('div');\n        heroSection.style.marginTop = '20px';\n        const heroTitle = document.createElement('h3');\n        heroTitle.textContent = 'Hero Loadout';\n        heroTitle.style.fontSize = isCompactLayout ? '24px' : '32px';\n        heroTitle.style.color = '#00AAFF';\n        heroTitle.style.marginBottom = '15px';\n        heroTitle.style.fontWeight = 'bold';\n        heroTitle.dataset.particleText = 'true';\n        heroTitle.dataset.particleColor = '#00AAFF';\n        heroSection.appendChild(heroTitle);\n        const heroDesc = document.createElement('div');\n        heroDesc.textContent = this.settings.selectedHeroes.length > 0\n            ? `Selected: ${this.settings.selectedHeroNames.join(', ')}`\n            : 'No heroes selected yet';\n        heroDesc.style.fontSize = '20px';\n        heroDesc.style.color = '#CCCCCC';\n        heroDesc.style.marginBottom = '15px';\n        heroSection.appendChild(heroDesc);\n        const selectHeroesBtn = this.createButton('SELECT HEROES', () => {\n            this.currentScreen = 'loadout-select';\n            this.startMenuTransition();\n            this.renderLoadoutSelectionScreen(this.contentElement);\n        }, '#00FF88');\n        heroSection.appendChild(selectHeroesBtn);\n        contentContainer.appendChild(heroSection);\n        // Action buttons\n        const buttonContainer = document.createElement('div');\n        buttonContainer.style.display = 'flex';\n        buttonContainer.style.gap = '20px';\n        buttonContainer.style.marginTop = '30px';\n        buttonContainer.style.flexWrap = 'wrap';\n        buttonContainer.style.justifyContent = 'center';\n        if (isCompactLayout) {\n            buttonContainer.style.flexDirection = 'column';\n            buttonContainer.style.alignItems = 'center';\n        }\n        // Back button\n        const backButton = this.createButton('BACK', () => {\n            this.currentScreen = 'faction-select';\n            this.startMenuTransition();\n            this.renderFactionSelectionScreen(this.contentElement);\n        }, '#666666');\n        buttonContainer.appendChild(backButton);\n        container.appendChild(buttonContainer);\n        (_a = this.menuParticleLayer) === null || _a === void 0 ? void 0 : _a.requestTargetRefresh(this.contentElement);\n    }\n    createLoadoutSection(container, title, loadouts, selectedId, onSelect, isCompact) {\n        const section = document.createElement('div');\n        const sectionTitle = document.createElement('h3');\n        sectionTitle.textContent = title;\n        sectionTitle.style.fontSize = isCompact ? '24px' : '32px';\n        sectionTitle.style.color = '#00AAFF';\n        sectionTitle.style.marginBottom = '15px';\n        sectionTitle.style.fontWeight = 'bold';\n        sectionTitle.dataset.particleText = 'true';\n        sectionTitle.dataset.particleColor = '#00AAFF';\n        section.appendChild(sectionTitle);\n        const optionsContainer = document.createElement('div');\n        optionsContainer.style.display = 'flex';\n        optionsContainer.style.flexDirection = 'column';\n        optionsContainer.style.gap = '10px';\n        loadouts.forEach(loadout => {\n            const isSelected = loadout.id === selectedId;\n            const optionDiv = document.createElement('div');\n            optionDiv.style.padding = '15px';\n            optionDiv.style.backgroundColor = isSelected ? 'rgba(0, 170, 255, 0.2)' : 'rgba(0, 0, 0, 0.3)';\n            optionDiv.style.border = isSelected ? '2px solid #00AAFF' : '2px solid rgba(255, 255, 255, 0.2)';\n            optionDiv.style.borderRadius = '8px';\n            optionDiv.style.cursor = 'pointer';\n            optionDiv.style.transition = 'all 0.2s';\n            const nameDiv = document.createElement('div');\n            nameDiv.textContent = loadout.name;\n            nameDiv.style.fontSize = '22px';\n            nameDiv.style.color = isSelected ? '#00AAFF' : '#FFFFFF';\n            nameDiv.style.fontWeight = 'bold';\n            nameDiv.style.marginBottom = '5px';\n            nameDiv.dataset.particleText = 'true';\n            nameDiv.dataset.particleColor = isSelected ? '#00AAFF' : '#FFFFFF';\n            optionDiv.appendChild(nameDiv);\n            const descDiv = document.createElement('div');\n            descDiv.textContent = loadout.description;\n            descDiv.style.fontSize = '18px';\n            descDiv.style.color = '#CCCCCC';\n            optionDiv.appendChild(descDiv);\n            optionDiv.addEventListener('click', () => {\n                onSelect(loadout.id);\n                this.renderLoadoutCustomizationScreen(this.contentElement);\n            });\n            optionDiv.addEventListener('mouseenter', () => {\n                if (!isSelected) {\n                    optionDiv.style.backgroundColor = 'rgba(0, 170, 255, 0.1)';\n                    optionDiv.style.borderColor = '#00AAFF';\n                }\n            });\n            optionDiv.addEventListener('mouseleave', () => {\n                if (!isSelected) {\n                    optionDiv.style.backgroundColor = 'rgba(0, 0, 0, 0.3)';\n                    optionDiv.style.borderColor = 'rgba(255, 255, 255, 0.2)';\n                }\n            });\n            optionsContainer.appendChild(optionDiv);\n        });\n        section.appendChild(optionsContainer);\n        container.appendChild(section);\n    }\n    renderLoadoutSelectionScreen(container) {\n        var _a;\n        this.clearMenu();\n        this.setMenuParticleDensity(1.6);\n        const screenWidth = window.innerWidth;\n        const isCompactLayout = screenWidth < 600;\n        if (!this.settings.selectedFaction) {\n            // Shouldn't happen, but handle gracefully\n            this.renderFactionSelectionScreen(container);\n            return;\n        }\n        // Title\n        const title = document.createElement('h2');\n        title.textContent = `Select 4 Heroes - ${this.settings.selectedFaction}`;\n        title.style.fontSize = isCompactLayout ? '28px' : '42px';\n        title.style.marginBottom = isCompactLayout ? '15px' : '20px';\n        title.style.color = '#FFD700';\n        title.style.textAlign = 'center';\n        title.style.maxWidth = '100%';\n        title.style.fontWeight = '300';\n        title.dataset.particleText = 'true';\n        title.dataset.particleColor = '#FFD700';\n        container.appendChild(title);\n        // Selection counter\n        const counter = document.createElement('div');\n        counter.textContent = `Selected: ${this.settings.selectedHeroes.length} / 4`;\n        counter.style.fontSize = isCompactLayout ? '24px' : '26px';\n        counter.style.marginBottom = isCompactLayout ? '20px' : '30px';\n        counter.style.color = this.settings.selectedHeroes.length === 4 ? '#00FF88' : '#CCCCCC';\n        counter.style.fontWeight = '300';\n        counter.dataset.particleText = 'true';\n        counter.dataset.particleColor = this.settings.selectedHeroes.length === 4 ? '#00FF88' : '#CCCCCC';\n        container.appendChild(counter);\n        // Hero grid\n        const heroGrid = document.createElement('div');\n        heroGrid.style.display = 'grid';\n        heroGrid.style.gridTemplateColumns = isCompactLayout\n            ? 'repeat(2, minmax(0, 1fr))'\n            : 'repeat(auto-fit, minmax(280px, 1fr))';\n        heroGrid.style.gap = '15px';\n        heroGrid.style.maxWidth = '1200px';\n        heroGrid.style.padding = '20px';\n        heroGrid.style.marginBottom = '20px';\n        heroGrid.style.maxHeight = isCompactLayout ? 'none' : '600px';\n        heroGrid.style.overflowY = isCompactLayout ? 'visible' : 'auto';\n        // Filter heroes by selected faction\n        const factionHeroes = this.heroUnits.filter(hero => hero.faction === this.settings.selectedFaction);\n        for (const hero of factionHeroes) {\n            const isSelected = this.settings.selectedHeroes.includes(hero.id);\n            const canSelect = isSelected || this.settings.selectedHeroes.length < 4;\n            const heroCard = document.createElement('div');\n            heroCard.style.backgroundColor = isSelected ? 'rgba(0, 255, 136, 0.1)' : 'rgba(255, 255, 255, 0.05)';\n            heroCard.style.border = '2px solid transparent';\n            heroCard.style.borderRadius = '10px';\n            heroCard.style.padding = '15px';\n            heroCard.style.cursor = canSelect ? 'pointer' : 'not-allowed';\n            heroCard.style.transition = 'all 0.3s';\n            heroCard.style.opacity = canSelect ? '1' : '0.5';\n            heroCard.style.minHeight = '300px';\n            heroCard.dataset.particleBox = 'true';\n            heroCard.dataset.particleColor = isSelected ? '#00FF88' : '#66B3FF';\n            if (canSelect) {\n                heroCard.addEventListener('mouseenter', () => {\n                    if (!isSelected) {\n                        heroCard.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';\n                        heroCard.style.transform = 'scale(1.02)';\n                    }\n                });\n                heroCard.addEventListener('mouseleave', () => {\n                    heroCard.style.backgroundColor = isSelected ? 'rgba(0, 255, 136, 0.1)' : 'rgba(255, 255, 255, 0.05)';\n                    heroCard.style.transform = 'scale(1)';\n                });\n                heroCard.addEventListener('click', () => {\n                    if (isSelected) {\n                        // Deselect hero\n                        this.settings.selectedHeroes = this.settings.selectedHeroes.filter(id => id !== hero.id);\n                    }\n                    else if (this.settings.selectedHeroes.length < 4) {\n                        // Select hero\n                        this.settings.selectedHeroes.push(hero.id);\n                    }\n                    this.renderLoadoutSelectionScreen(this.contentElement);\n                });\n            }\n            // Hero name\n            const heroName = document.createElement('h4');\n            heroName.textContent = hero.name;\n            heroName.style.fontSize = '24px';\n            heroName.style.marginBottom = '8px';\n            heroName.style.color = isSelected ? '#00FF88' : '#E0F2FF';\n            heroName.style.fontWeight = '300';\n            heroName.dataset.particleText = 'true';\n            heroName.dataset.particleColor = isSelected ? '#00FF88' : '#E0F2FF';\n            heroCard.appendChild(heroName);\n            // Hero description\n            const heroDesc = document.createElement('p');\n            heroDesc.textContent = hero.description;\n            heroDesc.style.fontSize = '24px';\n            heroDesc.style.lineHeight = '1.4';\n            heroDesc.style.color = '#AAAAAA';\n            heroDesc.style.marginBottom = '10px';\n            heroDesc.style.fontWeight = '300';\n            heroDesc.dataset.particleText = 'true';\n            heroDesc.dataset.particleColor = '#AAAAAA';\n            heroCard.appendChild(heroDesc);\n            // Stats section\n            const statsContainer = document.createElement('div');\n            statsContainer.style.fontSize = '24px';\n            statsContainer.style.lineHeight = '1.6';\n            statsContainer.style.color = '#CCCCCC';\n            statsContainer.style.marginBottom = '8px';\n            statsContainer.style.padding = '8px';\n            statsContainer.style.backgroundColor = 'rgba(0, 0, 0, 0.3)';\n            statsContainer.style.borderRadius = '5px';\n            statsContainer.style.fontWeight = '300';\n            // Create stat rows\n            const healthStat = document.createElement('div');\n            healthStat.textContent = `HP: ${hero.maxHealth}`;\n            healthStat.style.color = '#CCCCCC';\n            healthStat.style.fontWeight = 'bold';\n            healthStat.dataset.particleText = 'true';\n            healthStat.dataset.particleColor = '#CCCCCC';\n            statsContainer.appendChild(healthStat);\n            const regenStat = document.createElement('div');\n            regenStat.textContent = `RGN: ${hero.regen}%`;\n            regenStat.style.color = '#CCCCCC';\n            regenStat.style.fontWeight = 'bold';\n            regenStat.dataset.particleText = 'true';\n            regenStat.dataset.particleColor = '#CCCCCC';\n            statsContainer.appendChild(regenStat);\n            const defenseStat = document.createElement('div');\n            defenseStat.textContent = `DEF: ${hero.defense}%`;\n            defenseStat.style.color = '#CCCCCC';\n            defenseStat.style.fontWeight = 'bold';\n            defenseStat.dataset.particleText = 'true';\n            defenseStat.dataset.particleColor = '#CCCCCC';\n            statsContainer.appendChild(defenseStat);\n            const attackStat = document.createElement('div');\n            const attackSuffix = hero.attackIgnoresDefense ? ' (ignores defense)' : '';\n            attackStat.textContent = `ATK: ${hero.attackDamage}${attackSuffix}`;\n            attackStat.style.color = '#CCCCCC';\n            attackStat.style.fontWeight = 'bold';\n            attackStat.dataset.particleText = 'true';\n            attackStat.dataset.particleColor = '#CCCCCC';\n            statsContainer.appendChild(attackStat);\n            const attackSpeedStat = document.createElement('div');\n            attackSpeedStat.textContent = `SPD: ${hero.attackSpeed}/s`;\n            attackSpeedStat.style.color = '#CCCCCC';\n            attackSpeedStat.style.fontWeight = 'bold';\n            attackSpeedStat.dataset.particleText = 'true';\n            attackSpeedStat.dataset.particleColor = '#CCCCCC';\n            statsContainer.appendChild(attackSpeedStat);\n            const rangeStat = document.createElement('div');\n            rangeStat.textContent = `RNG: ${hero.attackRange}`;\n            rangeStat.style.color = '#CCCCCC';\n            rangeStat.style.fontWeight = 'bold';\n            rangeStat.dataset.particleText = 'true';\n            rangeStat.dataset.particleColor = '#CCCCCC';\n            statsContainer.appendChild(rangeStat);\n            heroCard.appendChild(statsContainer);\n            // Ability description\n            const abilityDesc = document.createElement('div');\n            abilityDesc.style.fontSize = '24px';\n            abilityDesc.style.lineHeight = '1.4';\n            abilityDesc.style.color = '#FFD700';\n            abilityDesc.style.marginBottom = '8px';\n            abilityDesc.style.fontStyle = 'italic';\n            abilityDesc.style.fontWeight = 'bold';\n            abilityDesc.textContent = `${hero.abilityDescription}`;\n            abilityDesc.dataset.particleText = 'true';\n            abilityDesc.dataset.particleColor = '#FFD700';\n            heroCard.appendChild(abilityDesc);\n            // Selection indicator\n            if (isSelected) {\n                const indicator = document.createElement('div');\n                indicator.textContent = ' Selected';\n                indicator.style.fontSize = '24px';\n                indicator.style.marginTop = '8px';\n                indicator.style.color = '#00FF88';\n                indicator.style.fontWeight = '300';\n                indicator.dataset.particleText = 'true';\n                indicator.dataset.particleColor = '#00FF88';\n                heroCard.appendChild(indicator);\n            }\n            heroGrid.appendChild(heroCard);\n        }\n        container.appendChild(heroGrid);\n        // Action buttons\n        const buttonContainer = document.createElement('div');\n        buttonContainer.style.display = 'flex';\n        buttonContainer.style.gap = '20px';\n        buttonContainer.style.marginTop = '20px';\n        buttonContainer.style.flexWrap = 'wrap';\n        buttonContainer.style.justifyContent = 'center';\n        if (isCompactLayout) {\n            buttonContainer.style.flexDirection = 'column';\n            buttonContainer.style.alignItems = 'center';\n        }\n        // Confirm button (only enabled if 4 heroes selected)\n        if (this.settings.selectedHeroes.length === 4) {\n            const confirmButton = this.createButton('CONFIRM LOADOUT', () => {\n                this.currentScreen = 'main';\n                this.startMenuTransition();\n                this.renderMainScreen(this.contentElement);\n            }, '#00FF88');\n            buttonContainer.appendChild(confirmButton);\n        }\n        // Back button\n        const backButton = this.createButton('BACK', () => {\n            this.currentScreen = 'loadout-customization';\n            this.startMenuTransition();\n            this.renderLoadoutCustomizationScreen(this.contentElement);\n        }, '#666666');\n        buttonContainer.appendChild(backButton);\n        container.appendChild(buttonContainer);\n        (_a = this.menuParticleLayer) === null || _a === void 0 ? void 0 : _a.requestTargetRefresh(this.contentElement);\n    }\n    createButton(text, onClick, color = '#FFD700') {\n        const button = document.createElement('button');\n        button.textContent = text;\n        button.style.fontSize = '24px';\n        button.style.padding = '15px 40px';\n        button.style.backgroundColor = 'rgba(0, 0, 0, 0.35)';\n        button.style.color = color === '#666666' ? '#FFFFFF' : color;\n        button.style.border = '2px solid transparent';\n        button.style.borderRadius = '5px';\n        button.style.cursor = 'pointer';\n        button.style.fontWeight = '300';\n        button.style.fontFamily = 'inherit';\n        button.style.transition = 'all 0.3s';\n        button.dataset.particleBox = 'true';\n        button.dataset.particleColor = color;\n        button.addEventListener('mouseenter', () => {\n            button.style.backgroundColor = 'rgba(255, 255, 255, 0.12)';\n            button.style.transform = 'scale(1.05)';\n        });\n        button.addEventListener('mouseleave', () => {\n            button.style.backgroundColor = 'rgba(0, 0, 0, 0.35)';\n            button.style.transform = 'scale(1)';\n        });\n        button.addEventListener('click', onClick);\n        return button;\n    }\n    createSettingSection(label, control) {\n        const section = document.createElement('div');\n        section.style.marginBottom = '30px';\n        section.style.display = 'flex';\n        section.style.justifyContent = 'space-between';\n        section.style.alignItems = 'center';\n        const labelElement = document.createElement('label');\n        labelElement.textContent = label;\n        labelElement.style.fontSize = '24px';\n        labelElement.style.color = '#FFFFFF';\n        labelElement.style.fontWeight = '300';\n        labelElement.dataset.particleText = 'true';\n        labelElement.dataset.particleColor = '#FFFFFF';\n        section.appendChild(labelElement);\n        section.appendChild(control);\n        return section;\n    }\n    createSelect(options, currentValue, onChange) {\n        const select = document.createElement('select');\n        select.style.fontSize = '24px';\n        select.style.padding = '8px 15px';\n        select.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';\n        select.style.color = '#FFFFFF';\n        select.style.border = '2px solid rgba(255, 255, 255, 0.3)';\n        select.style.borderRadius = '5px';\n        select.style.cursor = 'pointer';\n        select.style.fontFamily = 'inherit';\n        select.style.fontWeight = '300';\n        for (const option of options) {\n            const optionElement = document.createElement('option');\n            optionElement.value = option;\n            optionElement.textContent = option.charAt(0).toUpperCase() + option.slice(1);\n            optionElement.selected = option === currentValue;\n            optionElement.style.backgroundColor = _constants__WEBPACK_IMPORTED_MODULE_0__.UI_BACKGROUND_COLOR;\n            select.appendChild(optionElement);\n        }\n        select.addEventListener('change', () => {\n            onChange(select.value);\n        });\n        return select;\n    }\n    createToggle(currentValue, onChange) {\n        const toggleContainer = document.createElement('div');\n        toggleContainer.style.display = 'flex';\n        toggleContainer.style.alignItems = 'center';\n        toggleContainer.style.gap = '10px';\n        const toggle = document.createElement('div');\n        toggle.style.width = '60px';\n        toggle.style.height = '30px';\n        toggle.style.backgroundColor = currentValue ? '#00FF88' : '#666666';\n        toggle.style.borderRadius = '15px';\n        toggle.style.position = 'relative';\n        toggle.style.cursor = 'pointer';\n        toggle.style.transition = 'all 0.3s';\n        const knob = document.createElement('div');\n        knob.style.width = '26px';\n        knob.style.height = '26px';\n        knob.style.backgroundColor = '#FFFFFF';\n        knob.style.borderRadius = '50%';\n        knob.style.position = 'absolute';\n        knob.style.top = '2px';\n        knob.style.left = currentValue ? '32px' : '2px';\n        knob.style.transition = 'all 0.3s';\n        toggle.appendChild(knob);\n        toggle.addEventListener('click', () => {\n            const newValue = !currentValue;\n            currentValue = newValue;\n            toggle.style.backgroundColor = newValue ? '#00FF88' : '#666666';\n            knob.style.left = newValue ? '32px' : '2px';\n            onChange(newValue);\n        });\n        toggleContainer.appendChild(toggle);\n        return toggleContainer;\n    }\n    createColorPicker(currentValue, onChange) {\n        const container = document.createElement('div');\n        container.style.display = 'flex';\n        container.style.alignItems = 'center';\n        container.style.gap = '10px';\n        // Color preview box\n        const preview = document.createElement('div');\n        preview.style.width = '40px';\n        preview.style.height = '40px';\n        preview.style.backgroundColor = currentValue;\n        preview.style.border = '2px solid rgba(255, 255, 255, 0.3)';\n        preview.style.borderRadius = '5px';\n        preview.style.cursor = 'pointer';\n        // Hidden color input\n        const input = document.createElement('input');\n        input.type = 'color';\n        input.value = currentValue;\n        input.style.opacity = '0';\n        input.style.width = '0';\n        input.style.height = '0';\n        input.style.position = 'absolute';\n        input.addEventListener('change', () => {\n            preview.style.backgroundColor = input.value;\n            onChange(input.value);\n        });\n        preview.addEventListener('click', () => {\n            input.click();\n        });\n        container.appendChild(preview);\n        container.appendChild(input);\n        return container;\n    }\n    /**\n     * Validate and sanitize username\n     */\n    validateUsername(username) {\n        // Trim and limit length\n        let sanitized = username.trim().substring(0, 20);\n        // If empty or invalid, generate random username\n        if (sanitized.length < 1) {\n            return this.generateRandomUsername();\n        }\n        return sanitized;\n    }\n    createTextInput(currentValue, onChange, placeholder = '') {\n        const input = document.createElement('input');\n        input.type = 'text';\n        input.value = currentValue;\n        input.placeholder = placeholder;\n        input.style.fontSize = '20px';\n        input.style.padding = '8px 15px';\n        input.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';\n        input.style.color = '#FFFFFF';\n        input.style.border = '2px solid rgba(255, 255, 255, 0.3)';\n        input.style.borderRadius = '5px';\n        input.style.fontFamily = 'inherit';\n        input.style.fontWeight = '300';\n        input.style.minWidth = '200px';\n        input.maxLength = 20;\n        input.style.outline = 'none';\n        // Update on blur instead of every keystroke for efficiency\n        input.addEventListener('blur', () => {\n            const validatedValue = this.validateUsername(input.value);\n            input.value = validatedValue;\n            input.style.borderColor = 'rgba(255, 255, 255, 0.3)';\n            onChange(validatedValue);\n        });\n        input.addEventListener('focus', () => {\n            input.style.borderColor = 'rgba(255, 255, 255, 0.6)';\n        });\n        return input;\n    }\n    /**\n     * Set callback for when start button is clicked\n     */\n    onStart(callback) {\n        this.onStartCallback = callback;\n    }\n    /**\n     * Hide the menu\n     */\n    hide() {\n        var _a, _b, _c;\n        this.menuElement.style.display = 'none';\n        (_a = this.backgroundParticleLayer) === null || _a === void 0 ? void 0 : _a.stop();\n        (_b = this.atmosphereLayer) === null || _b === void 0 ? void 0 : _b.stop();\n        (_c = this.menuParticleLayer) === null || _c === void 0 ? void 0 : _c.stop();\n    }\n    /**\n     * Show the menu\n     */\n    show() {\n        var _a, _b, _c;\n        this.menuElement.style.display = 'block';\n        this.currentScreen = 'main';\n        this.renderMainScreen(this.contentElement);\n        (_a = this.backgroundParticleLayer) === null || _a === void 0 ? void 0 : _a.start();\n        (_b = this.atmosphereLayer) === null || _b === void 0 ? void 0 : _b.start();\n        (_c = this.menuParticleLayer) === null || _c === void 0 ? void 0 : _c.start();\n    }\n    /**\n     * Remove the menu from DOM\n     */\n    destroy() {\n        var _a, _b, _c;\n        if (this.carouselMenu) {\n            this.carouselMenu.destroy();\n            this.carouselMenu = null;\n        }\n        if (this.factionCarousel) {\n            this.factionCarousel.destroy();\n            this.factionCarousel = null;\n        }\n        if (this.resizeHandler) {\n            window.removeEventListener('resize', this.resizeHandler);\n        }\n        (_a = this.backgroundParticleLayer) === null || _a === void 0 ? void 0 : _a.destroy();\n        (_b = this.atmosphereLayer) === null || _b === void 0 ? void 0 : _b.destroy();\n        (_c = this.menuParticleLayer) === null || _c === void 0 ? void 0 : _c.stop();\n        if (this.menuElement.parentNode) {\n            this.menuElement.parentNode.removeChild(this.menuElement);\n        }\n    }\n    /**\n     * Get current settings\n     */\n    getSettings() {\n        return this.settings;\n    }\n}\n/**\n * Faction carousel view - displays factions in a horizontal carousel\n */\nclass FactionCarouselView {\n    constructor(container, options, initialIndex) {\n        this.scrollOffset = 0;\n        this.isDragging = false;\n        this.dragStartX = 0;\n        this.dragStartOffset = 0;\n        this.lastDragDeltaX = 0;\n        this.velocity = 0;\n        this.hasDragged = false;\n        this.isCompactLayout = false;\n        this.resizeHandler = null;\n        this.keydownHandler = null;\n        this.onSelectionChangeCallback = null;\n        this.onRenderCallback = null;\n        this.animationFrameId = null;\n        this.container = container;\n        this.options = options;\n        this.currentIndex = Math.max(0, Math.min(options.length - 1, initialIndex));\n        this.targetIndex = this.currentIndex;\n        this.setupContainer();\n        this.setupEventHandlers();\n        this.scrollOffset = -this.currentIndex * this.getItemSpacingPx();\n        this.startAnimation();\n    }\n    setupContainer() {\n        this.container.style.position = 'relative';\n        this.container.style.width = '100%';\n        this.updateLayoutMetrics();\n        this.container.style.overflow = 'hidden';\n        this.container.style.cursor = 'grab';\n        this.container.style.userSelect = 'none';\n        this.container.style.touchAction = 'pan-y';\n    }\n    setupEventHandlers() {\n        this.resizeHandler = () => {\n            this.updateLayoutMetrics();\n        };\n        window.addEventListener('resize', this.resizeHandler);\n        this.keydownHandler = (event) => {\n            const target = event.target;\n            if (target && (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA')) {\n                return;\n            }\n            const key = event.key.toLowerCase();\n            if (key === 'arrowleft' || key === 'a') {\n                this.moveSelection(-1);\n                event.preventDefault();\n            }\n            if (key === 'arrowright' || key === 'd') {\n                this.moveSelection(1);\n                event.preventDefault();\n            }\n        };\n        window.addEventListener('keydown', this.keydownHandler);\n        this.container.addEventListener('mousedown', (event) => {\n            this.startDrag(event.clientX);\n            event.preventDefault();\n        });\n        this.container.addEventListener('mousemove', (event) => {\n            if (this.isDragging) {\n                this.updateDrag(event.clientX);\n                event.preventDefault();\n            }\n        });\n        this.container.addEventListener('mouseup', (event) => {\n            this.endDrag(event.clientX);\n            event.preventDefault();\n        });\n        this.container.addEventListener('mouseleave', () => {\n            if (this.isDragging) {\n                this.endDrag(this.dragStartX);\n            }\n        });\n        this.container.addEventListener('touchstart', (event) => {\n            if (event.touches.length === 1) {\n                this.startDrag(event.touches[0].clientX);\n                event.preventDefault();\n            }\n        }, { passive: false });\n        this.container.addEventListener('touchmove', (event) => {\n            if (this.isDragging && event.touches.length === 1) {\n                this.updateDrag(event.touches[0].clientX);\n                event.preventDefault();\n            }\n        }, { passive: false });\n        this.container.addEventListener('touchend', (event) => {\n            if (this.isDragging) {\n                const touch = event.changedTouches[0];\n                this.endDrag(touch.clientX);\n                event.preventDefault();\n            }\n        }, { passive: false });\n    }\n    startDrag(x) {\n        this.isDragging = true;\n        this.dragStartX = x;\n        this.dragStartOffset = this.scrollOffset;\n        this.velocity = 0;\n        this.hasDragged = false;\n        this.lastDragDeltaX = 0;\n        this.container.style.cursor = 'grabbing';\n    }\n    updateDrag(x) {\n        if (!this.isDragging)\n            return;\n        const deltaX = x - this.dragStartX;\n        this.lastDragDeltaX = deltaX;\n        this.scrollOffset = this.dragStartOffset + deltaX;\n        this.velocity = deltaX * FactionCarouselView.VELOCITY_MULTIPLIER;\n        if (Math.abs(deltaX) > _constants__WEBPACK_IMPORTED_MODULE_0__.CLICK_DRAG_THRESHOLD) {\n            this.hasDragged = true;\n        }\n    }\n    endDrag(x) {\n        if (!this.isDragging)\n            return;\n        this.isDragging = false;\n        this.container.style.cursor = 'grab';\n        if (!this.hasDragged) {\n            this.handleClick(x);\n            return;\n        }\n        const itemWidthPx = this.getItemSpacingPx();\n        const deltaX = this.lastDragDeltaX;\n        if (Math.abs(deltaX) >= FactionCarouselView.SWIPE_THRESHOLD_PX) {\n            const direction = deltaX < 0 ? 1 : -1;\n            this.setCurrentIndex(this.currentIndex + direction);\n            return;\n        }\n        const targetIndexFloat = -this.scrollOffset / itemWidthPx;\n        const targetIndex = Math.round(targetIndexFloat + this.velocity * FactionCarouselView.VELOCITY_FACTOR);\n        this.setCurrentIndex(targetIndex);\n    }\n    handleClick(x) {\n        const rect = this.container.getBoundingClientRect();\n        const centerX = rect.width / 2;\n        const relativeX = x - rect.left;\n        const offsetFromCenter = relativeX - centerX;\n        const clickedOffset = this.currentIndex + Math.round(offsetFromCenter / this.getItemSpacingPx());\n        this.setCurrentIndex(clickedOffset);\n    }\n    moveSelection(direction) {\n        this.setCurrentIndex(this.currentIndex + direction);\n    }\n    setCurrentIndex(nextIndex) {\n        const clampedIndex = Math.max(0, Math.min(this.options.length - 1, nextIndex));\n        if (clampedIndex === this.currentIndex) {\n            this.targetIndex = clampedIndex;\n            return;\n        }\n        this.targetIndex = clampedIndex;\n        this.currentIndex = clampedIndex;\n        if (this.onSelectionChangeCallback) {\n            this.onSelectionChangeCallback(this.options[this.currentIndex]);\n        }\n    }\n    startAnimation() {\n        const animate = () => {\n            this.update();\n            this.render();\n            this.animationFrameId = requestAnimationFrame(animate);\n        };\n        animate();\n    }\n    updateLayoutMetrics() {\n        this.isCompactLayout = window.innerWidth < 600;\n        const targetHeight = this.isCompactLayout ? '460px' : '600px';\n        if (this.container.style.height !== targetHeight) {\n            this.container.style.height = targetHeight;\n        }\n    }\n    getLayoutScale() {\n        return this.isCompactLayout ? 0.6 : 0.9;\n    }\n    getItemSpacingPx() {\n        return FactionCarouselView.ITEM_SPACING_PX * this.getLayoutScale();\n    }\n    update() {\n        this.updateLayoutMetrics();\n        const targetScrollOffset = -this.currentIndex * this.getItemSpacingPx();\n        const diff = targetScrollOffset - this.scrollOffset;\n        this.scrollOffset += diff * FactionCarouselView.SMOOTH_INTERPOLATION_FACTOR;\n        if (!this.isDragging && Math.abs(this.velocity) > 0.1) {\n            this.velocity *= FactionCarouselView.VELOCITY_DECAY_FACTOR;\n            this.scrollOffset += this.velocity;\n        }\n        else {\n            this.velocity = 0;\n        }\n    }\n    render() {\n        this.container.innerHTML = '';\n        const rect = this.container.getBoundingClientRect();\n        const centerX = rect.width / 2;\n        const centerY = rect.height / 2;\n        const layoutScale = this.getLayoutScale();\n        const itemSpacingPx = this.getItemSpacingPx();\n        const baseSizePx = FactionCarouselView.BASE_SIZE_PX * layoutScale;\n        const textScale = FactionCarouselView.TEXT_SCALE * layoutScale;\n        for (let i = 0; i < this.options.length; i++) {\n            const option = this.options[i];\n            const offsetFromCenter = i - this.currentIndex;\n            const distance = Math.abs(offsetFromCenter);\n            const x = centerX + this.scrollOffset + i * itemSpacingPx;\n            let scale = 1.0;\n            let opacity = 1.0;\n            if (distance === 0) {\n                scale = 1.0;\n                opacity = 1.0;\n            }\n            else if (distance === 1) {\n                scale = 0.72;\n                opacity = 0.85;\n            }\n            else if (distance === 2) {\n                scale = 0.5;\n                opacity = 0.55;\n            }\n            else {\n                scale = Math.max(0.3, 1.0 - distance * 0.25);\n                opacity = Math.max(0.3, 1.0 - distance * 0.25);\n            }\n            const sizePx = baseSizePx * scale;\n            const optionElement = document.createElement('div');\n            optionElement.style.position = 'absolute';\n            optionElement.style.left = `${x - sizePx / 2}px`;\n            optionElement.style.top = `${centerY - sizePx / 2}px`;\n            optionElement.style.width = `${sizePx}px`;\n            optionElement.style.height = `${sizePx}px`;\n            optionElement.style.backgroundColor = distance === 0 ? 'rgba(12, 14, 22, 0.98)' : 'rgba(12, 14, 22, 0.85)';\n            optionElement.style.border = distance === 0 ? `2px solid ${option.color}` : '2px solid rgba(255, 255, 255, 0.2)';\n            optionElement.style.borderRadius = '10px';\n            optionElement.style.opacity = opacity.toString();\n            optionElement.style.display = 'flex';\n            optionElement.style.flexDirection = 'column';\n            optionElement.style.justifyContent = 'center';\n            optionElement.style.alignItems = 'center';\n            optionElement.style.pointerEvents = 'none';\n            optionElement.style.color = '#FFFFFF';\n            optionElement.style.fontWeight = '300';\n            optionElement.style.textAlign = 'center';\n            optionElement.style.padding = `${24 * layoutScale}px`;\n            optionElement.style.boxSizing = 'border-box';\n            optionElement.style.zIndex = (100 - distance).toString();\n            optionElement.style.overflow = 'hidden';\n            optionElement.dataset.particleBox = 'true';\n            optionElement.dataset.particleColor = distance === 0 ? option.color : '#66B3FF';\n            const nameElement = document.createElement('div');\n            nameElement.textContent = option.name.toUpperCase();\n            nameElement.style.fontSize = `${Math.max(16, 20 * scale) * textScale}px`;\n            nameElement.style.marginBottom = distance === 0 ? '14px' : '0';\n            nameElement.style.color = distance === 0 ? '#FFFFFF' : '#E0F2FF';\n            nameElement.style.fontWeight = '300';\n            nameElement.dataset.particleText = 'true';\n            nameElement.dataset.particleColor = distance === 0 ? '#FFFFFF' : '#E0F2FF';\n            optionElement.appendChild(nameElement);\n            if (distance === 0) {\n                const descElement = document.createElement('div');\n                descElement.textContent = option.description;\n                descElement.style.fontSize = `${Math.max(10, 12 * scale) * textScale}px`;\n                descElement.style.color = '#D0D0D0';\n                descElement.style.lineHeight = '1.4';\n                descElement.style.fontWeight = '300';\n                descElement.dataset.particleText = 'true';\n                descElement.dataset.particleColor = '#D0D0D0';\n                optionElement.appendChild(descElement);\n            }\n            this.container.appendChild(optionElement);\n        }\n        if (this.onRenderCallback) {\n            this.onRenderCallback();\n        }\n    }\n    onSelectionChange(callback) {\n        this.onSelectionChangeCallback = callback;\n    }\n    onRender(callback) {\n        this.onRenderCallback = callback;\n    }\n    destroy() {\n        if (this.animationFrameId !== null) {\n            cancelAnimationFrame(this.animationFrameId);\n            this.animationFrameId = null;\n        }\n        if (this.resizeHandler) {\n            window.removeEventListener('resize', this.resizeHandler);\n        }\n        if (this.keydownHandler) {\n            window.removeEventListener('keydown', this.keydownHandler);\n        }\n    }\n}\nFactionCarouselView.ITEM_SPACING_PX = 200;\nFactionCarouselView.BASE_SIZE_PX = 320;\nFactionCarouselView.TEXT_SCALE = 2.4;\nFactionCarouselView.VELOCITY_MULTIPLIER = 0.1;\nFactionCarouselView.VELOCITY_FACTOR = 0.001;\nFactionCarouselView.SMOOTH_INTERPOLATION_FACTOR = 0.15;\nFactionCarouselView.VELOCITY_DECAY_FACTOR = 0.9;\nFactionCarouselView.SWIPE_THRESHOLD_PX = 50;\n/**\n * Carousel menu view - displays menu options in a horizontal carousel\n */\nclass CarouselMenuView {\n    constructor(container, options, initialIndex = 0, optionBackgroundColor = 'transparent') {\n        this.currentIndex = 0;\n        this.targetIndex = 0;\n        this.scrollOffset = 0;\n        this.isDragging = false;\n        this.dragStartX = 0;\n        this.dragStartOffset = 0;\n        this.lastDragDeltaX = 0;\n        this.velocity = 0;\n        this.onSelectCallback = null;\n        this.onRenderCallback = null;\n        this.onNavigateCallback = null;\n        this.animationFrameId = null;\n        this.hasDragged = false;\n        this.isCompactLayout = false;\n        this.resizeHandler = null;\n        this.container = container;\n        this.options = options;\n        this.optionBackgroundColor = optionBackgroundColor;\n        // Validate and clamp initialIndex to valid range\n        const validatedIndex = Math.max(0, Math.min(initialIndex, options.length - 1));\n        this.currentIndex = validatedIndex;\n        this.targetIndex = validatedIndex;\n        this.setupContainer();\n        this.setupEventHandlers();\n        this.startAnimation();\n    }\n    setupContainer() {\n        this.container.style.position = 'relative';\n        this.container.style.width = '100%';\n        this.updateLayoutMetrics();\n        this.container.style.overflow = 'hidden';\n        this.container.style.cursor = 'grab';\n        this.container.style.userSelect = 'none';\n        this.container.style.touchAction = 'pan-y'; // Allow vertical scrolling but handle horizontal ourselves\n    }\n    setupEventHandlers() {\n        this.resizeHandler = () => {\n            this.updateLayoutMetrics();\n        };\n        window.addEventListener('resize', this.resizeHandler);\n        // Mouse events\n        this.container.addEventListener('mousedown', (e) => {\n            this.startDrag(e.clientX);\n            e.preventDefault();\n        });\n        this.container.addEventListener('mousemove', (e) => {\n            if (this.isDragging) {\n                this.updateDrag(e.clientX);\n                e.preventDefault();\n            }\n        });\n        this.container.addEventListener('mouseup', (e) => {\n            this.endDrag(e.clientX);\n            e.preventDefault();\n        });\n        this.container.addEventListener('mouseleave', () => {\n            if (this.isDragging) {\n                this.endDrag(this.dragStartX);\n            }\n        });\n        // Touch events\n        this.container.addEventListener('touchstart', (e) => {\n            if (e.touches.length === 1) {\n                this.startDrag(e.touches[0].clientX);\n                e.preventDefault();\n            }\n        }, { passive: false });\n        this.container.addEventListener('touchmove', (e) => {\n            if (this.isDragging && e.touches.length === 1) {\n                this.updateDrag(e.touches[0].clientX);\n                e.preventDefault();\n            }\n        }, { passive: false });\n        this.container.addEventListener('touchend', (e) => {\n            if (this.isDragging) {\n                const touch = e.changedTouches[0];\n                this.endDrag(touch.clientX);\n                e.preventDefault();\n            }\n        }, { passive: false });\n    }\n    startDrag(x) {\n        this.isDragging = true;\n        this.dragStartX = x;\n        this.dragStartOffset = this.scrollOffset;\n        this.velocity = 0;\n        this.hasDragged = false;\n        this.lastDragDeltaX = 0;\n        this.container.style.cursor = 'grabbing';\n    }\n    updateDrag(x) {\n        if (!this.isDragging)\n            return;\n        const deltaX = x - this.dragStartX;\n        this.lastDragDeltaX = deltaX;\n        this.scrollOffset = this.dragStartOffset + deltaX;\n        this.velocity = deltaX * CarouselMenuView.VELOCITY_MULTIPLIER; // Track velocity for momentum\n        // Track if we've dragged significantly\n        if (Math.abs(deltaX) > _constants__WEBPACK_IMPORTED_MODULE_0__.CLICK_DRAG_THRESHOLD) {\n            this.hasDragged = true;\n        }\n    }\n    endDrag(x) {\n        if (!this.isDragging)\n            return;\n        this.isDragging = false;\n        this.container.style.cursor = 'grab';\n        // If not dragged significantly, treat as a click/tap\n        if (!this.hasDragged) {\n            this.handleClick(x);\n            return;\n        }\n        const itemWidth = this.getItemWidthPx();\n        const deltaX = this.lastDragDeltaX;\n        if (Math.abs(deltaX) >= CarouselMenuView.SWIPE_THRESHOLD_PX) {\n            const direction = deltaX < 0 ? 1 : -1;\n            const targetIndex = Math.max(0, Math.min(this.options.length - 1, this.currentIndex + direction));\n            this.setCurrentIndex(targetIndex);\n            return;\n        }\n        // Snap to nearest option based on current position and velocity\n        const targetIndexFloat = -this.scrollOffset / itemWidth;\n        let targetIndex = Math.round(targetIndexFloat + this.velocity * CarouselMenuView.VELOCITY_FACTOR);\n        // Clamp to valid range\n        targetIndex = Math.max(0, Math.min(this.options.length - 1, targetIndex));\n        this.setCurrentIndex(targetIndex);\n    }\n    handleClick(x) {\n        const rect = this.container.getBoundingClientRect();\n        const centerX = rect.width / 2;\n        const relativeX = x - rect.left;\n        const offsetFromCenter = relativeX - centerX;\n        // Determine which option was clicked based on position\n        const clickedOffset = this.currentIndex + Math.round(offsetFromCenter / this.getItemWidthPx());\n        const clickedIndex = Math.max(0, Math.min(this.options.length - 1, clickedOffset));\n        if (clickedIndex === this.currentIndex) {\n            // Clicked on center option - select it\n            if (this.onSelectCallback) {\n                this.onSelectCallback(this.options[this.currentIndex]);\n            }\n        }\n        else {\n            // Clicked on different option - slide to it\n            this.setCurrentIndex(clickedIndex);\n        }\n    }\n    setCurrentIndex(nextIndex) {\n        if (nextIndex === this.currentIndex) {\n            this.targetIndex = nextIndex;\n            return;\n        }\n        this.targetIndex = nextIndex;\n        this.currentIndex = nextIndex;\n        if (this.onNavigateCallback) {\n            this.onNavigateCallback(nextIndex);\n        }\n    }\n    startAnimation() {\n        const animate = () => {\n            this.update();\n            this.render();\n            this.animationFrameId = requestAnimationFrame(animate);\n        };\n        animate();\n    }\n    updateLayoutMetrics() {\n        const isCompactLayout = window.innerWidth < 600;\n        this.isCompactLayout = isCompactLayout;\n        const layoutScale = this.getLayoutScale();\n        const baseSize = CarouselMenuView.BASE_SIZE * layoutScale;\n        const instructionPadding = 120 * layoutScale;\n        const targetHeight = `${Math.round(baseSize + instructionPadding)}px`;\n        if (this.container.style.height !== targetHeight) {\n            this.container.style.height = targetHeight;\n        }\n    }\n    getLayoutScale() {\n        return this.isCompactLayout ? 0.5 : 1;\n    }\n    getItemWidthPx() {\n        return CarouselMenuView.ITEM_WIDTH * this.getLayoutScale();\n    }\n    update() {\n        this.updateLayoutMetrics();\n        // Smooth scrolling towards target\n        const targetScrollOffset = -this.currentIndex * this.getItemWidthPx();\n        const diff = targetScrollOffset - this.scrollOffset;\n        this.scrollOffset += diff * CarouselMenuView.SMOOTH_INTERPOLATION_FACTOR;\n        // Apply velocity decay when not dragging\n        if (!this.isDragging && Math.abs(this.velocity) > 0.1) {\n            this.velocity *= CarouselMenuView.VELOCITY_DECAY_FACTOR;\n            this.scrollOffset += this.velocity;\n        }\n        else {\n            this.velocity = 0;\n        }\n    }\n    render() {\n        // Clear container\n        this.container.innerHTML = '';\n        const rect = this.container.getBoundingClientRect();\n        const centerX = rect.width / 2;\n        const centerY = rect.height / 2;\n        const layoutScale = this.getLayoutScale();\n        const itemWidth = this.getItemWidthPx();\n        const baseSize = CarouselMenuView.BASE_SIZE * layoutScale;\n        const textScale = CarouselMenuView.TEXT_SCALE * layoutScale;\n        // Render each option\n        for (let i = 0; i < this.options.length; i++) {\n            const option = this.options[i];\n            const offsetFromCenter = i - this.currentIndex;\n            const distance = Math.abs(offsetFromCenter);\n            // Calculate position\n            const x = centerX + this.scrollOffset + i * itemWidth;\n            // Calculate size and opacity based on distance from center\n            let scale = 1.0;\n            let opacity = 1.0;\n            if (distance === 0) {\n                scale = 1.0;\n                opacity = 1.0;\n            }\n            else if (distance === 1) {\n                scale = 0.75;\n                opacity = 0.75;\n            }\n            else if (distance === 2) {\n                scale = 0.5;\n                opacity = 0.5;\n            }\n            else {\n                scale = Math.max(0.25, 1.0 - distance * 0.25);\n                opacity = Math.max(0.25, 1.0 - distance * 0.25);\n            }\n            const size = baseSize * scale;\n            // Create option element\n            const optionElement = document.createElement('div');\n            optionElement.style.position = 'absolute';\n            optionElement.style.left = `${x - size / 2}px`;\n            optionElement.style.top = `${centerY - size / 2}px`;\n            optionElement.style.width = `${size}px`;\n            optionElement.style.height = `${size}px`;\n            optionElement.style.backgroundColor = this.optionBackgroundColor;\n            optionElement.style.border = '2px solid transparent';\n            optionElement.style.borderRadius = '10px';\n            optionElement.style.opacity = opacity.toString();\n            optionElement.style.transition = 'background-color 0.2s';\n            optionElement.style.display = 'flex';\n            optionElement.style.flexDirection = 'column';\n            optionElement.style.justifyContent = 'center';\n            optionElement.style.alignItems = 'center';\n            optionElement.style.pointerEvents = 'none'; // Let container handle events\n            optionElement.style.color = '#000000';\n            optionElement.style.fontWeight = '300';\n            optionElement.style.textAlign = 'center';\n            optionElement.style.padding = '30px';\n            optionElement.style.boxSizing = 'border-box';\n            optionElement.dataset.particleBox = 'true';\n            optionElement.dataset.particleColor = distance === 0 ? '#FFD700' : '#00AAFF';\n            // Add option name\n            const nameElement = document.createElement('div');\n            nameElement.textContent = option.name;\n            nameElement.style.fontSize = `${Math.max(14, 18 * scale) * textScale}px`;\n            nameElement.style.marginBottom = '15px';\n            nameElement.style.color = distance === 0 ? '#FFF5C2' : '#E2F4FF';\n            nameElement.style.fontWeight = '300';\n            nameElement.dataset.particleText = 'true';\n            nameElement.dataset.particleColor = distance === 0 ? '#FFF5C2' : '#E2F4FF';\n            optionElement.appendChild(nameElement);\n            // Add option description (only for center item)\n            if (distance === 0) {\n                const descElement = document.createElement('div');\n                descElement.textContent = option.description;\n                descElement.style.fontSize = `${Math.max(10, 12 * scale) * textScale}px`;\n                descElement.style.color = '#D0D0D0';\n                descElement.style.overflow = 'hidden';\n                descElement.style.textOverflow = 'ellipsis';\n                descElement.style.fontWeight = '300';\n                descElement.dataset.particleText = 'true';\n                descElement.dataset.particleColor = '#D0D0D0';\n                optionElement.appendChild(descElement);\n            }\n            this.container.appendChild(optionElement);\n        }\n        // Instruction text removed per requirements\n        if (this.onRenderCallback) {\n            this.onRenderCallback();\n        }\n    }\n    onSelect(callback) {\n        this.onSelectCallback = callback;\n    }\n    onRender(callback) {\n        this.onRenderCallback = callback;\n    }\n    onNavigate(callback) {\n        this.onNavigateCallback = callback;\n    }\n    destroy() {\n        if (this.animationFrameId !== null) {\n            cancelAnimationFrame(this.animationFrameId);\n            this.animationFrameId = null;\n        }\n        if (this.resizeHandler) {\n            window.removeEventListener('resize', this.resizeHandler);\n        }\n    }\n}\n// Animation constants\nCarouselMenuView.ITEM_WIDTH = 260;\nCarouselMenuView.BASE_SIZE = 220;\nCarouselMenuView.TEXT_SCALE = 2;\nCarouselMenuView.VELOCITY_MULTIPLIER = 0.1;\nCarouselMenuView.VELOCITY_FACTOR = 0.001;\nCarouselMenuView.SMOOTH_INTERPOLATION_FACTOR = 0.15;\nCarouselMenuView.VELOCITY_DECAY_FACTOR = 0.9;\nCarouselMenuView.SWIPE_THRESHOLD_PX = 50;\n\n\n//# sourceURL=webpack://sol/./src/menu.ts?\n}");

/***/ },

/***/ "./src/network.ts"
/*!************************!*\
  !*** ./src/network.ts ***!
  \************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LANSignaling: () => (/* binding */ LANSignaling),\n/* harmony export */   MessageType: () => (/* binding */ MessageType),\n/* harmony export */   NetworkEvent: () => (/* binding */ NetworkEvent),\n/* harmony export */   NetworkManager: () => (/* binding */ NetworkManager),\n/* harmony export */   PeerConnection: () => (/* binding */ PeerConnection)\n/* harmony export */ });\n/**\n * Network Module for LAN Play\n * Implements WebRTC peer-to-peer networking for local multiplayer\n */\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n/**\n * Network message types\n */\nvar MessageType;\n(function (MessageType) {\n    MessageType[\"GAME_COMMAND\"] = \"game_command\";\n    MessageType[\"GAME_STATE\"] = \"game_state\";\n    MessageType[\"PLAYER_JOIN\"] = \"player_join\";\n    MessageType[\"PLAYER_LEAVE\"] = \"player_leave\";\n    MessageType[\"LOBBY_UPDATE\"] = \"lobby_update\";\n    MessageType[\"GAME_START\"] = \"game_start\";\n    MessageType[\"PING\"] = \"ping\";\n    MessageType[\"PONG\"] = \"pong\";\n})(MessageType || (MessageType = {}));\n/**\n * Network events\n */\nvar NetworkEvent;\n(function (NetworkEvent) {\n    NetworkEvent[\"CONNECTED\"] = \"connected\";\n    NetworkEvent[\"DISCONNECTED\"] = \"disconnected\";\n    NetworkEvent[\"MESSAGE_RECEIVED\"] = \"message_received\";\n    NetworkEvent[\"PLAYER_JOINED\"] = \"player_joined\";\n    NetworkEvent[\"PLAYER_LEFT\"] = \"player_left\";\n    NetworkEvent[\"ERROR\"] = \"error\";\n})(NetworkEvent || (NetworkEvent = {}));\n/**\n * WebRTC Peer Connection Manager\n */\nclass PeerConnection {\n    constructor(peerId) {\n        this.connection = null;\n        this.dataChannel = null;\n        this.onMessageCallback = null;\n        this.onConnectedCallback = null;\n        this.onDisconnectedCallback = null;\n        this.peerId = peerId;\n    }\n    /**\n     * Initialize RTCPeerConnection with ICE servers\n     */\n    createPeerConnection() {\n        // Using public STUN servers for NAT traversal\n        const configuration = {\n            iceServers: [\n                { urls: 'stun:stun.l.google.com:19302' },\n                { urls: 'stun:stun1.l.google.com:19302' }\n            ]\n        };\n        return new RTCPeerConnection(configuration);\n    }\n    /**\n     * Create offer (host side)\n     */\n    createOffer() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.connection = this.createPeerConnection();\n            this.setupConnectionHandlers();\n            // Create data channel for game communication\n            this.dataChannel = this.connection.createDataChannel('gameData', {\n                ordered: true,\n                maxRetransmits: 3\n            });\n            this.setupDataChannelHandlers(this.dataChannel);\n            const offer = yield this.connection.createOffer();\n            yield this.connection.setLocalDescription(offer);\n            // Wait for ICE gathering to complete\n            yield this.waitForIceGathering();\n            return this.connection.localDescription;\n        });\n    }\n    /**\n     * Create answer (client side)\n     */\n    createAnswer(offer) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.connection = this.createPeerConnection();\n            this.setupConnectionHandlers();\n            // Set up data channel when received\n            this.connection.ondatachannel = (event) => {\n                this.dataChannel = event.channel;\n                this.setupDataChannelHandlers(this.dataChannel);\n            };\n            yield this.connection.setRemoteDescription(offer);\n            const answer = yield this.connection.createAnswer();\n            yield this.connection.setLocalDescription(answer);\n            // Wait for ICE gathering to complete\n            yield this.waitForIceGathering();\n            return this.connection.localDescription;\n        });\n    }\n    /**\n     * Wait for ICE gathering to complete\n     */\n    waitForIceGathering() {\n        if (!this.connection) {\n            return Promise.reject(new Error('Connection not initialized'));\n        }\n        return new Promise((resolve) => {\n            if (this.connection.iceGatheringState === 'complete') {\n                resolve();\n                return;\n            }\n            const checkState = () => {\n                if (this.connection.iceGatheringState === 'complete') {\n                    this.connection.removeEventListener('icegatheringstatechange', checkState);\n                    resolve();\n                }\n            };\n            this.connection.addEventListener('icegatheringstatechange', checkState);\n        });\n    }\n    /**\n     * Complete connection with answer (host side)\n     */\n    setAnswer(answer) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.connection) {\n                throw new Error('Connection not initialized');\n            }\n            yield this.connection.setRemoteDescription(answer);\n        });\n    }\n    /**\n     * Add ICE candidate\n     */\n    addIceCandidate(candidate) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.connection) {\n                throw new Error('Connection not initialized');\n            }\n            yield this.connection.addIceCandidate(candidate);\n        });\n    }\n    /**\n     * Set up connection event handlers\n     */\n    setupConnectionHandlers() {\n        if (!this.connection)\n            return;\n        this.connection.onicecandidate = (event) => {\n            if (event.candidate) {\n                // ICE candidate should be exchanged via signaling\n                console.log('ICE candidate:', event.candidate);\n            }\n        };\n        this.connection.onconnectionstatechange = () => {\n            if (!this.connection)\n                return;\n            console.log('Connection state:', this.connection.connectionState);\n            if (this.connection.connectionState === 'connected') {\n                if (this.onConnectedCallback) {\n                    this.onConnectedCallback();\n                }\n            }\n            else if (this.connection.connectionState === 'disconnected' ||\n                this.connection.connectionState === 'failed' ||\n                this.connection.connectionState === 'closed') {\n                if (this.onDisconnectedCallback) {\n                    this.onDisconnectedCallback();\n                }\n            }\n        };\n    }\n    /**\n     * Set up data channel event handlers\n     */\n    setupDataChannelHandlers(channel) {\n        channel.onopen = () => {\n            console.log('Data channel opened with peer:', this.peerId);\n        };\n        channel.onclose = () => {\n            console.log('Data channel closed with peer:', this.peerId);\n        };\n        channel.onerror = (error) => {\n            console.error('Data channel error:', error);\n        };\n        channel.onmessage = (event) => {\n            try {\n                const message = JSON.parse(event.data);\n                if (this.onMessageCallback) {\n                    this.onMessageCallback(message);\n                }\n            }\n            catch (error) {\n                console.error('Failed to parse network message:', error);\n            }\n        };\n    }\n    /**\n     * Send message to peer\n     */\n    sendMessage(message) {\n        if (!this.dataChannel || this.dataChannel.readyState !== 'open') {\n            console.warn('Data channel not open, cannot send message');\n            return;\n        }\n        try {\n            this.dataChannel.send(JSON.stringify(message));\n        }\n        catch (error) {\n            console.error('Failed to send message:', error);\n        }\n    }\n    /**\n     * Set callback for received messages\n     */\n    onMessage(callback) {\n        this.onMessageCallback = callback;\n    }\n    /**\n     * Set callback for connection established\n     */\n    onConnected(callback) {\n        this.onConnectedCallback = callback;\n    }\n    /**\n     * Set callback for disconnection\n     */\n    onDisconnected(callback) {\n        this.onDisconnectedCallback = callback;\n    }\n    /**\n     * Close connection\n     */\n    close() {\n        if (this.dataChannel) {\n            this.dataChannel.close();\n            this.dataChannel = null;\n        }\n        if (this.connection) {\n            this.connection.close();\n            this.connection = null;\n        }\n    }\n    /**\n     * Check if connected\n     */\n    isConnected() {\n        return this.dataChannel !== null && this.dataChannel.readyState === 'open';\n    }\n    getPeerId() {\n        return this.peerId;\n    }\n}\n/**\n * Network Manager for handling multiple peer connections\n */\nclass NetworkManager {\n    constructor(playerId) {\n        this.peers = new Map();\n        this.eventListeners = new Map();\n        this.lobby = null;\n        this.isHost = false;\n        this.localPlayerId = playerId;\n    }\n    /**\n     * Create a new lobby (host)\n     */\n    createLobby(lobbyName, username, maxPlayers = 2) {\n        this.isHost = true;\n        this.lobby = {\n            id: this.generateLobbyId(),\n            name: lobbyName,\n            hostId: this.localPlayerId,\n            players: [{\n                    id: this.localPlayerId,\n                    username: username,\n                    isHost: true,\n                    isReady: true\n                }],\n            maxPlayers: maxPlayers,\n            gameStarted: false\n        };\n        return this.lobby;\n    }\n    /**\n     * Connect to a peer (initiates WebRTC connection)\n     */\n    connectToPeer(peerId, offer) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const peer = new PeerConnection(peerId);\n            this.setupPeerHandlers(peer);\n            const answer = yield peer.createAnswer(offer);\n            this.peers.set(peerId, peer);\n            return answer;\n        });\n    }\n    /**\n     * Host creates offer for new peer\n     */\n    createOfferForPeer(peerId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const peer = new PeerConnection(peerId);\n            this.setupPeerHandlers(peer);\n            const offer = yield peer.createOffer();\n            this.peers.set(peerId, peer);\n            return offer;\n        });\n    }\n    /**\n     * Complete connection with answer\n     */\n    completeConnection(peerId, answer) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const peer = this.peers.get(peerId);\n            if (!peer) {\n                throw new Error(`No peer connection found for ${peerId}`);\n            }\n            yield peer.setAnswer(answer);\n        });\n    }\n    /**\n     * Set up event handlers for a peer\n     */\n    setupPeerHandlers(peer) {\n        peer.onMessage((message) => {\n            this.handleMessage(peer.getPeerId(), message);\n        });\n        peer.onConnected(() => {\n            console.log('Peer connected:', peer.getPeerId());\n            this.emit(NetworkEvent.CONNECTED, { peerId: peer.getPeerId() });\n        });\n        peer.onDisconnected(() => {\n            console.log('Peer disconnected:', peer.getPeerId());\n            this.removePeer(peer.getPeerId());\n            this.emit(NetworkEvent.DISCONNECTED, { peerId: peer.getPeerId() });\n        });\n    }\n    /**\n     * Handle incoming message from peer\n     */\n    handleMessage(peerId, message) {\n        console.log('Received message from', peerId, ':', message);\n        switch (message.type) {\n            case MessageType.PLAYER_JOIN:\n                if (this.isHost && this.lobby) {\n                    // Host adds player to lobby\n                    const playerInfo = message.data;\n                    this.lobby.players.push(playerInfo);\n                    this.broadcastLobbyUpdate();\n                }\n                break;\n            case MessageType.LOBBY_UPDATE:\n                // Update local lobby state\n                this.lobby = message.data;\n                this.emit(NetworkEvent.PLAYER_JOINED, message.data);\n                break;\n            case MessageType.GAME_START:\n                // Game is starting\n                if (this.lobby) {\n                    this.lobby.gameStarted = true;\n                }\n                break;\n            case MessageType.GAME_COMMAND:\n                // Forward game command to listeners\n                this.emit(NetworkEvent.MESSAGE_RECEIVED, message);\n                break;\n            default:\n                this.emit(NetworkEvent.MESSAGE_RECEIVED, message);\n                break;\n        }\n    }\n    /**\n     * Send message to specific peer\n     */\n    sendToPeer(peerId, message) {\n        const peer = this.peers.get(peerId);\n        if (peer) {\n            peer.sendMessage(message);\n        }\n        else {\n            console.warn(`Cannot send to peer ${peerId}: not connected`);\n        }\n    }\n    /**\n     * Broadcast message to all connected peers\n     */\n    broadcast(message) {\n        this.peers.forEach((peer) => {\n            peer.sendMessage(message);\n        });\n    }\n    /**\n     * Broadcast lobby update to all peers\n     */\n    broadcastLobbyUpdate() {\n        if (!this.lobby)\n            return;\n        const message = {\n            type: MessageType.LOBBY_UPDATE,\n            senderId: this.localPlayerId,\n            timestamp: Date.now(),\n            data: this.lobby\n        };\n        this.broadcast(message);\n    }\n    /**\n     * Send game command to all peers\n     */\n    sendGameCommand(command) {\n        const message = {\n            type: MessageType.GAME_COMMAND,\n            senderId: this.localPlayerId,\n            timestamp: Date.now(),\n            data: command\n        };\n        this.broadcast(message);\n    }\n    /**\n     * Start the game (host only)\n     */\n    startGame() {\n        if (!this.isHost || !this.lobby) {\n            console.warn('Only host can start the game');\n            return;\n        }\n        this.lobby.gameStarted = true;\n        const message = {\n            type: MessageType.GAME_START,\n            senderId: this.localPlayerId,\n            timestamp: Date.now(),\n            data: this.lobby\n        };\n        this.broadcast(message);\n    }\n    /**\n     * Register event listener\n     */\n    on(event, callback) {\n        if (!this.eventListeners.has(event)) {\n            this.eventListeners.set(event, []);\n        }\n        this.eventListeners.get(event).push(callback);\n    }\n    /**\n     * Emit event to listeners\n     */\n    emit(event, data) {\n        const listeners = this.eventListeners.get(event);\n        if (listeners) {\n            listeners.forEach(callback => callback(data));\n        }\n    }\n    /**\n     * Remove peer connection\n     */\n    removePeer(peerId) {\n        const peer = this.peers.get(peerId);\n        if (peer) {\n            peer.close();\n            this.peers.delete(peerId);\n        }\n        // Remove from lobby if exists\n        if (this.lobby) {\n            this.lobby.players = this.lobby.players.filter(p => p.id !== peerId);\n            if (this.isHost) {\n                this.broadcastLobbyUpdate();\n            }\n        }\n    }\n    /**\n     * Disconnect from all peers and close lobby\n     */\n    disconnect() {\n        this.peers.forEach((peer) => {\n            peer.close();\n        });\n        this.peers.clear();\n        this.lobby = null;\n        this.isHost = false;\n        // Clear event listeners to prevent memory leaks\n        this.eventListeners.clear();\n    }\n    /**\n     * Generate unique lobby ID\n     */\n    generateLobbyId() {\n        return `lobby_${Date.now()}_${Math.random().toString(36).slice(2, 11)}`;\n    }\n    /**\n     * Get current lobby info\n     */\n    getLobby() {\n        return this.lobby;\n    }\n    /**\n     * Get local player ID\n     */\n    getLocalPlayerId() {\n        return this.localPlayerId;\n    }\n    /**\n     * Check if this client is the host\n     */\n    isLobbyHost() {\n        return this.isHost;\n    }\n    /**\n     * Get number of connected peers\n     */\n    getPeerCount() {\n        return this.peers.size;\n    }\n    /**\n     * Get all connected peer IDs\n     */\n    getPeerIds() {\n        return Array.from(this.peers.keys());\n    }\n}\n/**\n * Simple signaling mechanism for LAN play\n * Uses copy-paste signaling for initial connection setup\n */\nclass LANSignaling {\n    /**\n     * Generate connection code for host\n     */\n    static generateHostCode(offer, playerId, username) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = {\n                type: 'offer',\n                sdp: offer,\n                playerId: playerId,\n                username: username\n            };\n            return btoa(JSON.stringify(data));\n        });\n    }\n    /**\n     * Parse host connection code\n     */\n    static parseHostCode(code) {\n        try {\n            const data = JSON.parse(atob(code));\n            if (data.type !== 'offer') {\n                throw new Error('Invalid connection code: not an offer');\n            }\n            return {\n                offer: data.sdp,\n                playerId: data.playerId || 'host',\n                username: data.username || 'Host'\n            };\n        }\n        catch (error) {\n            throw new Error('Invalid connection code format');\n        }\n    }\n    /**\n     * Generate answer code for client\n     */\n    static generateAnswerCode(answer, playerId, username) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = {\n                type: 'answer',\n                sdp: answer,\n                playerId: playerId,\n                username: username\n            };\n            return btoa(JSON.stringify(data));\n        });\n    }\n    /**\n     * Parse client answer code\n     */\n    static parseAnswerCode(code) {\n        try {\n            const data = JSON.parse(atob(code));\n            if (data.type !== 'answer') {\n                throw new Error('Invalid connection code: not an answer');\n            }\n            return {\n                answer: data.sdp,\n                playerId: data.playerId || 'client',\n                username: data.username || 'Client'\n            };\n        }\n        catch (error) {\n            throw new Error('Invalid connection code format');\n        }\n    }\n}\n\n\n//# sourceURL=webpack://sol/./src/network.ts?\n}");

/***/ },

/***/ "./src/renderer.ts"
/*!*************************!*\
  !*** ./src/renderer.ts ***!
  \*************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GameRenderer: () => (/* binding */ GameRenderer)\n/* harmony export */ });\n/* harmony import */ var _game_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./game-core */ \"./src/game-core.ts\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants */ \"./src/constants.ts\");\n/* harmony import */ var _menu__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./menu */ \"./src/menu.ts\");\n/**\n * Game Renderer - Handles visualization on HTML5 Canvas\n */\n\n\n\nclass GameRenderer {\n    constructor(canvas) {\n        this.camera = new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(0, 0);\n        this.parallaxCamera = new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(0, 0);\n        this.zoom = 1.0;\n        this.selectionStart = null;\n        this.selectionEnd = null;\n        this.abilityArrowStart = null; // Arrow start for hero ability casting\n        this.abilityArrowEnd = null; // Arrow end for hero ability casting\n        this.selectedUnits = new Set();\n        this.pathPreviewForge = null;\n        this.pathPreviewPoints = [];\n        this.pathPreviewEnd = null;\n        this.selectedHeroNames = [];\n        this.tapEffects = [];\n        this.swipeEffects = [];\n        this.warpGateShockwaves = [];\n        this.productionButtonWaves = [];\n        this.viewingPlayer = null; // The player whose view we're rendering\n        this.showInfo = false; // Toggle for showing top-left info\n        this.showInGameMenu = false; // Toggle for in-game menu\n        this.isPaused = false; // Game pause state\n        this.playerColor = _constants__WEBPACK_IMPORTED_MODULE_1__.PLAYER_1_COLOR; // Player 1 color (customizable)\n        this.enemyColor = _constants__WEBPACK_IMPORTED_MODULE_1__.PLAYER_2_COLOR; // Player 2 color (customizable)\n        this.colorScheme = _menu__WEBPACK_IMPORTED_MODULE_2__.COLOR_SCHEMES['SpaceBlack']; // Color scheme for rendering\n        this.inGameMenuTab = 'main';\n        this.damageDisplayMode = 'damage'; // How to display damage numbers\n        this.healthDisplayMode = 'bar'; // How to display unit health\n        this.graphicsQuality = 'high'; // Graphics quality setting\n        this.HERO_SPRITE_SCALE = 6;\n        this.FORGE_SPRITE_SCALE = 2.2;\n        this.spriteImageCache = new Map();\n        this.tintedSpriteCache = new Map();\n        this.outlinedSpriteCache = new Map();\n        this.forgeFlameStates = new Map();\n        this.graphicsOptionByKey = new Map();\n        this.graphicsVariantByKey = new Map();\n        this.graphicsMenuScrollOffset = 0;\n        this.graphicsOptions = [\n            {\n                key: 'centralSun',\n                label: 'Central Sun',\n                svgPath: 'ASSETS/sprites/environment/centralSun.svg',\n                pngPath: 'ASSETS/sprites/environment/centralSun.png'\n            },\n            {\n                key: 'stellarForge',\n                label: 'Stellar Forge Base',\n                svgPath: 'ASSETS/sprites/RADIANT/stellarForgeBases/radiantBaseType1.svg',\n                pngPath: 'ASSETS/sprites/RADIANT/stellarForgeBases/radiantBaseType1.png'\n            },\n            {\n                key: 'forgeFlameHot',\n                label: 'Forge Flame (Hot)',\n                pngPath: 'ASSETS/sprites/RADIANT/stellarForgeBases/radiantForgeFlame.png'\n            },\n            {\n                key: 'forgeFlameCold',\n                label: 'Forge Flame (Cold)',\n                pngPath: 'ASSETS/sprites/RADIANT/stellarForgeBases/radiantForgeFlameCold.png'\n            },\n            {\n                key: 'solarMirror',\n                label: 'Solar Mirror',\n                svgPath: 'ASSETS/sprites/RADIANT/solarMirrors/radiantSolarMirror.svg',\n                pngPath: 'ASSETS/sprites/RADIANT/solarMirrors/radiantSolarMirror.png'\n            },\n            {\n                key: 'starling',\n                label: 'Starling',\n                svgPath: 'ASSETS/sprites/RADIANT/starlings/starlingLevel (1).svg',\n                pngPath: 'ASSETS/sprites/RADIANT/starlings/starlingLevel (1).png'\n            },\n            {\n                key: 'heroMarine',\n                label: 'Hero: Marine',\n                svgPath: 'ASSETS/sprites/RADIANT/heroUnits/Marine.svg',\n                pngPath: 'ASSETS/sprites/RADIANT/heroUnits/Marine.png'\n            },\n            {\n                key: 'heroGrave',\n                label: 'Hero: Grave',\n                svgPath: 'ASSETS/sprites/RADIANT/heroUnits/Grave.svg',\n                pngPath: 'ASSETS/sprites/RADIANT/heroUnits/Grave.png'\n            },\n            {\n                key: 'heroRay',\n                label: 'Hero: Ray',\n                svgPath: 'ASSETS/sprites/RADIANT/heroUnits/Ray.svg',\n                pngPath: 'ASSETS/sprites/RADIANT/heroUnits/Ray.png'\n            },\n            {\n                key: 'heroInfluenceBall',\n                label: 'Hero: Influence Ball',\n                svgPath: 'ASSETS/sprites/RADIANT/heroUnits/Uniter.svg',\n                pngPath: 'ASSETS/sprites/RADIANT/heroUnits/Uniter.png'\n            },\n            {\n                key: 'heroTurretDeployer',\n                label: 'Hero: Turret Deployer',\n                svgPath: 'ASSETS/sprites/RADIANT/heroUnits/Engineer.svg',\n                pngPath: 'ASSETS/sprites/RADIANT/heroUnits/Engineer.png'\n            },\n            {\n                key: 'heroDriller',\n                label: 'Hero: Driller',\n                svgPath: 'ASSETS/sprites/RADIANT/heroUnits/Drill.svg',\n                pngPath: 'ASSETS/sprites/RADIANT/heroUnits/Drill.png'\n            },\n            {\n                key: 'heroDagger',\n                label: 'Hero: Dagger',\n                svgPath: 'ASSETS/sprites/RADIANT/heroUnits/Dagger.svg',\n                pngPath: 'ASSETS/sprites/RADIANT/heroUnits/Dagger.png'\n            },\n            {\n                key: 'heroBeam',\n                label: 'Hero: Beam',\n                svgPath: 'ASSETS/sprites/RADIANT/heroUnits/Beam.svg',\n                pngPath: 'ASSETS/sprites/RADIANT/heroUnits/Beam.png'\n            },\n            {\n                key: 'heroPreist',\n                label: 'Hero: Preist',\n                svgPath: 'ASSETS/sprites/RADIANT/heroUnits/Preist.svg',\n                pngPath: 'ASSETS/sprites/RADIANT/heroUnits/Preist.png'\n            },\n            {\n                key: 'heroTank',\n                label: 'Hero: Tank',\n                svgPath: 'ASSETS/sprites/RADIANT/heroUnits/Tank.svg',\n                pngPath: 'ASSETS/sprites/RADIANT/heroUnits/Tank.png'\n            }\n        ];\n        // Movement order indicator constants\n        this.MOVE_ORDER_DOT_RADIUS = 12;\n        this.FORGE_MAX_HEALTH = 1000;\n        this.MIRROR_MAX_HEALTH = _constants__WEBPACK_IMPORTED_MODULE_1__.MIRROR_MAX_HEALTH;\n        // Parallax star layers for depth\n        this.starLayers = [];\n        this.canvas = canvas;\n        const context = canvas.getContext('2d');\n        if (!context) {\n            throw new Error('Could not get 2D context from canvas');\n        }\n        this.ctx = context;\n        this.resizeCanvas();\n        window.addEventListener('resize', () => this.resizeCanvas());\n        // Initialize star layers with random positions\n        this.initializeStarLayers();\n        const defaultPngKeys = ['stellarForge', 'solarMirror'];\n        for (const option of this.graphicsOptions) {\n            this.graphicsOptionByKey.set(option.key, option);\n            const defaultVariant = option.svgPath ? 'svg' : option.pngPath ? 'png' : 'stub';\n            const shouldPreferPng = defaultPngKeys.includes(option.key) && option.pngPath;\n            this.graphicsVariantByKey.set(option.key, shouldPreferPng ? 'png' : defaultVariant);\n        }\n    }\n    resizeCanvas() {\n        // Get device pixel ratio for high-DPI displays (retina, mobile, etc.)\n        const dpr = window.devicePixelRatio || 1;\n        // Set canvas physical size to match display size * device pixel ratio\n        this.canvas.width = window.innerWidth * dpr;\n        this.canvas.height = window.innerHeight * dpr;\n        // Set canvas CSS size to match window size\n        this.canvas.style.width = `${window.innerWidth}px`;\n        this.canvas.style.height = `${window.innerHeight}px`;\n        // Reset transform and scale the context to match device pixel ratio\n        this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n        this.ctx.scale(dpr, dpr);\n    }\n    /**\n     * Initialize star layers with random positions for parallax effect\n     */\n    initializeStarLayers() {\n        // Use a seeded random for consistent star positions\n        let seed = 42;\n        const seededRandom = () => {\n            seed = (seed * 9301 + 49297) % 233280;\n            return seed / 233280;\n        };\n        for (const layerConfig of _constants__WEBPACK_IMPORTED_MODULE_1__.STAR_LAYER_CONFIGS) {\n            const stars = [];\n            for (let i = 0; i < layerConfig.count; i++) {\n                stars.push({\n                    x: seededRandom() * _constants__WEBPACK_IMPORTED_MODULE_1__.STAR_WRAP_SIZE - _constants__WEBPACK_IMPORTED_MODULE_1__.STAR_WRAP_SIZE / 2,\n                    y: seededRandom() * _constants__WEBPACK_IMPORTED_MODULE_1__.STAR_WRAP_SIZE - _constants__WEBPACK_IMPORTED_MODULE_1__.STAR_WRAP_SIZE / 2,\n                    size: layerConfig.sizeRange[0] + seededRandom() * (layerConfig.sizeRange[1] - layerConfig.sizeRange[0]),\n                    brightness: 0.3 + seededRandom() * 0.7 // Vary brightness\n                });\n            }\n            this.starLayers.push({\n                stars,\n                parallaxFactor: layerConfig.parallaxFactor\n            });\n        }\n    }\n    /**\n     * Convert world coordinates to screen coordinates\n     */\n    worldToScreen(worldPos) {\n        const dpr = window.devicePixelRatio || 1;\n        const centerX = (this.canvas.width / dpr) / 2;\n        const centerY = (this.canvas.height / dpr) / 2;\n        return new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(centerX + (worldPos.x - this.camera.x) * this.zoom, centerY + (worldPos.y - this.camera.y) * this.zoom);\n    }\n    /**\n     * Check if a world position is within render bounds (map boundaries)\n     * @param worldPos Position in world space\n     * @param mapSize Size of the map\n     * @param margin Additional margin beyond map size (default 0)\n     * @returns true if position should be rendered\n     */\n    isWithinRenderBounds(worldPos, mapSize, margin = 0) {\n        const halfSize = mapSize / 2;\n        return worldPos.x >= -halfSize - margin &&\n            worldPos.x <= halfSize + margin &&\n            worldPos.y >= -halfSize - margin &&\n            worldPos.y <= halfSize + margin;\n    }\n    /**\n     * Convert screen coordinates to world coordinates\n     */\n    screenToWorld(screenX, screenY) {\n        const dpr = window.devicePixelRatio || 1;\n        const centerX = (this.canvas.width / dpr) / 2;\n        const centerY = (this.canvas.height / dpr) / 2;\n        return new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(this.camera.x + (screenX - centerX) / this.zoom, this.camera.y + (screenY - centerY) / this.zoom);\n    }\n    /**\n     * Get faction color\n     */\n    getFactionColor(faction) {\n        switch (faction) {\n            case _game_core__WEBPACK_IMPORTED_MODULE_0__.Faction.RADIANT:\n                return '#FFD700'; // Gold\n            case _game_core__WEBPACK_IMPORTED_MODULE_0__.Faction.AURUM:\n                return '#DAA520'; // Goldenrod\n            case _game_core__WEBPACK_IMPORTED_MODULE_0__.Faction.SOLARI:\n                return '#FF8C00'; // Dark orange\n            default:\n                return '#FFFFFF';\n        }\n    }\n    getSpriteImage(path) {\n        const resolvedPath = this.resolveAssetPath(path);\n        const cached = this.spriteImageCache.get(resolvedPath);\n        if (cached) {\n            return cached;\n        }\n        const image = new Image();\n        image.src = resolvedPath;\n        this.spriteImageCache.set(resolvedPath, image);\n        return image;\n    }\n    getTintedSprite(path, color) {\n        const resolvedPath = this.resolveAssetPath(path);\n        const cacheKey = `${resolvedPath}|${color}`;\n        const cached = this.tintedSpriteCache.get(cacheKey);\n        if (cached) {\n            return cached;\n        }\n        const image = this.getSpriteImage(resolvedPath);\n        if (!image.complete || image.naturalWidth === 0 || image.naturalHeight === 0) {\n            return null;\n        }\n        const canvas = document.createElement('canvas');\n        canvas.width = image.naturalWidth;\n        canvas.height = image.naturalHeight;\n        const ctx = canvas.getContext('2d');\n        if (!ctx) {\n            return null;\n        }\n        ctx.drawImage(image, 0, 0);\n        ctx.globalCompositeOperation = 'multiply';\n        ctx.fillStyle = color;\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        ctx.globalCompositeOperation = 'destination-in';\n        ctx.drawImage(image, 0, 0);\n        ctx.globalCompositeOperation = 'source-over';\n        this.tintedSpriteCache.set(cacheKey, canvas);\n        return canvas;\n    }\n    /**\n     * Get a sprite with a colored tint and white outline\n     */\n    getOutlinedTintedSprite(path, color) {\n        const resolvedPath = this.resolveAssetPath(path);\n        const cacheKey = `${resolvedPath}|${color}|outlined`;\n        const cached = this.outlinedSpriteCache.get(cacheKey);\n        if (cached) {\n            return cached;\n        }\n        const image = this.getSpriteImage(resolvedPath);\n        if (!image.complete || image.naturalWidth === 0 || image.naturalHeight === 0) {\n            return null;\n        }\n        // Create a larger canvas to accommodate the outline\n        const outlineWidth = 2;\n        const canvas = document.createElement('canvas');\n        canvas.width = image.naturalWidth + outlineWidth * 2;\n        canvas.height = image.naturalHeight + outlineWidth * 2;\n        const ctx = canvas.getContext('2d');\n        if (!ctx) {\n            return null;\n        }\n        // Draw white outline by drawing the image multiple times offset in all directions\n        ctx.globalCompositeOperation = 'source-over';\n        ctx.fillStyle = 'white';\n        // Draw outline in 8 directions\n        for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 4) {\n            const offsetX = Math.cos(angle) * outlineWidth + outlineWidth;\n            const offsetY = Math.sin(angle) * outlineWidth + outlineWidth;\n            ctx.drawImage(image, offsetX, offsetY);\n        }\n        // Fill the outline with white\n        ctx.globalCompositeOperation = 'source-in';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        // Draw the colored sprite on top\n        ctx.globalCompositeOperation = 'source-over';\n        ctx.drawImage(image, outlineWidth, outlineWidth);\n        ctx.globalCompositeOperation = 'multiply';\n        ctx.fillStyle = color;\n        ctx.fillRect(outlineWidth, outlineWidth, image.naturalWidth, image.naturalHeight);\n        ctx.globalCompositeOperation = 'destination-in';\n        ctx.drawImage(image, outlineWidth, outlineWidth);\n        ctx.globalCompositeOperation = 'source-over';\n        this.outlinedSpriteCache.set(cacheKey, canvas);\n        return canvas;\n    }\n    resolveAssetPath(path) {\n        if (!path.startsWith('ASSETS/')) {\n            return path;\n        }\n        const isDistBuild = window.location.pathname.includes('/dist/');\n        return isDistBuild ? `../${path}` : path;\n    }\n    getGraphicVariant(key) {\n        var _a;\n        return (_a = this.graphicsVariantByKey.get(key)) !== null && _a !== void 0 ? _a : 'stub';\n    }\n    setGraphicsVariant(key, variant) {\n        this.graphicsVariantByKey.set(key, variant);\n    }\n    setInGameMenuTab(tab) {\n        this.inGameMenuTab = tab;\n    }\n    getGraphicAssetPath(key) {\n        var _a, _b;\n        const option = this.graphicsOptionByKey.get(key);\n        if (!option) {\n            return null;\n        }\n        const variant = this.getGraphicVariant(key);\n        if (variant === 'svg') {\n            return (_a = option.svgPath) !== null && _a !== void 0 ? _a : null;\n        }\n        if (variant === 'png') {\n            return (_b = option.pngPath) !== null && _b !== void 0 ? _b : null;\n        }\n        return null;\n    }\n    getForgeSpritePath(forge) {\n        if (forge.owner.faction === _game_core__WEBPACK_IMPORTED_MODULE_0__.Faction.RADIANT) {\n            return this.getGraphicAssetPath('stellarForge');\n        }\n        return null;\n    }\n    getSolarMirrorSpritePath(mirror) {\n        if (mirror.owner.faction === _game_core__WEBPACK_IMPORTED_MODULE_0__.Faction.RADIANT) {\n            return this.getGraphicAssetPath('solarMirror');\n        }\n        return null;\n    }\n    getStarlingSpritePath(starling) {\n        if (starling.owner.faction === _game_core__WEBPACK_IMPORTED_MODULE_0__.Faction.RADIANT) {\n            // Use level 1 starling sprite\n            return this.getGraphicAssetPath('starling');\n        }\n        return null;\n    }\n    getStarlingFacingRotationRad(starling) {\n        // Use the unit's smooth rotation if it's moving\n        if (starling.rallyPoint) {\n            const distanceToRally = starling.position.distanceTo(starling.rallyPoint);\n            if (distanceToRally > _constants__WEBPACK_IMPORTED_MODULE_1__.UNIT_ARRIVAL_THRESHOLD) {\n                // Use the smoothly interpolated rotation from the unit's movement logic\n                return starling.rotation;\n            }\n        }\n        // If not moving but has a target, face the target\n        if (starling.target && 'position' in starling.target) {\n            if (!('health' in starling.target) || starling.target.health > 0) {\n                const targetPosition = starling.target.position;\n                const dx = targetPosition.x - starling.position.x;\n                const dy = targetPosition.y - starling.position.y;\n                if (dx !== 0 || dy !== 0) {\n                    // Add /2 so the TOP of the sprite is treated as the FRONT\n                    return Math.atan2(dy, dx) + Math.PI / 2;\n                }\n            }\n        }\n        return starling.rotation;\n    }\n    getForgeFlameState(forge, gameTime) {\n        let state = this.forgeFlameStates.get(forge);\n        if (!state) {\n            state = {\n                warmth: forge.isReceivingLight ? 1 : 0,\n                rotationRad: forge.rotation,\n                lastGameTime: gameTime\n            };\n            this.forgeFlameStates.set(forge, state);\n            return state;\n        }\n        const deltaTime = Math.max(0, gameTime - state.lastGameTime);\n        state.lastGameTime = gameTime;\n        const targetWarmth = forge.isReceivingLight ? 1 : 0;\n        if (targetWarmth > state.warmth) {\n            state.warmth = Math.min(1, state.warmth + _constants__WEBPACK_IMPORTED_MODULE_1__.FORGE_FLAME_WARMTH_FADE_PER_SEC * deltaTime);\n        }\n        else if (targetWarmth < state.warmth) {\n            state.warmth = Math.max(0, state.warmth - _constants__WEBPACK_IMPORTED_MODULE_1__.FORGE_FLAME_WARMTH_FADE_PER_SEC * deltaTime);\n        }\n        if (forge.isReceivingLight) {\n            const crunch = forge.getCurrentCrunch();\n            const speedMultiplier = crunch && crunch.isActive() ? 2 : 1;\n            state.rotationRad += _constants__WEBPACK_IMPORTED_MODULE_1__.FORGE_FLAME_ROTATION_SPEED_RAD_PER_SEC * speedMultiplier * deltaTime;\n            if (state.rotationRad >= Math.PI * 2) {\n                state.rotationRad -= Math.PI * 2;\n            }\n        }\n        return state;\n    }\n    getHeroSpritePath(unit) {\n        if (unit.owner.faction !== _game_core__WEBPACK_IMPORTED_MODULE_0__.Faction.RADIANT) {\n            return null;\n        }\n        if (unit instanceof _game_core__WEBPACK_IMPORTED_MODULE_0__.Marine) {\n            return this.getGraphicAssetPath('heroMarine');\n        }\n        if (unit instanceof _game_core__WEBPACK_IMPORTED_MODULE_0__.Grave) {\n            return this.getGraphicAssetPath('heroGrave');\n        }\n        if (unit instanceof _game_core__WEBPACK_IMPORTED_MODULE_0__.Dagger) {\n            return this.getGraphicAssetPath('heroDagger');\n        }\n        if (unit instanceof _game_core__WEBPACK_IMPORTED_MODULE_0__.Beam) {\n            return this.getGraphicAssetPath('heroBeam');\n        }\n        if (unit instanceof _game_core__WEBPACK_IMPORTED_MODULE_0__.Mortar) {\n            return this.getGraphicAssetPath('heroMortar');\n        }\n        if (unit instanceof _game_core__WEBPACK_IMPORTED_MODULE_0__.Ray) {\n            return this.getGraphicAssetPath('heroRay');\n        }\n        if (unit instanceof _game_core__WEBPACK_IMPORTED_MODULE_0__.InfluenceBall) {\n            return this.getGraphicAssetPath('heroInfluenceBall');\n        }\n        if (unit instanceof _game_core__WEBPACK_IMPORTED_MODULE_0__.TurretDeployer) {\n            return this.getGraphicAssetPath('heroTurretDeployer');\n        }\n        if (unit instanceof _game_core__WEBPACK_IMPORTED_MODULE_0__.Driller) {\n            return this.getGraphicAssetPath('heroDriller');\n        }\n        if (unit instanceof _game_core__WEBPACK_IMPORTED_MODULE_0__.Preist) {\n            return this.getGraphicAssetPath('heroPreist');\n        }\n        if (unit instanceof _game_core__WEBPACK_IMPORTED_MODULE_0__.Tank) {\n            return this.getGraphicAssetPath('heroTank');\n        }\n        return null;\n    }\n    /**\n     * Darken a color by a given factor (0-1, where 0 is black and 1 is original color)\n     */\n    darkenColor(color, factor) {\n        // Clamp factor to valid range [0, 1]\n        const clampedFactor = Math.max(0, Math.min(1, factor));\n        // Parse hex color (handle both #RGB and #RRGGBB formats)\n        let hex = color.replace('#', '');\n        if (hex.length === 3) {\n            // Convert #RGB to #RRGGBB\n            hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];\n        }\n        const r = parseInt(hex.substring(0, 2), 16) || 0;\n        const g = parseInt(hex.substring(2, 4), 16) || 0;\n        const b = parseInt(hex.substring(4, 6), 16) || 0;\n        // Apply darkening factor and clamp to valid RGB range\n        const newR = Math.floor(Math.min(255, r * clampedFactor));\n        const newG = Math.floor(Math.min(255, g * clampedFactor));\n        const newB = Math.floor(Math.min(255, b * clampedFactor));\n        // Convert back to hex\n        return '#' +\n            newR.toString(16).padStart(2, '0') +\n            newG.toString(16).padStart(2, '0') +\n            newB.toString(16).padStart(2, '0');\n    }\n    /**\n     * Brighten and pale a color (make it lighter and more desaturated)\n     * Used for solar mirrors to make them slightly brighter and paler than player color\n     */\n    brightenAndPaleColor(color) {\n        // Parse hex color\n        let hex = color.replace('#', '');\n        if (hex.length === 3) {\n            hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];\n        }\n        const r = parseInt(hex.substring(0, 2), 16) || 0;\n        const g = parseInt(hex.substring(2, 4), 16) || 0;\n        const b = parseInt(hex.substring(4, 6), 16) || 0;\n        // Brighten: move towards white by 20%\n        const brightenFactor = 0.2;\n        const brightenedR = r + (255 - r) * brightenFactor;\n        const brightenedG = g + (255 - g) * brightenFactor;\n        const brightenedB = b + (255 - b) * brightenFactor;\n        // Pale (desaturate): move towards average (gray) by 15%\n        const avg = (brightenedR + brightenedG + brightenedB) / 3;\n        const paleFactor = 0.15;\n        const newR = Math.floor(brightenedR + (avg - brightenedR) * paleFactor);\n        const newG = Math.floor(brightenedG + (avg - brightenedG) * paleFactor);\n        const newB = Math.floor(brightenedB + (avg - brightenedB) * paleFactor);\n        return '#' +\n            newR.toString(16).padStart(2, '0') +\n            newG.toString(16).padStart(2, '0') +\n            newB.toString(16).padStart(2, '0');\n    }\n    /**\n     * Draw a selection indicator (green dashed circle) for selected buildings\n     */\n    drawBuildingSelectionIndicator(screenPos, radius) {\n        this.ctx.strokeStyle = '#00FF00'; // Green highlight for selection\n        this.ctx.lineWidth = 3;\n        this.ctx.setLineDash([5, 5]);\n        this.ctx.beginPath();\n        this.ctx.arc(screenPos.x, screenPos.y, radius + 5, 0, Math.PI * 2);\n        this.ctx.stroke();\n        this.ctx.setLineDash([]); // Reset dash pattern\n    }\n    /**\n     * Draw a sun\n     */\n    drawSun(sun) {\n        const screenPos = this.worldToScreen(sun.position);\n        const screenRadius = sun.radius * this.zoom;\n        const sunSpritePath = this.getGraphicAssetPath('centralSun');\n        const sunSprite = sunSpritePath ? this.getSpriteImage(sunSpritePath) : null;\n        // Draw sun glow (outer glow)\n        const gradient = this.ctx.createRadialGradient(screenPos.x, screenPos.y, 0, screenPos.x, screenPos.y, screenRadius);\n        gradient.addColorStop(0, this.colorScheme.sunGlow.outerGlow1);\n        gradient.addColorStop(0.5, this.colorScheme.sunGlow.outerGlow2);\n        gradient.addColorStop(0.8, this.colorScheme.sunGlow.outerGlow3);\n        gradient.addColorStop(1, this.colorScheme.sunGlow.outerGlow4);\n        this.ctx.fillStyle = gradient;\n        this.ctx.beginPath();\n        this.ctx.arc(screenPos.x, screenPos.y, screenRadius, 0, Math.PI * 2);\n        this.ctx.fill();\n        if (sunSprite && sunSprite.complete && sunSprite.naturalWidth > 0) {\n            const diameterPx = screenRadius * 2;\n            this.ctx.drawImage(sunSprite, screenPos.x - screenRadius, screenPos.y - screenRadius, diameterPx, diameterPx);\n            return;\n        }\n        // Stub fallback when no sprite is available.\n        this.ctx.strokeStyle = this.colorScheme.sunGlow.outerGlow1;\n        this.ctx.lineWidth = 3;\n        this.ctx.beginPath();\n        this.ctx.arc(screenPos.x, screenPos.y, screenRadius * 0.8, 0, Math.PI * 2);\n        this.ctx.stroke();\n    }\n    drawForgeFlames(forge, screenPos, forgeSpriteSize, game, shouldDim) {\n        const flameState = this.getForgeFlameState(forge, game.gameTime);\n        const hotSpritePath = this.getGraphicAssetPath('forgeFlameHot');\n        const coldSpritePath = this.getGraphicAssetPath('forgeFlameCold');\n        if (!hotSpritePath || !coldSpritePath) {\n            return;\n        }\n        const hotSprite = this.getSpriteImage(hotSpritePath);\n        const coldSprite = this.getSpriteImage(coldSpritePath);\n        if (!hotSprite.complete || hotSprite.naturalWidth === 0 || !coldSprite.complete || coldSprite.naturalWidth === 0) {\n            return;\n        }\n        const flameSize = forgeSpriteSize * _constants__WEBPACK_IMPORTED_MODULE_1__.FORGE_FLAME_SIZE_MULTIPLIER;\n        const shadeMultiplier = shouldDim ? (1 - _constants__WEBPACK_IMPORTED_MODULE_1__.SHADE_OPACITY) : 1;\n        const baseAlpha = _constants__WEBPACK_IMPORTED_MODULE_1__.FORGE_FLAME_ALPHA * shadeMultiplier;\n        const hotAlpha = baseAlpha * flameState.warmth;\n        const coldAlpha = baseAlpha * (1 - flameState.warmth);\n        // Both flames overlap at the same position instead of being side by side\n        const flameOffsets = [0, 0];\n        for (let i = 0; i < flameOffsets.length; i++) {\n            const offsetX = flameOffsets[i];\n            const rotationRad = i === 0 ? flameState.rotationRad : -flameState.rotationRad;\n            this.ctx.save();\n            this.ctx.translate(screenPos.x + offsetX, screenPos.y);\n            this.ctx.rotate(rotationRad);\n            if (coldAlpha > 0) {\n                this.ctx.globalAlpha = coldAlpha;\n                this.ctx.drawImage(coldSprite, -flameSize / 2, -flameSize / 2, flameSize, flameSize);\n            }\n            if (hotAlpha > 0) {\n                this.ctx.globalAlpha = hotAlpha;\n                this.ctx.drawImage(hotSprite, -flameSize / 2, -flameSize / 2, flameSize, flameSize);\n            }\n            this.ctx.restore();\n        }\n        this.ctx.globalAlpha = 1.0;\n    }\n    /**\n     * Draw a subtle lens flare effect when a sun is visible on screen\n     */\n    drawLensFlare(sun) {\n        const screenPos = this.worldToScreen(sun.position);\n        const screenRadius = sun.radius * this.zoom;\n        // Check if sun is within or near the viewport\n        const dpr = window.devicePixelRatio || 1;\n        const canvasWidth = this.canvas.width / dpr;\n        const canvasHeight = this.canvas.height / dpr;\n        const centerX = canvasWidth / 2;\n        const centerY = canvasHeight / 2;\n        // Calculate direction vector from screen center to sun\n        const dx = screenPos.x - centerX;\n        const dy = screenPos.y - centerY;\n        const distanceFromCenter = Math.sqrt(dx * dx + dy * dy);\n        // Only draw lens flare if sun is reasonably visible\n        const maxDistance = Math.sqrt(canvasWidth * canvasWidth + canvasHeight * canvasHeight) / 2;\n        if (distanceFromCenter > maxDistance + screenRadius) {\n            return; // Sun is too far off screen\n        }\n        // Draw multiple subtle flare spots at different positions along the sun-center axis\n        // offset: position multiplier along the axis (-1 = opposite side, 0 = center, 1 = sun)\n        // size: flare radius as a fraction of sun radius\n        // Extract base color and alpha from colorScheme.lensFlareHalo\n        const haloColorMatch = this.colorScheme.lensFlareHalo.match(/rgba\\((\\d+),\\s*(\\d+),\\s*(\\d+),\\s*([\\d.]+)\\)/);\n        const haloBaseColor = haloColorMatch\n            ? `rgba(${haloColorMatch[1]}, ${haloColorMatch[2]}, ${haloColorMatch[3]}, `\n            : 'rgba(255, 240, 200, ';\n        const flarePositions = [\n            { offset: -0.3, size: 0.4, alpha: 0.15 },\n            { offset: -0.5, size: 0.25, alpha: 0.12 },\n            { offset: 0.4, size: 0.3, alpha: 0.1 },\n            { offset: 0.7, size: 0.2, alpha: 0.08 }\n        ];\n        for (const flare of flarePositions) {\n            // Calculate position along the sun-center line\n            const flareX = centerX + dx * flare.offset;\n            const flareY = centerY + dy * flare.offset;\n            const flareRadius = screenRadius * flare.size;\n            // Draw flare spot with radial gradient\n            const flareGradient = this.ctx.createRadialGradient(flareX, flareY, 0, flareX, flareY, flareRadius);\n            flareGradient.addColorStop(0, `${haloBaseColor}${flare.alpha})`);\n            flareGradient.addColorStop(0.5, `${haloBaseColor}${flare.alpha * 0.5})`);\n            flareGradient.addColorStop(1, `${haloBaseColor}0)`);\n            this.ctx.fillStyle = flareGradient;\n            this.ctx.beginPath();\n            this.ctx.arc(flareX, flareY, flareRadius, 0, Math.PI * 2);\n            this.ctx.fill();\n        }\n        // Draw subtle hexagonal starburst around the sun\n        this.ctx.save();\n        this.ctx.globalAlpha = 0.2;\n        this.ctx.strokeStyle = this.colorScheme.lensFlareHalo;\n        this.ctx.lineWidth = 2;\n        for (let i = 0; i < 6; i++) {\n            const angle = (Math.PI / 3) * i;\n            const rayLength = screenRadius * 1.5;\n            const startX = screenPos.x + Math.cos(angle) * screenRadius * 0.7;\n            const startY = screenPos.y + Math.sin(angle) * screenRadius * 0.7;\n            const endX = screenPos.x + Math.cos(angle) * rayLength;\n            const endY = screenPos.y + Math.sin(angle) * rayLength;\n            // Create gradient for each ray - increase alpha for better visibility\n            const rayGradient = this.ctx.createLinearGradient(startX, startY, endX, endY);\n            const rayColor = haloBaseColor + '0.4)';\n            rayGradient.addColorStop(0, rayColor);\n            rayGradient.addColorStop(1, `${haloBaseColor}0)`);\n            this.ctx.strokeStyle = rayGradient;\n            this.ctx.beginPath();\n            this.ctx.moveTo(startX, startY);\n            this.ctx.lineTo(endX, endY);\n            this.ctx.stroke();\n        }\n        this.ctx.restore();\n    }\n    /**\n     * Draw a Stellar Forge\n     */\n    drawStellarForge(forge, color, game, isEnemy) {\n        const screenPos = this.worldToScreen(forge.position);\n        const size = 40 * this.zoom;\n        // Check visibility for enemy forges\n        let shouldDim = false;\n        let displayColor = color;\n        if (isEnemy && this.viewingPlayer) {\n            const isVisible = game.isObjectVisibleToPlayer(forge.position, this.viewingPlayer);\n            if (!isVisible) {\n                return; // Don't draw invisible enemy forge\n            }\n            // Check if in shadow for dimming effect - darken color instead of using alpha\n            const inShadow = game.isPointInShadow(forge.position);\n            if (inShadow) {\n                shouldDim = true;\n                displayColor = this.darkenColor(color, _constants__WEBPACK_IMPORTED_MODULE_1__.SHADE_OPACITY);\n            }\n        }\n        // Draw selection circle if selected\n        if (forge.isSelected) {\n            this.ctx.strokeStyle = '#00FFFF';\n            this.ctx.lineWidth = 4;\n            this.ctx.beginPath();\n            this.ctx.arc(screenPos.x, screenPos.y, size * 1.5, 0, Math.PI * 2);\n            this.ctx.stroke();\n            // Draw minion path if it exists\n            if (forge.minionPath.length > 0) {\n                this.ctx.strokeStyle = '#FFFF00'; // Yellow path\n                this.ctx.lineWidth = 3;\n                this.ctx.setLineDash([10, 5]); // Dashed line\n                this.ctx.beginPath();\n                // Start from the forge position\n                const startScreen = this.worldToScreen(forge.position);\n                this.ctx.moveTo(startScreen.x, startScreen.y);\n                // Draw line through all waypoints\n                for (const waypoint of forge.minionPath) {\n                    const waypointScreen = this.worldToScreen(waypoint);\n                    this.ctx.lineTo(waypointScreen.x, waypointScreen.y);\n                }\n                this.ctx.stroke();\n                this.ctx.setLineDash([]); // Reset to solid line\n                // Draw waypoint markers\n                this.ctx.fillStyle = '#FFFF00';\n                for (let i = 0; i < forge.minionPath.length; i++) {\n                    const waypoint = forge.minionPath[i];\n                    const waypointScreen = this.worldToScreen(waypoint);\n                    this.ctx.beginPath();\n                    this.ctx.arc(waypointScreen.x, waypointScreen.y, 5, 0, Math.PI * 2);\n                    this.ctx.fill();\n                    // Draw number for waypoint\n                    if (i === forge.minionPath.length - 1) {\n                        // Last waypoint gets special marker\n                        this.ctx.strokeStyle = '#FFFF00';\n                        this.ctx.lineWidth = 2;\n                        this.ctx.beginPath();\n                        this.ctx.arc(waypointScreen.x, waypointScreen.y, 8, 0, Math.PI * 2);\n                        this.ctx.stroke();\n                    }\n                }\n            }\n            // Draw path preview while drawing a new path\n            if (this.pathPreviewForge === forge && (this.pathPreviewPoints.length > 0 || this.pathPreviewEnd)) {\n                this.drawMinionPathPreview(forge.position, this.pathPreviewPoints, this.pathPreviewEnd);\n            }\n            if (forge.isSelected && this.selectedHeroNames.length > 0) {\n                // Draw hero production buttons around the forge\n                this.drawHeroButtons(forge, screenPos, this.selectedHeroNames);\n            }\n        }\n        // Draw base structure - use darkened color if should dim\n        const tintColor = shouldDim\n            ? this.darkenColor(isEnemy ? this.enemyColor : this.playerColor, _constants__WEBPACK_IMPORTED_MODULE_1__.SHADE_OPACITY)\n            : (isEnemy ? this.enemyColor : this.playerColor);\n        const forgeSpritePath = this.getForgeSpritePath(forge);\n        const forgeSprite = forgeSpritePath ? this.getTintedSprite(forgeSpritePath, tintColor) : null;\n        if (forgeSprite) {\n            const spriteSize = size * this.FORGE_SPRITE_SCALE;\n            this.ctx.drawImage(forgeSprite, screenPos.x - spriteSize / 2, screenPos.y - spriteSize / 2, spriteSize, spriteSize);\n            this.drawForgeFlames(forge, screenPos, spriteSize, game, shouldDim);\n            this.ctx.strokeStyle = forge.isReceivingLight\n                ? (shouldDim ? this.darkenColor('#00FF00', _constants__WEBPACK_IMPORTED_MODULE_1__.SHADE_OPACITY) : '#00FF00')\n                : (shouldDim ? this.darkenColor('#FF0000', _constants__WEBPACK_IMPORTED_MODULE_1__.SHADE_OPACITY) : '#FF0000');\n            this.ctx.lineWidth = 3;\n            this.ctx.beginPath();\n            this.ctx.arc(screenPos.x, screenPos.y, spriteSize * 0.52, 0, Math.PI * 2);\n            this.ctx.stroke();\n        }\n        else {\n            this.ctx.fillStyle = displayColor;\n            this.ctx.strokeStyle = forge.isReceivingLight ?\n                (shouldDim ? this.darkenColor('#00FF00', _constants__WEBPACK_IMPORTED_MODULE_1__.SHADE_OPACITY) : '#00FF00') :\n                (shouldDim ? this.darkenColor('#FF0000', _constants__WEBPACK_IMPORTED_MODULE_1__.SHADE_OPACITY) : '#FF0000');\n            this.ctx.lineWidth = 3;\n            // Draw as a hexagon with rotation\n            this.ctx.beginPath();\n            for (let i = 0; i < 6; i++) {\n                const angle = (Math.PI / 3) * i + forge.rotation;\n                const x = screenPos.x + size * Math.cos(angle);\n                const y = screenPos.y + size * Math.sin(angle);\n                if (i === 0) {\n                    this.ctx.moveTo(x, y);\n                }\n                else {\n                    this.ctx.lineTo(x, y);\n                }\n            }\n            this.ctx.closePath();\n            this.ctx.fill();\n            this.ctx.stroke();\n        }\n        this.drawHealthDisplay(screenPos, forge.health, this.FORGE_MAX_HEALTH, size, -size - 15);\n        if (forge.heroProductionUnitType && forge.heroProductionDurationSec > 0) {\n            const barWidth = size * 2;\n            const barHeight = 6;\n            const barX = screenPos.x - barWidth / 2;\n            const barY = screenPos.y + size + 10;\n            const progressPercent = Math.max(0, Math.min(1, 1 - (forge.heroProductionRemainingSec / forge.heroProductionDurationSec)));\n            this.ctx.fillStyle = '#222';\n            this.ctx.fillRect(barX, barY, barWidth, barHeight);\n            this.ctx.fillStyle = '#00FF88';\n            this.ctx.fillRect(barX, barY, barWidth * progressPercent, barHeight);\n        }\n        // Draw move order indicator if forge has one\n        if (forge.moveOrder > 0 && forge.targetPosition) {\n            this.drawMoveOrderIndicator(forge.position, forge.targetPosition, forge.moveOrder, shouldDim ? displayColor : color);\n        }\n    }\n    /**\n     * Draw hero production buttons around selected Stellar Forge\n     */\n    drawHeroButtons(forge, screenPos, heroNames) {\n        const buttonRadius = _constants__WEBPACK_IMPORTED_MODULE_1__.HERO_BUTTON_RADIUS_PX * this.zoom;\n        const buttonDistance = (_constants__WEBPACK_IMPORTED_MODULE_1__.HERO_BUTTON_DISTANCE_PX * this.zoom);\n        // Draw 4 buttons in cardinal directions\n        const positions = [\n            { x: 0, y: -1 }, // Top\n            { x: 1, y: 0 }, // Right\n            { x: 0, y: 1 }, // Bottom\n            { x: -1, y: 0 } // Left\n        ];\n        const displayHeroes = heroNames.slice(0, positions.length);\n        for (let i = 0; i < displayHeroes.length; i++) {\n            const heroName = displayHeroes[i];\n            const pos = positions[i];\n            const buttonX = screenPos.x + pos.x * buttonDistance;\n            const buttonY = screenPos.y + pos.y * buttonDistance;\n            const heroUnitType = this.getHeroUnitType(heroName);\n            const isHeroAlive = heroUnitType ? this.isHeroUnitAlive(forge.owner, heroUnitType) : false;\n            const isHeroProducing = heroUnitType ? this.isHeroUnitQueuedOrProducing(forge, heroUnitType) : false;\n            const isAvailable = heroUnitType ? !isHeroAlive && !isHeroProducing : false;\n            // Draw button background\n            this.ctx.fillStyle = isAvailable ? 'rgba(0, 255, 136, 0.3)' : 'rgba(128, 128, 128, 0.3)';\n            this.ctx.strokeStyle = isAvailable ? '#00FF88' : '#888888';\n            this.ctx.lineWidth = 2;\n            this.ctx.beginPath();\n            this.ctx.arc(buttonX, buttonY, buttonRadius, 0, Math.PI * 2);\n            this.ctx.fill();\n            this.ctx.stroke();\n            // Draw button label\n            this.ctx.fillStyle = isAvailable ? '#FFFFFF' : '#666666';\n            this.ctx.font = `${14 * this.zoom}px Doto`;\n            this.ctx.textAlign = 'center';\n            this.ctx.textBaseline = 'middle';\n            this.ctx.fillText(heroName, buttonX, buttonY);\n            if (isHeroProducing) {\n                this.drawHeroHourglass(buttonX, buttonY, buttonRadius);\n            }\n            else if (isHeroAlive) {\n                this.drawHeroCheckmark(buttonX, buttonY, buttonRadius);\n            }\n        }\n    }\n    getHeroUnitType(heroName) {\n        switch (heroName) {\n            case 'Marine':\n            case 'Grave':\n            case 'Ray':\n            case 'Dagger':\n            case 'Beam':\n            case 'Driller':\n                return heroName;\n            case 'Influence Ball':\n                return 'InfluenceBall';\n            case 'Turret Deployer':\n                return 'TurretDeployer';\n            default:\n                return null;\n        }\n    }\n    isHeroUnitOfType(unit, heroUnitType) {\n        switch (heroUnitType) {\n            case 'Marine':\n                return unit instanceof _game_core__WEBPACK_IMPORTED_MODULE_0__.Marine;\n            case 'Grave':\n                return unit instanceof _game_core__WEBPACK_IMPORTED_MODULE_0__.Grave;\n            case 'Ray':\n                return unit instanceof _game_core__WEBPACK_IMPORTED_MODULE_0__.Ray;\n            case 'InfluenceBall':\n                return unit instanceof _game_core__WEBPACK_IMPORTED_MODULE_0__.InfluenceBall;\n            case 'TurretDeployer':\n                return unit instanceof _game_core__WEBPACK_IMPORTED_MODULE_0__.TurretDeployer;\n            case 'Driller':\n                return unit instanceof _game_core__WEBPACK_IMPORTED_MODULE_0__.Driller;\n            case 'Dagger':\n                return unit instanceof _game_core__WEBPACK_IMPORTED_MODULE_0__.Dagger;\n            case 'Beam':\n                return unit instanceof _game_core__WEBPACK_IMPORTED_MODULE_0__.Beam;\n            case 'Mortar':\n                return unit instanceof _game_core__WEBPACK_IMPORTED_MODULE_0__.Mortar;\n            case 'Preist':\n                return unit instanceof _game_core__WEBPACK_IMPORTED_MODULE_0__.Preist;\n            default:\n                return false;\n        }\n    }\n    isHeroUnitAlive(player, heroUnitType) {\n        return player.units.some((unit) => this.isHeroUnitOfType(unit, heroUnitType));\n    }\n    isHeroUnitQueuedOrProducing(forge, heroUnitType) {\n        return forge.heroProductionUnitType === heroUnitType || forge.unitQueue.includes(heroUnitType);\n    }\n    drawHeroHourglass(centerX, centerY, radius) {\n        const iconWidth = radius * 0.7;\n        const iconHeight = radius * 0.8;\n        const leftX = centerX - iconWidth * 0.5;\n        const rightX = centerX + iconWidth * 0.5;\n        const topY = centerY - iconHeight * 0.5;\n        const bottomY = centerY + iconHeight * 0.5;\n        const midY = centerY;\n        this.ctx.strokeStyle = '#CCCCCC';\n        this.ctx.lineWidth = Math.max(1, 2 * this.zoom);\n        this.ctx.beginPath();\n        this.ctx.moveTo(leftX, topY);\n        this.ctx.lineTo(rightX, topY);\n        this.ctx.lineTo(centerX, midY);\n        this.ctx.closePath();\n        this.ctx.stroke();\n        this.ctx.beginPath();\n        this.ctx.moveTo(leftX, bottomY);\n        this.ctx.lineTo(rightX, bottomY);\n        this.ctx.lineTo(centerX, midY);\n        this.ctx.closePath();\n        this.ctx.stroke();\n    }\n    drawHeroCheckmark(centerX, centerY, radius) {\n        const iconWidth = radius * 0.7;\n        const iconHeight = radius * 0.6;\n        const startX = centerX - iconWidth * 0.45;\n        const startY = centerY + iconHeight * 0.05;\n        const midX = centerX - iconWidth * 0.1;\n        const midY = centerY + iconHeight * 0.35;\n        const endX = centerX + iconWidth * 0.5;\n        const endY = centerY - iconHeight * 0.35;\n        this.ctx.strokeStyle = '#CCCCCC';\n        this.ctx.lineWidth = Math.max(1, 2 * this.zoom);\n        this.ctx.beginPath();\n        this.ctx.moveTo(startX, startY);\n        this.ctx.lineTo(midX, midY);\n        this.ctx.lineTo(endX, endY);\n        this.ctx.stroke();\n    }\n    /**\n     * Draw a Solar Mirror with flat surface, rotation, and proximity-based glow\n     */\n    drawSolarMirror(mirror, color, game, isEnemy) {\n        // Check visibility for enemy mirrors\n        let shouldDim = false;\n        let displayColor = color;\n        if (isEnemy && this.viewingPlayer) {\n            const isVisible = game.isObjectVisibleToPlayer(mirror.position, this.viewingPlayer);\n            if (!isVisible) {\n                return; // Don't draw invisible enemy mirrors\n            }\n            // Check if in shadow for dimming effect - darken color instead of using alpha\n            const inShadow = game.isPointInShadow(mirror.position);\n            if (inShadow) {\n                shouldDim = true;\n                displayColor = this.darkenColor(color, _constants__WEBPACK_IMPORTED_MODULE_1__.SHADE_OPACITY);\n            }\n        }\n        const screenPos = this.worldToScreen(mirror.position);\n        const size = 20 * this.zoom;\n        // Save context state\n        this.ctx.save();\n        // Calculate glow intensity based on distance to closest sun\n        // Closer = brighter glow (inverse relationship)\n        const glowIntensity = Math.max(0, Math.min(1, 1 - (mirror.closestSunDistance / _constants__WEBPACK_IMPORTED_MODULE_1__.MIRROR_MAX_GLOW_DISTANCE)));\n        // Draw glow if close to a light source\n        if (glowIntensity > 0.1 && mirror.closestSunDistance !== Infinity) {\n            const glowRadius = _constants__WEBPACK_IMPORTED_MODULE_1__.MIRROR_ACTIVE_GLOW_RADIUS * this.zoom * (1 + glowIntensity);\n            const gradient = this.ctx.createRadialGradient(screenPos.x, screenPos.y, 0, screenPos.x, screenPos.y, glowRadius);\n            gradient.addColorStop(0, `rgba(255, 255, 150, ${glowIntensity * 0.8})`);\n            gradient.addColorStop(0.5, `rgba(255, 255, 100, ${glowIntensity * 0.4})`);\n            gradient.addColorStop(1, 'rgba(255, 255, 50, 0)');\n            this.ctx.fillStyle = gradient;\n            this.ctx.beginPath();\n            this.ctx.arc(screenPos.x, screenPos.y, glowRadius, 0, Math.PI * 2);\n            this.ctx.fill();\n            // Draw reflected light beam in front of the mirror\n            // Find the closest visible sun to determine reflection direction\n            const closestSun = mirror.getClosestVisibleSun(game.suns, game.asteroids);\n            if (closestSun) {\n                const forge = mirror.owner.stellarForge;\n                let reflectDir = null;\n                if (forge && mirror.hasLineOfSightToForge(forge, game.asteroids, game.players)) {\n                    reflectDir = new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(forge.position.x - mirror.position.x, forge.position.y - mirror.position.y).normalize();\n                }\n                else {\n                    const sunDir = new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(closestSun.position.x - mirror.position.x, closestSun.position.y - mirror.position.y).normalize();\n                    reflectDir = new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(-sunDir.x, -sunDir.y);\n                }\n                // Draw reflected light beam (a few feet / ~100 units in front of mirror)\n                const beamLength = 100;\n                const beamEnd = new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(mirror.position.x + reflectDir.x * beamLength, mirror.position.y + reflectDir.y * beamLength);\n                const beamEndScreen = this.worldToScreen(beamEnd);\n                // Draw bright beam with doubled intensity\n                const beamGradient = this.ctx.createLinearGradient(screenPos.x, screenPos.y, beamEndScreen.x, beamEndScreen.y);\n                beamGradient.addColorStop(0, `rgba(255, 255, 200, ${glowIntensity * 1.0})`);\n                beamGradient.addColorStop(0.7, `rgba(255, 255, 150, ${glowIntensity * 0.6})`);\n                beamGradient.addColorStop(1, 'rgba(255, 255, 100, 0)');\n                this.ctx.strokeStyle = beamGradient;\n                this.ctx.lineWidth = 15 * this.zoom * glowIntensity;\n                this.ctx.lineCap = 'round';\n                this.ctx.beginPath();\n                this.ctx.moveTo(screenPos.x, screenPos.y);\n                this.ctx.lineTo(beamEndScreen.x, beamEndScreen.y);\n                this.ctx.stroke();\n                // Add a bright spot at the end of the beam for doubled brightness effect\n                const endGlowRadius = 20 * this.zoom * glowIntensity;\n                const endGradient = this.ctx.createRadialGradient(beamEndScreen.x, beamEndScreen.y, 0, beamEndScreen.x, beamEndScreen.y, endGlowRadius);\n                endGradient.addColorStop(0, `rgba(255, 255, 255, ${glowIntensity * 0.9})`);\n                endGradient.addColorStop(0.5, `rgba(255, 255, 200, ${glowIntensity * 0.5})`);\n                endGradient.addColorStop(1, 'rgba(255, 255, 150, 0)');\n                this.ctx.fillStyle = endGradient;\n                this.ctx.beginPath();\n                this.ctx.arc(beamEndScreen.x, beamEndScreen.y, endGlowRadius, 0, Math.PI * 2);\n                this.ctx.fill();\n            }\n        }\n        // Translate to mirror position and rotate for reflection angle\n        this.ctx.translate(screenPos.x, screenPos.y);\n        this.ctx.rotate(mirror.reflectionAngle);\n        const surfaceLength = size * 2;\n        const surfaceThickness = size * 0.3;\n        let selectionWidth = surfaceLength;\n        let selectionHeight = surfaceThickness;\n        let drewSprite = false;\n        const mirrorSpritePath = this.getSolarMirrorSpritePath(mirror);\n        if (mirrorSpritePath) {\n            // Determine the color for the mirror (use displayColor which already accounts for enemy status and shadow)\n            const mirrorColor = this.brightenAndPaleColor(displayColor);\n            // Use tinted sprite for solar mirror\n            const mirrorSprite = this.getTintedSprite(mirrorSpritePath, mirrorColor);\n            if (mirrorSprite) {\n                const targetSize = size * 2.4;\n                const scale = targetSize / Math.max(mirrorSprite.width, mirrorSprite.height);\n                const drawWidth = mirrorSprite.width * scale;\n                const drawHeight = mirrorSprite.height * scale;\n                selectionWidth = drawWidth;\n                selectionHeight = drawHeight;\n                this.ctx.drawImage(mirrorSprite, -drawWidth / 2, -drawHeight / 2, drawWidth, drawHeight);\n                drewSprite = true;\n            }\n        }\n        if (!drewSprite) {\n            // Draw flat reflective surface (rectangle)\n            const surfaceGradient = this.ctx.createLinearGradient(0, -surfaceThickness / 2, 0, surfaceThickness / 2);\n            surfaceGradient.addColorStop(0, '#FFFFFF');\n            surfaceGradient.addColorStop(0.5, '#E0E0E0');\n            surfaceGradient.addColorStop(1, '#C0C0C0');\n            this.ctx.fillStyle = surfaceGradient;\n            this.ctx.fillRect(-surfaceLength / 2, -surfaceThickness / 2, surfaceLength, surfaceThickness);\n            // Draw border for the surface\n            this.ctx.strokeStyle = displayColor;\n            this.ctx.lineWidth = 2;\n            this.ctx.strokeRect(-surfaceLength / 2, -surfaceThickness / 2, surfaceLength, surfaceThickness);\n            // Draw small indicator dots at the ends\n            this.ctx.fillStyle = displayColor;\n            this.ctx.beginPath();\n            this.ctx.arc(-surfaceLength / 2, 0, 3, 0, Math.PI * 2);\n            this.ctx.fill();\n            this.ctx.beginPath();\n            this.ctx.arc(surfaceLength / 2, 0, 3, 0, Math.PI * 2);\n            this.ctx.fill();\n        }\n        if (mirror.isSelected) {\n            this.ctx.strokeStyle = '#FFFF00';\n            this.ctx.lineWidth = 3;\n            this.ctx.strokeRect(-selectionWidth / 2 - 3, -selectionHeight / 2 - 3, selectionWidth + 6, selectionHeight + 6);\n        }\n        // Restore context state\n        this.ctx.restore();\n        // Draw efficiency indicator (in world space, not rotated)\n        if (mirror.efficiency < 1.0) {\n            this.ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';\n            this.ctx.beginPath();\n            this.ctx.arc(screenPos.x, screenPos.y, size * 0.3, 0, Math.PI * 2);\n            this.ctx.fill();\n        }\n        // Draw move order indicator if mirror has one\n        if (mirror.moveOrder > 0 && mirror.targetPosition) {\n            this.drawMoveOrderIndicator(mirror.position, mirror.targetPosition, mirror.moveOrder, color);\n        }\n        this.drawHealthDisplay(screenPos, mirror.health, this.MIRROR_MAX_HEALTH, size, -size - 10);\n        if (mirror.isSelected) {\n            const hasLoSToSun = mirror.hasLineOfSightToLight(game.suns, game.asteroids);\n            const forge = mirror.owner.stellarForge;\n            const hasLoSToForge = forge\n                ? mirror.hasLineOfSightToForge(forge, game.asteroids, game.players)\n                : false;\n            const energyRate = hasLoSToSun && hasLoSToForge ? mirror.getEnergyRatePerSec() : 0;\n            const textY = screenPos.y + size + 16 * this.zoom;\n            this.ctx.fillStyle = '#FFFFAA';\n            this.ctx.font = `${12 * this.zoom}px Doto`;\n            this.ctx.textAlign = 'center';\n            this.ctx.textBaseline = 'middle';\n            this.ctx.fillText(`+${energyRate.toFixed(0)}/s`, screenPos.x, textY);\n        }\n    }\n    /**\n     * Draw space dust particle with lightweight circle rendering\n     */\n    drawSpaceDust(particle, game, viewingPlayerIndex) {\n        const screenPos = this.worldToScreen(particle.position);\n        const baseSize = _constants__WEBPACK_IMPORTED_MODULE_1__.DUST_PARTICLE_SIZE * this.zoom;\n        // Check if particle is in shadow\n        const inShadow = game.isPointInShadow(particle.position);\n        if (viewingPlayerIndex !== null) {\n            // If particle is in shade, only draw if it's visible to player's units\n            if (inShadow) {\n                const viewingPlayer = game.players[viewingPlayerIndex];\n                const isVisible = game.isObjectVisibleToPlayer(particle.position, viewingPlayer);\n                if (!isVisible) {\n                    return; // Don't draw particles in shade that aren't in unit sight\n                }\n            }\n        }\n        let glowLevel = particle.glowState;\n        if (particle.glowTransition > 0 && particle.glowState !== particle.targetGlowState) {\n            glowLevel = particle.glowState + (particle.targetGlowState - particle.glowState) * particle.glowTransition;\n        }\n        if (glowLevel > 0) {\n            const glowSize = baseSize * (1.2 + glowLevel * 0.35);\n            this.ctx.fillStyle = particle.currentColor;\n            this.ctx.globalAlpha = 0.15 + glowLevel * 0.1;\n            this.ctx.beginPath();\n            this.ctx.arc(screenPos.x, screenPos.y, glowSize, 0, Math.PI * 2);\n            this.ctx.fill();\n            this.ctx.globalAlpha = 1.0;\n        }\n        this.ctx.fillStyle = particle.currentColor;\n        this.ctx.beginPath();\n        this.ctx.arc(screenPos.x, screenPos.y, baseSize, 0, Math.PI * 2);\n        this.ctx.fill();\n    }\n    getClosestInfluenceOwnerIndex(position, game) {\n        let closestDistance = Infinity;\n        let closestIndex = null;\n        for (let i = 0; i < game.players.length; i++) {\n            const player = game.players[i];\n            if (player.stellarForge && !player.isDefeated()) {\n                const distance = position.distanceTo(player.stellarForge.position);\n                if (distance < _constants__WEBPACK_IMPORTED_MODULE_1__.INFLUENCE_RADIUS && distance < closestDistance) {\n                    closestDistance = distance;\n                    closestIndex = i;\n                }\n            }\n        }\n        return closestIndex;\n    }\n    /**\n     * Draw an asteroid\n     */\n    drawAsteroid(asteroid) {\n        const worldVertices = asteroid.getWorldVertices();\n        if (worldVertices.length === 0)\n            return;\n        const screenVertices = worldVertices.map(v => this.worldToScreen(v));\n        const sizeRange = _constants__WEBPACK_IMPORTED_MODULE_1__.ASTEROID_MAX_SIZE - _constants__WEBPACK_IMPORTED_MODULE_1__.ASTEROID_MIN_SIZE;\n        const sizeT = sizeRange > 0\n            ? Math.min(1, Math.max(0, (asteroid.size - _constants__WEBPACK_IMPORTED_MODULE_1__.ASTEROID_MIN_SIZE) / sizeRange))\n            : 0;\n        const asteroidFill = this.interpolateHexColor(this.colorScheme.asteroidColors.fillStart, this.colorScheme.asteroidColors.fillEnd, sizeT);\n        const asteroidStroke = this.interpolateHexColor(this.colorScheme.asteroidColors.strokeStart, this.colorScheme.asteroidColors.strokeEnd, sizeT);\n        // Draw asteroid body\n        this.ctx.fillStyle = asteroidFill;\n        this.ctx.strokeStyle = asteroidStroke;\n        this.ctx.lineWidth = 2;\n        this.ctx.beginPath();\n        this.ctx.moveTo(screenVertices[0].x, screenVertices[0].y);\n        for (let i = 1; i < screenVertices.length; i++) {\n            this.ctx.lineTo(screenVertices[i].x, screenVertices[i].y);\n        }\n        this.ctx.closePath();\n        this.ctx.fill();\n        this.ctx.stroke();\n    }\n    /**\n     * Draw sun rays with raytracing (brightens field and casts shadows)\n     */\n    drawSunRays(game) {\n        // Draw ambient lighting layers for each sun (brighter closer to sun)\n        for (const sun of game.suns) {\n            const sunScreenPos = this.worldToScreen(sun.position);\n            const maxRadius = Math.max(this.canvas.width, this.canvas.height) * 2;\n            // Create radial gradient centered on the sun\n            const gradient = this.ctx.createRadialGradient(sunScreenPos.x, sunScreenPos.y, 0, sunScreenPos.x, sunScreenPos.y, maxRadius);\n            // Use color scheme for subtle brightness falloff from sun\n            gradient.addColorStop(0, this.colorScheme.sunLightRays.nearCenter); // Brightest near sun\n            gradient.addColorStop(0.5, this.colorScheme.sunLightRays.mid); // Medium\n            gradient.addColorStop(1, this.colorScheme.sunLightRays.edge); // Fade out\n            this.ctx.fillStyle = gradient;\n            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n        }\n        // Draw asteroid shadows cast by sunlight\n        // Process each sun separately so overlapping shadows from the same sun don't stack\n        for (const sun of game.suns) {\n            this.ctx.save();\n            this.ctx.globalCompositeOperation = 'source-over';\n            this.ctx.fillStyle = 'rgba(0, 0, 20, 0.5)';\n            let hasShadowPath = false;\n            this.ctx.beginPath();\n            // Draw shadow regions behind asteroids\n            for (const asteroid of game.asteroids) {\n                const worldVertices = asteroid.getWorldVertices();\n                // For each edge of the asteroid, cast a shadow\n                for (let i = 0; i < worldVertices.length; i++) {\n                    const v1 = worldVertices[i];\n                    const v2 = worldVertices[(i + 1) % worldVertices.length];\n                    // Calculate if this edge faces away from the sun\n                    const edgeCenter = new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D((v1.x + v2.x) / 2, (v1.y + v2.y) / 2);\n                    const toSun = new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(sun.position.x - edgeCenter.x, sun.position.y - edgeCenter.y);\n                    const edgeNormal = new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(-(v2.y - v1.y), v2.x - v1.x);\n                    const dot = toSun.x * edgeNormal.x + toSun.y * edgeNormal.y;\n                    if (dot < 0) {\n                        // This edge is facing away from the sun, cast shadow\n                        const dirFromSun1 = new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(v1.x - sun.position.x, v1.y - sun.position.y).normalize();\n                        const dirFromSun2 = new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(v2.x - sun.position.x, v2.y - sun.position.y).normalize();\n                        const shadow1 = new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(v1.x + dirFromSun1.x * _constants__WEBPACK_IMPORTED_MODULE_1__.SHADOW_LENGTH, v1.y + dirFromSun1.y * _constants__WEBPACK_IMPORTED_MODULE_1__.SHADOW_LENGTH);\n                        const shadow2 = new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(v2.x + dirFromSun2.x * _constants__WEBPACK_IMPORTED_MODULE_1__.SHADOW_LENGTH, v2.y + dirFromSun2.y * _constants__WEBPACK_IMPORTED_MODULE_1__.SHADOW_LENGTH);\n                        const sv1 = this.worldToScreen(v1);\n                        const sv2 = this.worldToScreen(v2);\n                        const ss1 = this.worldToScreen(shadow1);\n                        const ss2 = this.worldToScreen(shadow2);\n                        // Add shadow polygon to a single path so overlaps don't darken\n                        this.ctx.moveTo(sv1.x, sv1.y);\n                        this.ctx.lineTo(sv2.x, sv2.y);\n                        this.ctx.lineTo(ss2.x, ss2.y);\n                        this.ctx.lineTo(ss1.x, ss1.y);\n                        this.ctx.closePath();\n                        hasShadowPath = true;\n                    }\n                }\n            }\n            if (hasShadowPath) {\n                this.ctx.fill();\n            }\n            this.ctx.restore();\n        }\n    }\n    /**\n     * Draw influence circle for a base\n     */\n    drawInfluenceCircle(position, radius, color) {\n        const screenPos = this.worldToScreen(position);\n        const screenRadius = radius * this.zoom;\n        // Draw outer ring\n        this.ctx.strokeStyle = color;\n        this.ctx.lineWidth = 2;\n        this.ctx.globalAlpha = 0.3;\n        this.ctx.beginPath();\n        this.ctx.arc(screenPos.x, screenPos.y, screenRadius, 0, Math.PI * 2);\n        this.ctx.stroke();\n        this.ctx.globalAlpha = 1.0;\n    }\n    /**\n     * Draw a warp gate\n     */\n    drawWarpGate(gate) {\n        const screenPos = this.worldToScreen(gate.position);\n        const maxRadius = _constants__WEBPACK_IMPORTED_MODULE_1__.WARP_GATE_RADIUS * this.zoom;\n        const chargeProgress = gate.chargeTime / _constants__WEBPACK_IMPORTED_MODULE_1__.WARP_GATE_CHARGE_TIME;\n        const currentRadius = Math.min(maxRadius, chargeProgress * maxRadius);\n        if (!gate.isComplete) {\n            // Draw charging effect\n            this.ctx.strokeStyle = '#00FFFF';\n            this.ctx.lineWidth = 3;\n            this.ctx.globalAlpha = 0.5 + Math.sin(gate.chargeTime * 5) * 0.2;\n            this.ctx.beginPath();\n            this.ctx.arc(screenPos.x, screenPos.y, currentRadius, 0, Math.PI * 2);\n            this.ctx.stroke();\n            this.ctx.globalAlpha = 1.0;\n            // Draw charge progress\n            this.ctx.strokeStyle = '#FFFFFF';\n            this.ctx.lineWidth = 5;\n            this.ctx.beginPath();\n            this.ctx.arc(screenPos.x, screenPos.y, currentRadius + 5, 0, chargeProgress * Math.PI * 2);\n            this.ctx.stroke();\n        }\n        else {\n            // Draw completed warp gate\n            this.ctx.fillStyle = 'rgba(0, 255, 255, 0.3)';\n            this.ctx.beginPath();\n            this.ctx.arc(screenPos.x, screenPos.y, maxRadius, 0, Math.PI * 2);\n            this.ctx.fill();\n            this.ctx.strokeStyle = '#00FFFF';\n            this.ctx.lineWidth = 3;\n            this.ctx.beginPath();\n            this.ctx.arc(screenPos.x, screenPos.y, maxRadius, 0, Math.PI * 2);\n            this.ctx.stroke();\n            // Draw 4 build buttons around the gate\n            const buttonRadius = _constants__WEBPACK_IMPORTED_MODULE_1__.WARP_GATE_BUTTON_RADIUS * this.zoom;\n            const buttonDistance = maxRadius + _constants__WEBPACK_IMPORTED_MODULE_1__.WARP_GATE_BUTTON_OFFSET * this.zoom;\n            const angles = [0, Math.PI / 2, Math.PI, 3 * Math.PI / 2];\n            const labels = ['Cannon', 'Swirler', 'Foundry', 'Locked'];\n            for (let i = 0; i < 4; i++) {\n                const angle = angles[i];\n                const btnX = screenPos.x + Math.cos(angle) * buttonDistance;\n                const btnY = screenPos.y + Math.sin(angle) * buttonDistance;\n                const labelOffset = buttonRadius + 14 * this.zoom;\n                this.ctx.fillStyle = i === 3 ? '#2A2A2A' : '#444444';\n                this.ctx.strokeStyle = '#00FFFF';\n                this.ctx.lineWidth = 2;\n                this.ctx.beginPath();\n                this.ctx.arc(btnX, btnY, buttonRadius, 0, Math.PI * 2);\n                this.ctx.fill();\n                this.ctx.stroke();\n                // Draw button label\n                this.ctx.fillStyle = i === 3 ? 'rgba(255, 255, 255, 0.6)' : '#FFFFFF';\n                this.ctx.font = `${11 * this.zoom}px Doto`;\n                this.ctx.textAlign = 'center';\n                this.ctx.textBaseline = 'middle';\n                this.ctx.fillText(labels[i], btnX + Math.cos(angle) * labelOffset, btnY + Math.sin(angle) * labelOffset);\n            }\n            this.ctx.textAlign = 'left';\n            this.ctx.textBaseline = 'alphabetic';\n        }\n    }\n    /**\n     * Draw a unit\n     */\n    drawUnit(unit, color, game, isEnemy, sizeMultiplier = 1.0) {\n        const screenPos = this.worldToScreen(unit.position);\n        const size = 8 * this.zoom * sizeMultiplier;\n        const isSelected = this.selectedUnits.has(unit);\n        // Check visibility for enemy units\n        let shouldDim = false;\n        let displayColor = color;\n        if (isEnemy && this.viewingPlayer) {\n            const isVisible = game.isObjectVisibleToPlayer(unit.position, this.viewingPlayer, unit);\n            if (!isVisible) {\n                return; // Don't draw invisible enemy units\n            }\n            // Check if in shadow for dimming effect - darken color instead of using alpha\n            const inShadow = game.isPointInShadow(unit.position);\n            if (inShadow) {\n                shouldDim = true;\n                displayColor = this.darkenColor(color, _constants__WEBPACK_IMPORTED_MODULE_1__.SHADE_OPACITY);\n            }\n        }\n        // Draw attack range circle for selected hero units (only friendly units)\n        if (isSelected && unit.isHero && !isEnemy) {\n            const attackRangeScreenRadius = unit.attackRange * this.zoom;\n            this.ctx.strokeStyle = color;\n            this.ctx.lineWidth = 1;\n            this.ctx.globalAlpha = _constants__WEBPACK_IMPORTED_MODULE_1__.HERO_ATTACK_RANGE_ALPHA;\n            this.ctx.beginPath();\n            this.ctx.arc(screenPos.x, screenPos.y, attackRangeScreenRadius, 0, Math.PI * 2);\n            this.ctx.stroke();\n            this.ctx.globalAlpha = 1.0;\n        }\n        // Draw unit body (circle) - use darkened color if should dim\n        const heroSpritePath = unit.isHero ? this.getHeroSpritePath(unit) : null;\n        const tintColor = shouldDim\n            ? this.darkenColor(isEnemy ? this.enemyColor : this.playerColor, _constants__WEBPACK_IMPORTED_MODULE_1__.SHADE_OPACITY)\n            : (isEnemy ? this.enemyColor : this.playerColor);\n        // Use outlined sprite for selected units, regular tinted sprite otherwise\n        const heroSprite = heroSpritePath\n            ? (isSelected && !isEnemy ? this.getOutlinedTintedSprite(heroSpritePath, tintColor) : this.getTintedSprite(heroSpritePath, tintColor))\n            : null;\n        if (heroSprite) {\n            const spriteSize = size * this.HERO_SPRITE_SCALE;\n            const rotationRad = unit.rotation;\n            this.ctx.save();\n            this.ctx.translate(screenPos.x, screenPos.y);\n            this.ctx.rotate(rotationRad);\n            this.ctx.drawImage(heroSprite, -spriteSize / 2, -spriteSize / 2, spriteSize, spriteSize);\n            this.ctx.restore();\n        }\n        else {\n            this.ctx.fillStyle = displayColor;\n            this.ctx.strokeStyle = isSelected ? '#FFFFFF' : (shouldDim ? this.darkenColor('#FFFFFF', _constants__WEBPACK_IMPORTED_MODULE_1__.SHADE_OPACITY) : '#FFFFFF');\n            this.ctx.lineWidth = isSelected ? 3 : 1;\n            this.ctx.beginPath();\n            this.ctx.arc(screenPos.x, screenPos.y, size, 0, Math.PI * 2);\n            this.ctx.fill();\n            this.ctx.stroke();\n        }\n        this.drawHealthDisplay(screenPos, unit.health, unit.maxHealth, size, -size - 8);\n        // Show stun indicator if unit is stunned\n        if (unit.isStunned()) {\n            this.ctx.fillStyle = '#FFFF00';\n            this.ctx.globalAlpha = 0.7;\n            const stunSize = 6 * this.zoom;\n            // Draw stars around unit to indicate stun\n            for (let i = 0; i < 3; i++) {\n                const angle = (game.gameTime * 3 + i * (Math.PI * 2 / 3)) % (Math.PI * 2);\n                const x = screenPos.x + Math.cos(angle) * (size * 1.8);\n                const y = screenPos.y + Math.sin(angle) * (size * 1.8);\n                this.ctx.beginPath();\n                for (let j = 0; j < 5; j++) {\n                    const starAngle = j * (Math.PI * 2 / 5) - Math.PI / 2;\n                    const starX = x + Math.cos(starAngle) * stunSize * 0.5;\n                    const starY = y + Math.sin(starAngle) * stunSize * 0.5;\n                    if (j === 0) {\n                        this.ctx.moveTo(starX, starY);\n                    }\n                    else {\n                        this.ctx.lineTo(starX, starY);\n                    }\n                }\n                this.ctx.closePath();\n                this.ctx.fill();\n            }\n            this.ctx.globalAlpha = 1.0;\n        }\n        // Draw direction indicator if unit has a target\n        if (!unit.isHero && unit.target) {\n            const dx = unit.target.position.x - unit.position.x;\n            const dy = unit.target.position.y - unit.position.y;\n            const angle = Math.atan2(dy, dx);\n            this.ctx.strokeStyle = shouldDim ? this.darkenColor('#FFFFFF', _constants__WEBPACK_IMPORTED_MODULE_1__.SHADE_OPACITY) : '#FFFFFF';\n            this.ctx.lineWidth = 2;\n            this.ctx.beginPath();\n            this.ctx.moveTo(screenPos.x, screenPos.y);\n            this.ctx.lineTo(screenPos.x + Math.cos(angle) * size * 1.5, screenPos.y + Math.sin(angle) * size * 1.5);\n            this.ctx.stroke();\n        }\n        // Draw move order indicator if unit has one\n        if (unit.moveOrder > 0 && unit.rallyPoint) {\n            this.drawMoveOrderIndicator(unit.position, unit.rallyPoint, unit.moveOrder, shouldDim ? displayColor : color);\n        }\n    }\n    /**\n     * Draw move order indicator (dot and line)\n     */\n    drawMoveOrderIndicator(position, target, order, color) {\n        const screenPos = this.worldToScreen(position);\n        const targetScreenPos = this.worldToScreen(target);\n        // Draw thin line from unit to target\n        this.ctx.strokeStyle = color;\n        this.ctx.lineWidth = 1;\n        this.ctx.globalAlpha = 0.5;\n        this.ctx.setLineDash([5, 5]);\n        this.ctx.beginPath();\n        this.ctx.moveTo(screenPos.x, screenPos.y);\n        this.ctx.lineTo(targetScreenPos.x, targetScreenPos.y);\n        this.ctx.stroke();\n        this.ctx.setLineDash([]);\n        this.ctx.globalAlpha = 1.0;\n        // Draw dot with order number at target\n        const dotRadius = this.MOVE_ORDER_DOT_RADIUS;\n        this.ctx.fillStyle = color;\n        this.ctx.strokeStyle = '#FFFFFF';\n        this.ctx.lineWidth = 2;\n        this.ctx.beginPath();\n        this.ctx.arc(targetScreenPos.x, targetScreenPos.y, dotRadius, 0, Math.PI * 2);\n        this.ctx.fill();\n        this.ctx.stroke();\n        // Draw order number\n        this.ctx.fillStyle = '#FFFFFF';\n        this.ctx.font = 'bold 12px Doto';\n        this.ctx.textAlign = 'center';\n        this.ctx.textBaseline = 'middle';\n        this.ctx.fillText(order.toString(), targetScreenPos.x, targetScreenPos.y);\n    }\n    /**\n     * Draw a muzzle flash\n     */\n    drawMuzzleFlash(flash) {\n        const screenPos = this.worldToScreen(flash.position);\n        const size = 5 * this.zoom;\n        const opacity = 1.0 - (flash.lifetime / flash.maxLifetime);\n        this.ctx.save();\n        this.ctx.translate(screenPos.x, screenPos.y);\n        this.ctx.rotate(flash.angle);\n        // Draw flash as a bright yellow oval\n        this.ctx.fillStyle = `rgba(255, 255, 100, ${opacity})`;\n        this.ctx.beginPath();\n        this.ctx.ellipse(0, 0, size * 2, size, 0, 0, Math.PI * 2);\n        this.ctx.fill();\n        this.ctx.restore();\n    }\n    /**\n     * Draw a bullet casing\n     */\n    drawBulletCasing(casing) {\n        const screenPos = this.worldToScreen(casing.position);\n        const width = 3 * this.zoom;\n        const height = 5 * this.zoom;\n        const opacity = 1.0 - (casing.lifetime / casing.maxLifetime);\n        this.ctx.save();\n        this.ctx.translate(screenPos.x, screenPos.y);\n        this.ctx.rotate(casing.rotation);\n        // Draw casing as a yellow rectangle\n        this.ctx.fillStyle = `rgba(255, 215, 0, ${opacity})`;\n        this.ctx.fillRect(-width / 2, -height / 2, width, height);\n        this.ctx.restore();\n    }\n    /**\n     * Draw a bouncing bullet\n     */\n    drawBouncingBullet(bullet) {\n        const screenPos = this.worldToScreen(bullet.position);\n        const size = 3 * this.zoom;\n        const opacity = 1.0 - (bullet.lifetime / bullet.maxLifetime);\n        // Draw bullet as a yellow circle\n        this.ctx.fillStyle = `rgba(255, 255, 0, ${opacity})`;\n        this.ctx.beginPath();\n        this.ctx.arc(screenPos.x, screenPos.y, size, 0, Math.PI * 2);\n        this.ctx.fill();\n    }\n    /**\n     * Draw an ability bullet\n     */\n    drawAbilityBullet(bullet) {\n        const screenPos = this.worldToScreen(bullet.position);\n        const size = 4 * this.zoom;\n        const opacity = bullet.lifetime / bullet.maxLifetime;\n        // Draw bullet with owner's faction color\n        const color = this.getFactionColor(bullet.owner.faction);\n        this.ctx.fillStyle = `${color}`;\n        this.ctx.globalAlpha = opacity;\n        this.ctx.beginPath();\n        this.ctx.arc(screenPos.x, screenPos.y, size, 0, Math.PI * 2);\n        this.ctx.fill();\n        this.ctx.globalAlpha = 1.0;\n    }\n    /**\n     * Draw a minion projectile\n     */\n    drawMinionProjectile(projectile) {\n        const screenPos = this.worldToScreen(projectile.position);\n        const size = 2.5 * this.zoom;\n        const color = this.getFactionColor(projectile.owner.faction);\n        this.ctx.fillStyle = color;\n        this.ctx.globalAlpha = 0.9;\n        this.ctx.beginPath();\n        this.ctx.arc(screenPos.x, screenPos.y, size, 0, Math.PI * 2);\n        this.ctx.fill();\n        this.ctx.globalAlpha = 1.0;\n    }\n    /**\n     * Draw a mortar projectile (larger, more visible artillery shell)\n     */\n    drawMortarProjectile(projectile) {\n        const screenPos = this.worldToScreen(projectile.position);\n        const size = 6 * this.zoom; // Larger than other projectiles\n        const color = this.getFactionColor(projectile.owner.faction);\n        // Draw outer glow\n        this.ctx.fillStyle = color;\n        this.ctx.globalAlpha = 0.3;\n        this.ctx.beginPath();\n        this.ctx.arc(screenPos.x, screenPos.y, size * 1.5, 0, Math.PI * 2);\n        this.ctx.fill();\n        // Draw main projectile\n        this.ctx.globalAlpha = 1.0;\n        this.ctx.fillStyle = color;\n        this.ctx.beginPath();\n        this.ctx.arc(screenPos.x, screenPos.y, size, 0, Math.PI * 2);\n        this.ctx.fill();\n        // Draw inner highlight\n        this.ctx.fillStyle = '#FFFFFF';\n        this.ctx.globalAlpha = 0.5;\n        this.ctx.beginPath();\n        this.ctx.arc(screenPos.x - size * 0.2, screenPos.y - size * 0.2, size * 0.4, 0, Math.PI * 2);\n        this.ctx.fill();\n        this.ctx.globalAlpha = 1.0;\n    }\n    /**\n     * Draw a laser beam\n     */\n    drawLaserBeam(laser) {\n        const startScreen = this.worldToScreen(laser.startPos);\n        const endScreen = this.worldToScreen(laser.endPos);\n        const color = this.getFactionColor(laser.owner.faction);\n        // Calculate fade based on lifetime\n        const alpha = 1.0 - (laser.lifetime / laser.maxLifetime);\n        // Draw the main laser beam\n        this.ctx.strokeStyle = color;\n        this.ctx.globalAlpha = alpha * 0.8;\n        this.ctx.lineWidth = 2;\n        this.ctx.beginPath();\n        this.ctx.moveTo(startScreen.x, startScreen.y);\n        this.ctx.lineTo(endScreen.x, endScreen.y);\n        this.ctx.stroke();\n        // Draw a glowing outer beam\n        this.ctx.globalAlpha = alpha * 0.3;\n        this.ctx.lineWidth = 4;\n        this.ctx.beginPath();\n        this.ctx.moveTo(startScreen.x, startScreen.y);\n        this.ctx.lineTo(endScreen.x, endScreen.y);\n        this.ctx.stroke();\n        this.ctx.globalAlpha = 1.0;\n    }\n    /**\n     * Draw an impact particle\n     */\n    drawImpactParticle(particle) {\n        const screenPos = this.worldToScreen(particle.position);\n        const color = this.getFactionColor(particle.faction);\n        const alpha = 1.0 - (particle.lifetime / particle.maxLifetime);\n        const size = 1 * this.zoom;\n        this.ctx.fillStyle = color;\n        this.ctx.globalAlpha = alpha;\n        this.ctx.beginPath();\n        this.ctx.arc(screenPos.x, screenPos.y, size, 0, Math.PI * 2);\n        this.ctx.fill();\n        this.ctx.globalAlpha = 1.0;\n    }\n    /**\n     * Draw an influence zone\n     */\n    drawInfluenceZone(zone) {\n        const screenPos = this.worldToScreen(zone.position);\n        const radius = zone.radius * this.zoom;\n        const opacity = Math.max(0.1, 1.0 - (zone.lifetime / zone.duration));\n        const color = this.getFactionColor(zone.owner.faction);\n        // Draw outer ring\n        this.ctx.strokeStyle = color;\n        this.ctx.globalAlpha = opacity * 0.6;\n        this.ctx.lineWidth = 3 * this.zoom;\n        this.ctx.beginPath();\n        this.ctx.arc(screenPos.x, screenPos.y, radius, 0, Math.PI * 2);\n        this.ctx.stroke();\n        // Draw inner fill\n        const gradient = this.ctx.createRadialGradient(screenPos.x, screenPos.y, 0, screenPos.x, screenPos.y, radius);\n        gradient.addColorStop(0, `${color}40`);\n        gradient.addColorStop(1, `${color}10`);\n        this.ctx.fillStyle = gradient;\n        this.ctx.globalAlpha = opacity * 0.3;\n        this.ctx.beginPath();\n        this.ctx.arc(screenPos.x, screenPos.y, radius, 0, Math.PI * 2);\n        this.ctx.fill();\n        this.ctx.globalAlpha = 1.0;\n    }\n    /**\n     * Draw an influence ball projectile\n     */\n    drawInfluenceBallProjectile(projectile) {\n        const screenPos = this.worldToScreen(projectile.position);\n        const size = 12 * this.zoom;\n        const color = this.getFactionColor(projectile.owner.faction);\n        // Draw glowing ball\n        const gradient = this.ctx.createRadialGradient(screenPos.x, screenPos.y, 0, screenPos.x, screenPos.y, size);\n        gradient.addColorStop(0, color);\n        gradient.addColorStop(0.5, `${color}AA`);\n        gradient.addColorStop(1, `${color}00`);\n        this.ctx.fillStyle = gradient;\n        this.ctx.beginPath();\n        this.ctx.arc(screenPos.x, screenPos.y, size, 0, Math.PI * 2);\n        this.ctx.fill();\n        // Draw inner core\n        this.ctx.fillStyle = '#FFFFFF';\n        this.ctx.beginPath();\n        this.ctx.arc(screenPos.x, screenPos.y, size * 0.3, 0, Math.PI * 2);\n        this.ctx.fill();\n    }\n    /**\n     * Draw a crescent wave from Tank hero ability\n     */\n    drawCrescentWave(wave) {\n        const screenPos = this.worldToScreen(wave.position);\n        const color = this.getFactionColor(wave.owner.faction);\n        this.ctx.save();\n        // Draw wave as an arc segment - match the collision detection size\n        const waveRadius = _constants__WEBPACK_IMPORTED_MODULE_1__.TANK_WAVE_WIDTH * this.zoom;\n        const halfAngle = _constants__WEBPACK_IMPORTED_MODULE_1__.TANK_WAVE_ANGLE / 2;\n        // Create gradient for wave glow\n        const gradient = this.ctx.createRadialGradient(screenPos.x, screenPos.y, 0, screenPos.x, screenPos.y, waveRadius * 1.5);\n        gradient.addColorStop(0, `${color}00`);\n        gradient.addColorStop(0.5, `${color}88`);\n        gradient.addColorStop(1, `${color}00`);\n        // Draw main wave arc\n        this.ctx.strokeStyle = color;\n        this.ctx.lineWidth = waveRadius * 0.5;\n        this.ctx.globalAlpha = 0.7;\n        this.ctx.beginPath();\n        this.ctx.arc(screenPos.x, screenPos.y, waveRadius, wave.angle - halfAngle, wave.angle + halfAngle);\n        this.ctx.stroke();\n        // Draw wave glow effect\n        this.ctx.fillStyle = gradient;\n        this.ctx.globalAlpha = 0.4;\n        this.ctx.beginPath();\n        this.ctx.moveTo(screenPos.x, screenPos.y);\n        this.ctx.arc(screenPos.x, screenPos.y, waveRadius * 1.5, wave.angle - halfAngle, wave.angle + halfAngle);\n        this.ctx.closePath();\n        this.ctx.fill();\n        // Draw energy particles along the wave front\n        const numParticles = 10;\n        for (let i = 0; i < numParticles; i++) {\n            const angle = wave.angle - halfAngle + (_constants__WEBPACK_IMPORTED_MODULE_1__.TANK_WAVE_ANGLE * i / numParticles);\n            const distance = waveRadius * (0.8 + Math.sin(wave.lifetime * 5 + i) * 0.2);\n            const particleX = screenPos.x + Math.cos(angle) * distance;\n            const particleY = screenPos.y + Math.sin(angle) * distance;\n            this.ctx.fillStyle = '#FFFFFF';\n            this.ctx.globalAlpha = 0.8;\n            this.ctx.beginPath();\n            this.ctx.arc(particleX, particleY, 3 * this.zoom, 0, Math.PI * 2);\n            this.ctx.fill();\n        }\n        this.ctx.restore();\n    }\n    /**\n     * Draw a deployed turret\n     */\n    drawDeployedTurret(turret) {\n        const screenPos = this.worldToScreen(turret.position);\n        const color = this.getFactionColor(turret.owner.faction);\n        // Sprite paths for the radiant cannon\n        const bottomSpritePath = 'ASSETS/sprites/RADIANT/structures/radiantCannon_bottom.png';\n        const topSpritePath = 'ASSETS/sprites/RADIANT/structures/radiantCannon_top_outline.png';\n        // Calculate sprite size based on zoom\n        const spriteScale = _constants__WEBPACK_IMPORTED_MODULE_1__.DEPLOYED_TURRET_SPRITE_SCALE * this.zoom;\n        // Load and draw bottom sprite (static base)\n        const bottomSprite = this.getTintedSprite(bottomSpritePath, color);\n        if (bottomSprite) {\n            const bottomWidth = bottomSprite.width * spriteScale;\n            const bottomHeight = bottomSprite.height * spriteScale;\n            this.ctx.save();\n            this.ctx.translate(screenPos.x, screenPos.y);\n            this.ctx.drawImage(bottomSprite, -bottomWidth / 2, -bottomHeight / 2, bottomWidth, bottomHeight);\n            this.ctx.restore();\n        }\n        // Calculate rotation angle to face target\n        let rotationAngle = 0;\n        if (turret.target) {\n            const dx = turret.target.position.x - turret.position.x;\n            const dy = turret.target.position.y - turret.position.y;\n            rotationAngle = Math.atan2(dy, dx);\n        }\n        // Select sprite based on firing state\n        let topSpriteToUse = null;\n        if (turret.isFiring) {\n            // Cycle through animation frames\n            const frameIndex = Math.floor(turret.firingAnimationProgress * _constants__WEBPACK_IMPORTED_MODULE_1__.DEPLOYED_TURRET_ANIMATION_FRAME_COUNT);\n            const clampedFrameIndex = Math.min(frameIndex, _constants__WEBPACK_IMPORTED_MODULE_1__.DEPLOYED_TURRET_ANIMATION_FRAME_COUNT - 1);\n            const animSpritePath = `ASSETS/sprites/RADIANT/structures/radiantCannonAnimation/radiantCannonFrame (${clampedFrameIndex + 1}).png`;\n            topSpriteToUse = this.getTintedSprite(animSpritePath, color);\n        }\n        else {\n            // Use default top sprite when not firing\n            topSpriteToUse = this.getTintedSprite(topSpritePath, color);\n        }\n        // Draw top sprite (rotating barrel)\n        if (topSpriteToUse) {\n            const topWidth = topSpriteToUse.width * spriteScale;\n            const topHeight = topSpriteToUse.height * spriteScale;\n            // Calculate pivot point: centered horizontally, DEPLOYED_TURRET_PIVOT_FROM_BOTTOM_PX from bottom\n            // Convert sprite pixels to normalized coordinates\n            const pivotRatio = (_constants__WEBPACK_IMPORTED_MODULE_1__.DEPLOYED_TURRET_SPRITE_HEIGHT_PX - _constants__WEBPACK_IMPORTED_MODULE_1__.DEPLOYED_TURRET_PIVOT_FROM_BOTTOM_PX) / _constants__WEBPACK_IMPORTED_MODULE_1__.DEPLOYED_TURRET_SPRITE_HEIGHT_PX;\n            const pivotOffsetY = pivotRatio * topHeight - topHeight / 2;\n            this.ctx.save();\n            this.ctx.translate(screenPos.x, screenPos.y);\n            this.ctx.rotate(rotationAngle + Math.PI / 2); // Add PI/2 because sprite top faces upward\n            this.ctx.translate(0, -pivotOffsetY); // Offset for pivot point\n            this.ctx.drawImage(topSpriteToUse, -topWidth / 2, -topHeight / 2, topWidth, topHeight);\n            this.ctx.restore();\n        }\n        // Draw health bar above the turret\n        const displaySize = _constants__WEBPACK_IMPORTED_MODULE_1__.DEPLOYED_TURRET_HEALTH_BAR_SIZE * this.zoom;\n        this.drawHealthDisplay(screenPos, turret.health, turret.maxHealth, displaySize, -displaySize - 10);\n    }\n    /**\n     * Draw a Grave unit with its orbiting projectiles\n     */\n    drawGrave(grave, color, game, isEnemy) {\n        // Check visibility for enemy units\n        let shouldDim = false;\n        let displayColor = color;\n        if (isEnemy && this.viewingPlayer) {\n            const isVisible = game.isObjectVisibleToPlayer(grave.position, this.viewingPlayer);\n            if (!isVisible) {\n                return; // Don't draw invisible enemy units\n            }\n            // Check if in shadow for dimming effect - darken color instead of using alpha\n            const inShadow = game.isPointInShadow(grave.position);\n            if (inShadow) {\n                shouldDim = true;\n                displayColor = this.darkenColor(color, _constants__WEBPACK_IMPORTED_MODULE_1__.SHADE_OPACITY);\n            }\n        }\n        // Draw the base unit\n        this.drawUnit(grave, displayColor, game, isEnemy);\n        // Draw a distinctive grave symbol\n        const screenPos = this.worldToScreen(grave.position);\n        const size = 10 * this.zoom;\n        // Draw cross symbol - darken if needed\n        this.ctx.strokeStyle = shouldDim ? this.darkenColor('#FFFFFF', _constants__WEBPACK_IMPORTED_MODULE_1__.SHADE_OPACITY) : '#FFFFFF';\n        this.ctx.lineWidth = 2 * this.zoom;\n        this.ctx.beginPath();\n        this.ctx.moveTo(screenPos.x, screenPos.y - size);\n        this.ctx.lineTo(screenPos.x, screenPos.y + size);\n        this.ctx.moveTo(screenPos.x - size * 0.7, screenPos.y - size * 0.3);\n        this.ctx.lineTo(screenPos.x + size * 0.7, screenPos.y - size * 0.3);\n        this.ctx.stroke();\n        // Draw projectiles\n        for (const projectile of grave.getProjectiles()) {\n            this.drawGraveProjectile(projectile, displayColor);\n        }\n    }\n    /**\n     * Draw merged attack range outlines for selected starlings\n     * Shows the combined outline instead of individual circles\n     */\n    drawMergedStarlingRanges(game) {\n        // Collect all selected friendly starlings\n        const selectedStarlings = [];\n        for (const unit of this.selectedUnits) {\n            if (unit instanceof _game_core__WEBPACK_IMPORTED_MODULE_0__.Starling && this.viewingPlayer && unit.owner === this.viewingPlayer) {\n                selectedStarlings.push(unit);\n            }\n        }\n        if (selectedStarlings.length === 0) {\n            return;\n        }\n        const color = this.getFactionColor(this.viewingPlayer.faction);\n        // For merged ranges, we draw the outline of all overlapping circles\n        // Using a simplified approach: draw arc segments that are on the outer boundary\n        this.ctx.strokeStyle = color;\n        this.ctx.lineWidth = 1;\n        this.ctx.globalAlpha = _constants__WEBPACK_IMPORTED_MODULE_1__.HERO_ATTACK_RANGE_ALPHA;\n        this.ctx.beginPath();\n        for (let i = 0; i < selectedStarlings.length; i++) {\n            const starling = selectedStarlings[i];\n            const screenPos = this.worldToScreen(starling.position);\n            const radius = starling.attackRange * this.zoom;\n            // Draw arc segments that don't overlap with other starlings\n            const angleStep = Math.PI / 32; // Sample 64 points around circle\n            let pathStarted = false;\n            for (let angle = 0; angle < Math.PI * 2; angle += angleStep) {\n                const px = starling.position.x + Math.cos(angle) * starling.attackRange;\n                const py = starling.position.y + Math.sin(angle) * starling.attackRange;\n                // Check if this point is outside all other starling ranges\n                let isOuterPoint = true;\n                for (let j = 0; j < selectedStarlings.length; j++) {\n                    if (i === j)\n                        continue;\n                    const other = selectedStarlings[j];\n                    const dx = px - other.position.x;\n                    const dy = py - other.position.y;\n                    const distSq = dx * dx + dy * dy;\n                    const otherRadiusSq = other.attackRange * other.attackRange;\n                    if (distSq < otherRadiusSq) {\n                        isOuterPoint = false;\n                        break;\n                    }\n                }\n                const screenX = this.worldToScreen({ x: px, y: py }).x;\n                const screenY = this.worldToScreen({ x: px, y: py }).y;\n                if (isOuterPoint) {\n                    if (!pathStarted) {\n                        this.ctx.moveTo(screenX, screenY);\n                        pathStarted = true;\n                    }\n                    else {\n                        this.ctx.lineTo(screenX, screenY);\n                    }\n                }\n                else {\n                    pathStarted = false;\n                }\n            }\n        }\n        this.ctx.stroke();\n        this.ctx.globalAlpha = 1.0;\n    }\n    /**\n     * Draw a Starling unit (minion from stellar forge)\n     */\n    drawStarling(starling, color, game, isEnemy) {\n        const screenPos = this.worldToScreen(starling.position);\n        const size = 8 * this.zoom * 0.3; // Minion size (30% of normal unit)\n        const isSelected = this.selectedUnits.has(starling);\n        // Check visibility for enemy units\n        let shouldDim = false;\n        let displayColor = color;\n        if (isEnemy && this.viewingPlayer) {\n            const isVisible = game.isObjectVisibleToPlayer(starling.position, this.viewingPlayer);\n            if (!isVisible) {\n                return; // Don't draw invisible enemy units\n            }\n            // Check if in shadow for dimming effect - darken color instead of using alpha\n            const inShadow = game.isPointInShadow(starling.position);\n            if (inShadow) {\n                shouldDim = true;\n                displayColor = this.darkenColor(color, _constants__WEBPACK_IMPORTED_MODULE_1__.SHADE_OPACITY);\n            }\n        }\n        // Note: Range circles for starlings are drawn separately as merged outlines\n        // in drawMergedStarlingRanges() before individual starlings are rendered\n        // Get starling sprite and color it with player color\n        const starlingSpritePath = this.getStarlingSpritePath(starling);\n        const tintColor = shouldDim\n            ? this.darkenColor(isEnemy ? this.enemyColor : this.playerColor, _constants__WEBPACK_IMPORTED_MODULE_1__.SHADE_OPACITY)\n            : (isEnemy ? this.enemyColor : this.playerColor);\n        // Use outlined sprite for selected starlings, regular tinted sprite otherwise\n        const starlingSprite = starlingSpritePath\n            ? (isSelected && !isEnemy ? this.getOutlinedTintedSprite(starlingSpritePath, tintColor) : this.getTintedSprite(starlingSpritePath, tintColor))\n            : null;\n        if (starlingSprite) {\n            const spriteSize = size * _constants__WEBPACK_IMPORTED_MODULE_1__.STARLING_SPRITE_SCALE_FACTOR;\n            const rotationRad = this.getStarlingFacingRotationRad(starling);\n            if (rotationRad !== null) {\n                this.ctx.save();\n                this.ctx.translate(screenPos.x, screenPos.y);\n                this.ctx.rotate(rotationRad);\n                this.ctx.drawImage(starlingSprite, -spriteSize / 2, -spriteSize / 2, spriteSize, spriteSize);\n                this.ctx.restore();\n            }\n            else {\n                this.ctx.drawImage(starlingSprite, screenPos.x - spriteSize / 2, screenPos.y - spriteSize / 2, spriteSize, spriteSize);\n            }\n        }\n        else {\n            // Fallback to circle rendering if sprite not loaded\n            this.ctx.fillStyle = displayColor;\n            this.ctx.strokeStyle = isSelected ? '#FFFFFF' : (shouldDim ? this.darkenColor('#FFFFFF', _constants__WEBPACK_IMPORTED_MODULE_1__.SHADE_OPACITY) : '#FFFFFF');\n            this.ctx.lineWidth = isSelected ? 3 : 1;\n            this.ctx.beginPath();\n            this.ctx.arc(screenPos.x, screenPos.y, size, 0, Math.PI * 2);\n            this.ctx.fill();\n            this.ctx.stroke();\n        }\n        // Draw health bar/number if damaged\n        this.drawHealthDisplay(screenPos, starling.health, starling.maxHealth, size, -size * 6 - 10);\n        // Note: Move order lines for starlings are drawn separately in drawStarlingMoveLines()\n        // to show only a single line from the closest starling when multiple are selected\n    }\n    /**\n     * Draw move order lines for selected starlings\n     * Shows a single line from the closest starling to the destination when multiple are selected\n     */\n    drawStarlingMoveLines(game) {\n        if (!this.viewingPlayer)\n            return;\n        // Group selected starlings by their rally point (using string key for proper Map comparison)\n        const starlingsByRallyPoint = new Map();\n        for (const unit of this.selectedUnits) {\n            if (unit instanceof _game_core__WEBPACK_IMPORTED_MODULE_0__.Starling && unit.owner === this.viewingPlayer && unit.rallyPoint && unit.moveOrder > 0) {\n                const key = `${unit.rallyPoint.x},${unit.rallyPoint.y}`;\n                if (!starlingsByRallyPoint.has(key)) {\n                    starlingsByRallyPoint.set(key, { rallyPoint: unit.rallyPoint, starlings: [] });\n                }\n                starlingsByRallyPoint.get(key).starlings.push(unit);\n            }\n        }\n        const color = this.getFactionColor(this.viewingPlayer.faction);\n        // For each rally point, draw a single line from the closest starling\n        for (const [key, group] of starlingsByRallyPoint) {\n            if (group.starlings.length === 0)\n                continue;\n            // Find the closest starling to the rally point\n            let closestStarling = group.starlings[0];\n            let minDistSq = Infinity;\n            for (const starling of group.starlings) {\n                const dx = group.rallyPoint.x - starling.position.x;\n                const dy = group.rallyPoint.y - starling.position.y;\n                const distSq = dx * dx + dy * dy;\n                if (distSq < minDistSq) {\n                    minDistSq = distSq;\n                    closestStarling = starling;\n                }\n            }\n            // Draw move order indicator from the closest starling only\n            this.drawMoveOrderIndicator(closestStarling.position, group.rallyPoint, closestStarling.moveOrder, color);\n        }\n    }\n    /**\n     * Draw a Ray unit (Solari hero)\n     */\n    drawRay(ray, color, game, isEnemy) {\n        // Check visibility for enemy units\n        let shouldDim = false;\n        let displayColor = color;\n        if (isEnemy && this.viewingPlayer) {\n            const isVisible = game.isObjectVisibleToPlayer(ray.position, this.viewingPlayer);\n            if (!isVisible) {\n                return; // Don't draw invisible enemy units\n            }\n            const inShadow = game.isPointInShadow(ray.position);\n            if (inShadow) {\n                shouldDim = true;\n                displayColor = this.darkenColor(color, _constants__WEBPACK_IMPORTED_MODULE_1__.SHADE_OPACITY);\n            }\n        }\n        // Draw base unit\n        this.drawUnit(ray, displayColor, game, isEnemy);\n        // Draw Ray symbol (lightning bolt)\n        const screenPos = this.worldToScreen(ray.position);\n        const size = 10 * this.zoom;\n        this.ctx.strokeStyle = displayColor;\n        this.ctx.lineWidth = 2 * this.zoom;\n        this.ctx.beginPath();\n        this.ctx.moveTo(screenPos.x, screenPos.y - size);\n        this.ctx.lineTo(screenPos.x - size * 0.3, screenPos.y);\n        this.ctx.lineTo(screenPos.x + size * 0.3, screenPos.y);\n        this.ctx.lineTo(screenPos.x, screenPos.y + size);\n        this.ctx.stroke();\n        // Draw beam segments\n        const beamSegments = ray.getBeamSegments();\n        for (const segment of beamSegments) {\n            const startScreen = this.worldToScreen(segment.startPos);\n            const endScreen = this.worldToScreen(segment.endPos);\n            const opacity = 1.0 - (segment.lifetime / segment.maxLifetime);\n            this.ctx.strokeStyle = displayColor;\n            this.ctx.globalAlpha = opacity;\n            this.ctx.lineWidth = _constants__WEBPACK_IMPORTED_MODULE_1__.RAY_BEAM_WIDTH * this.zoom;\n            this.ctx.beginPath();\n            this.ctx.moveTo(startScreen.x, startScreen.y);\n            this.ctx.lineTo(endScreen.x, endScreen.y);\n            this.ctx.stroke();\n        }\n        this.ctx.globalAlpha = 1.0;\n    }\n    /**\n     * Draw an InfluenceBall unit (Solari hero)\n     */\n    drawInfluenceBall(ball, color, game, isEnemy) {\n        // Check visibility for enemy units\n        let shouldDim = false;\n        let displayColor = color;\n        if (isEnemy && this.viewingPlayer) {\n            const isVisible = game.isObjectVisibleToPlayer(ball.position, this.viewingPlayer);\n            if (!isVisible) {\n                return;\n            }\n            const inShadow = game.isPointInShadow(ball.position);\n            if (inShadow) {\n                shouldDim = true;\n                displayColor = this.darkenColor(color, _constants__WEBPACK_IMPORTED_MODULE_1__.SHADE_OPACITY);\n            }\n        }\n        // Draw base unit\n        this.drawUnit(ball, displayColor, game, isEnemy);\n        // Draw sphere symbol\n        const screenPos = this.worldToScreen(ball.position);\n        const size = 12 * this.zoom;\n        this.ctx.strokeStyle = displayColor;\n        this.ctx.lineWidth = 2 * this.zoom;\n        this.ctx.beginPath();\n        this.ctx.arc(screenPos.x, screenPos.y, size, 0, Math.PI * 2);\n        this.ctx.stroke();\n        this.ctx.beginPath();\n        this.ctx.arc(screenPos.x, screenPos.y, size * 0.6, 0, Math.PI * 2);\n        this.ctx.stroke();\n    }\n    /**\n     * Draw a TurretDeployer unit (Solari hero)\n     */\n    drawTurretDeployer(deployer, color, game, isEnemy) {\n        // Check visibility for enemy units\n        let shouldDim = false;\n        let displayColor = color;\n        if (isEnemy && this.viewingPlayer) {\n            const isVisible = game.isObjectVisibleToPlayer(deployer.position, this.viewingPlayer);\n            if (!isVisible) {\n                return;\n            }\n            const inShadow = game.isPointInShadow(deployer.position);\n            if (inShadow) {\n                shouldDim = true;\n                displayColor = this.darkenColor(color, _constants__WEBPACK_IMPORTED_MODULE_1__.SHADE_OPACITY);\n            }\n        }\n        // Draw base unit\n        this.drawUnit(deployer, displayColor, game, isEnemy);\n        // Draw turret symbol\n        const screenPos = this.worldToScreen(deployer.position);\n        const size = 10 * this.zoom;\n        this.ctx.fillStyle = displayColor;\n        this.ctx.fillRect(screenPos.x - size * 0.5, screenPos.y - size * 0.3, size, size * 0.6);\n        this.ctx.fillRect(screenPos.x - size * 0.2, screenPos.y - size, size * 0.4, size);\n    }\n    /**\n     * Draw a Driller unit (Aurum hero)\n     */\n    drawDriller(driller, color, game, isEnemy) {\n        // Don't draw if hidden in asteroid\n        if (driller.isHiddenInAsteroid()) {\n            return;\n        }\n        // Check visibility for enemy units\n        let shouldDim = false;\n        let displayColor = color;\n        if (isEnemy && this.viewingPlayer) {\n            const isVisible = game.isObjectVisibleToPlayer(driller.position, this.viewingPlayer);\n            if (!isVisible) {\n                return;\n            }\n            const inShadow = game.isPointInShadow(driller.position);\n            if (inShadow) {\n                shouldDim = true;\n                displayColor = this.darkenColor(color, _constants__WEBPACK_IMPORTED_MODULE_1__.SHADE_OPACITY);\n            }\n        }\n        // Draw base unit\n        this.drawUnit(driller, displayColor, game, isEnemy);\n        // Draw drill symbol\n        const screenPos = this.worldToScreen(driller.position);\n        const size = 10 * this.zoom;\n        this.ctx.strokeStyle = displayColor;\n        this.ctx.lineWidth = 2 * this.zoom;\n        // Draw drill bit\n        this.ctx.beginPath();\n        this.ctx.moveTo(screenPos.x - size, screenPos.y);\n        this.ctx.lineTo(screenPos.x, screenPos.y - size * 0.5);\n        this.ctx.lineTo(screenPos.x + size, screenPos.y);\n        this.ctx.lineTo(screenPos.x, screenPos.y + size * 0.5);\n        this.ctx.closePath();\n        this.ctx.stroke();\n    }\n    /**\n     * Draw a Dagger hero unit with cloak indicator\n     */\n    drawDagger(dagger, color, game, isEnemy) {\n        // Check visibility for enemy units\n        let shouldDim = false;\n        let displayColor = color;\n        if (isEnemy && this.viewingPlayer) {\n            const isVisible = game.isObjectVisibleToPlayer(dagger.position, this.viewingPlayer, dagger);\n            if (!isVisible) {\n                return; // Cloaked Dagger is invisible to enemies\n            }\n            const inShadow = game.isPointInShadow(dagger.position);\n            if (inShadow) {\n                shouldDim = true;\n                displayColor = this.darkenColor(color, _constants__WEBPACK_IMPORTED_MODULE_1__.SHADE_OPACITY);\n            }\n        }\n        // For friendly units, apply cloak opacity when cloaked\n        let isCloakedFriendly = false;\n        if (!isEnemy && dagger.isCloakedToEnemies()) {\n            isCloakedFriendly = true;\n            this.ctx.globalAlpha = _constants__WEBPACK_IMPORTED_MODULE_1__.DAGGER_CLOAK_OPACITY;\n        }\n        // Draw base unit\n        this.drawUnit(dagger, isCloakedFriendly ? color : displayColor, game, isEnemy);\n        // Draw cloak indicator (ghostly outline)\n        if (isCloakedFriendly) {\n            const screenPos = this.worldToScreen(dagger.position);\n            const size = 8 * this.zoom;\n            this.ctx.strokeStyle = color;\n            this.ctx.lineWidth = 1.5 * this.zoom;\n            this.ctx.setLineDash([3 * this.zoom, 3 * this.zoom]); // Dashed line for cloak effect\n            // Draw outer circle for cloak\n            this.ctx.beginPath();\n            this.ctx.arc(screenPos.x, screenPos.y, size + 6, 0, Math.PI * 2);\n            this.ctx.stroke();\n            this.ctx.setLineDash([]); // Reset line dash\n        }\n        // Draw ability indicator when visible (not cloaked)\n        if (!dagger.isCloakedToEnemies() && !isEnemy) {\n            const screenPos = this.worldToScreen(dagger.position);\n            const size = 8 * this.zoom;\n            // Draw strike symbol (like a blade)\n            this.ctx.strokeStyle = shouldDim ? this.darkenColor('#FF6600', _constants__WEBPACK_IMPORTED_MODULE_1__.SHADE_OPACITY) : '#FF6600'; // Orange for strike\n            this.ctx.lineWidth = 2 * this.zoom;\n            this.ctx.beginPath();\n            this.ctx.moveTo(screenPos.x - size * 0.7, screenPos.y - size * 0.7);\n            this.ctx.lineTo(screenPos.x + size * 0.7, screenPos.y + size * 0.7);\n            this.ctx.stroke();\n        }\n        // Reset alpha\n        if (isCloakedFriendly) {\n            this.ctx.globalAlpha = 1.0;\n        }\n    }\n    /**\n     * Draw a Beam hero unit with sniper indicator\n     */\n    drawBeam(beam, color, game, isEnemy) {\n        // Check visibility for enemy units\n        let shouldDim = false;\n        let displayColor = color;\n        if (isEnemy && this.viewingPlayer) {\n            const isVisible = game.isObjectVisibleToPlayer(beam.position, this.viewingPlayer, beam);\n            if (!isVisible) {\n                return; // Don't draw invisible enemy units\n            }\n            const inShadow = game.isPointInShadow(beam.position);\n            if (inShadow) {\n                shouldDim = true;\n                displayColor = this.darkenColor(color, _constants__WEBPACK_IMPORTED_MODULE_1__.SHADE_OPACITY);\n            }\n        }\n        // Draw base unit\n        this.drawUnit(beam, displayColor, game, isEnemy);\n        // Draw crosshair/sniper scope indicator for friendly units\n        if (!isEnemy) {\n            const screenPos = this.worldToScreen(beam.position);\n            const size = 10 * this.zoom;\n            this.ctx.strokeStyle = shouldDim ? this.darkenColor('#FF0000', _constants__WEBPACK_IMPORTED_MODULE_1__.SHADE_OPACITY) : '#FF0000'; // Red for sniper\n            this.ctx.lineWidth = 1.5 * this.zoom;\n            // Draw crosshair\n            this.ctx.beginPath();\n            // Horizontal line\n            this.ctx.moveTo(screenPos.x - size, screenPos.y);\n            this.ctx.lineTo(screenPos.x + size, screenPos.y);\n            // Vertical line\n            this.ctx.moveTo(screenPos.x, screenPos.y - size);\n            this.ctx.lineTo(screenPos.x, screenPos.y + size);\n            this.ctx.stroke();\n            // Draw small circle in center\n            this.ctx.beginPath();\n            this.ctx.arc(screenPos.x, screenPos.y, size * 0.3, 0, Math.PI * 2);\n            this.ctx.stroke();\n        }\n        // Display damage multiplier if recently fired (show for 2 seconds)\n        if (game.gameTime - beam.lastBeamTime < 2.0 && beam.lastBeamMultiplier > 0) {\n            const screenPos = this.worldToScreen(beam.position);\n            const yOffset = -20 * this.zoom;\n            // Format multiplier: e.g., \"(30x5.5)\"\n            const baseDamage = _constants__WEBPACK_IMPORTED_MODULE_1__.BEAM_ABILITY_BASE_DAMAGE;\n            const multiplierText = `(${baseDamage}x${beam.lastBeamMultiplier.toFixed(1)})`;\n            // Small font for the multiplier\n            const fontSize = 10 * this.zoom;\n            this.ctx.font = `${fontSize}px Doto`;\n            this.ctx.fillStyle = '#FFAA00'; // Orange/yellow\n            this.ctx.textAlign = 'center';\n            this.ctx.textBaseline = 'bottom';\n            // Draw with slight fade based on time\n            const age = game.gameTime - beam.lastBeamTime;\n            const opacity = Math.max(0, 1 - age / 2.0);\n            this.ctx.globalAlpha = opacity;\n            // Add stroke for readability\n            this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';\n            this.ctx.lineWidth = 2;\n            this.ctx.strokeText(multiplierText, screenPos.x, screenPos.y + yOffset);\n            this.ctx.fillText(multiplierText, screenPos.x, screenPos.y + yOffset);\n            this.ctx.globalAlpha = 1.0;\n        }\n    }\n    /**\n     * Draw a Mortar hero unit with detection cone visualization\n     */\n    drawMortar(mortar, color, game, isEnemy) {\n        // Check visibility for enemy units\n        let shouldDim = false;\n        let displayColor = color;\n        if (isEnemy && this.viewingPlayer) {\n            const isVisible = game.isObjectVisibleToPlayer(mortar.position, this.viewingPlayer, mortar);\n            if (!isVisible) {\n                return; // Don't draw invisible enemy units\n            }\n            const inShadow = game.isPointInShadow(mortar.position);\n            if (inShadow) {\n                shouldDim = true;\n                displayColor = this.darkenColor(color, _constants__WEBPACK_IMPORTED_MODULE_1__.SHADE_OPACITY);\n            }\n        }\n        // Draw detection cone if set up and not enemy\n        if (!isEnemy && mortar.isSetup && mortar.facingDirection) {\n            const screenPos = this.worldToScreen(mortar.position);\n            const facingAngle = Math.atan2(mortar.facingDirection.y, mortar.facingDirection.x);\n            const halfConeAngle = _constants__WEBPACK_IMPORTED_MODULE_1__.MORTAR_DETECTION_CONE_ANGLE / 2;\n            const coneRadius = _constants__WEBPACK_IMPORTED_MODULE_1__.MORTAR_ATTACK_RANGE * this.zoom;\n            // Draw detection cone\n            this.ctx.fillStyle = shouldDim ? this.darkenColor(color, _constants__WEBPACK_IMPORTED_MODULE_1__.SHADE_OPACITY * 0.5) : color;\n            this.ctx.globalAlpha = 0.15;\n            this.ctx.beginPath();\n            this.ctx.moveTo(screenPos.x, screenPos.y);\n            this.ctx.arc(screenPos.x, screenPos.y, coneRadius, facingAngle - halfConeAngle, facingAngle + halfConeAngle);\n            this.ctx.closePath();\n            this.ctx.fill();\n            this.ctx.globalAlpha = 1.0;\n            // Draw cone outline\n            this.ctx.strokeStyle = shouldDim ? this.darkenColor(color, _constants__WEBPACK_IMPORTED_MODULE_1__.SHADE_OPACITY) : color;\n            this.ctx.lineWidth = 2 * this.zoom;\n            this.ctx.globalAlpha = 0.5;\n            this.ctx.beginPath();\n            this.ctx.moveTo(screenPos.x, screenPos.y);\n            this.ctx.arc(screenPos.x, screenPos.y, coneRadius, facingAngle - halfConeAngle, facingAngle + halfConeAngle);\n            this.ctx.lineTo(screenPos.x, screenPos.y);\n            this.ctx.stroke();\n            this.ctx.globalAlpha = 1.0;\n        }\n        // Draw base unit\n        this.drawUnit(mortar, displayColor, game, isEnemy);\n        // Draw setup indicator - show artillery barrel/turret for friendly units\n        if (!isEnemy && mortar.isSetup && mortar.facingDirection) {\n            const screenPos = this.worldToScreen(mortar.position);\n            const facingAngle = Math.atan2(mortar.facingDirection.y, mortar.facingDirection.x);\n            const barrelLength = 15 * this.zoom;\n            // Draw barrel\n            this.ctx.strokeStyle = shouldDim ? this.darkenColor('#888888', _constants__WEBPACK_IMPORTED_MODULE_1__.SHADE_OPACITY) : '#888888';\n            this.ctx.lineWidth = 4 * this.zoom;\n            this.ctx.beginPath();\n            this.ctx.moveTo(screenPos.x, screenPos.y);\n            this.ctx.lineTo(screenPos.x + Math.cos(facingAngle) * barrelLength, screenPos.y + Math.sin(facingAngle) * barrelLength);\n            this.ctx.stroke();\n        }\n        else if (!isEnemy && !mortar.isSetup) {\n            // Show \"not set up\" indicator\n            const screenPos = this.worldToScreen(mortar.position);\n            const size = 12 * this.zoom;\n            this.ctx.strokeStyle = shouldDim ? this.darkenColor('#FFAA00', _constants__WEBPACK_IMPORTED_MODULE_1__.SHADE_OPACITY) : '#FFAA00'; // Orange\n            this.ctx.lineWidth = 2 * this.zoom;\n            this.ctx.globalAlpha = 0.7;\n            // Draw exclamation mark\n            this.ctx.beginPath();\n            // Vertical line\n            this.ctx.moveTo(screenPos.x, screenPos.y - size);\n            this.ctx.lineTo(screenPos.x, screenPos.y - size * 0.3);\n            this.ctx.stroke();\n            // Dot\n            this.ctx.beginPath();\n            this.ctx.arc(screenPos.x, screenPos.y - size * 0.1, 1.5 * this.zoom, 0, Math.PI * 2);\n            this.ctx.fill();\n            this.ctx.globalAlpha = 1.0;\n        }\n    }\n    drawPreist(preist, color, game, isEnemy) {\n        // Draw base unit\n        this.drawUnit(preist, color, game, isEnemy);\n        // Don't draw healing beams for enemy units (unless you can see them)\n        if (isEnemy) {\n            return;\n        }\n        // Draw healing beams to targets\n        const beamTargets = preist.getHealingBeamTargets();\n        const screenPos = this.worldToScreen(preist.position);\n        this.ctx.save();\n        for (const target of beamTargets) {\n            if (!target)\n                continue;\n            const targetScreenPos = this.worldToScreen(target.position);\n            // Draw healing beam as a pulsing green line\n            this.ctx.strokeStyle = '#00FF88';\n            this.ctx.lineWidth = 3 * this.zoom;\n            this.ctx.globalAlpha = 0.6 + 0.2 * Math.sin(game.gameTime * 5);\n            this.ctx.beginPath();\n            this.ctx.moveTo(screenPos.x, screenPos.y);\n            this.ctx.lineTo(targetScreenPos.x, targetScreenPos.y);\n            this.ctx.stroke();\n            // Draw particles along the beam\n            const numParticles = 5;\n            for (let i = 0; i < numParticles; i++) {\n                const t = (i / numParticles + game.gameTime * 0.5) % 1.0;\n                const particleX = screenPos.x + (targetScreenPos.x - screenPos.x) * t;\n                const particleY = screenPos.y + (targetScreenPos.y - screenPos.y) * t;\n                this.ctx.fillStyle = '#00FF88';\n                this.ctx.globalAlpha = 0.8;\n                this.ctx.beginPath();\n                this.ctx.arc(particleX, particleY, 2 * this.zoom, 0, Math.PI * 2);\n                this.ctx.fill();\n            }\n        }\n        // Draw healing bomb particles\n        const particles = preist.getHealingBombParticles();\n        for (const particle of particles) {\n            const particleScreenPos = this.worldToScreen(particle.position);\n            // Draw particle as a glowing green dot\n            this.ctx.fillStyle = '#00FF88';\n            this.ctx.globalAlpha = 0.8 * (1 - particle.lifetime / particle.maxLifetime);\n            this.ctx.beginPath();\n            this.ctx.arc(particleScreenPos.x, particleScreenPos.y, 3 * this.zoom, 0, Math.PI * 2);\n            this.ctx.fill();\n            // Draw glow\n            const gradient = this.ctx.createRadialGradient(particleScreenPos.x, particleScreenPos.y, 0, particleScreenPos.x, particleScreenPos.y, 8 * this.zoom);\n            gradient.addColorStop(0, 'rgba(0, 255, 136, 0.4)');\n            gradient.addColorStop(1, 'rgba(0, 255, 136, 0)');\n            this.ctx.fillStyle = gradient;\n            this.ctx.globalAlpha = 0.6 * (1 - particle.lifetime / particle.maxLifetime);\n            this.ctx.beginPath();\n            this.ctx.arc(particleScreenPos.x, particleScreenPos.y, 8 * this.zoom, 0, Math.PI * 2);\n            this.ctx.fill();\n        }\n        this.ctx.restore();\n    }\n    drawTank(tank, color, game, isEnemy) {\n        // Draw base unit (includes health bar and stun indicator)\n        this.drawUnit(tank, color, game, isEnemy);\n        const screenPos = this.worldToScreen(tank.position);\n        // Draw shield around tank\n        this.ctx.save();\n        // Shield visual - pulsing circular shield\n        const shieldRadius = _constants__WEBPACK_IMPORTED_MODULE_1__.TANK_SHIELD_RADIUS * this.zoom;\n        const pulseAlpha = 0.2 + 0.1 * Math.sin(game.gameTime * 3);\n        // Shield outer circle\n        this.ctx.strokeStyle = color;\n        this.ctx.lineWidth = 2 * this.zoom;\n        this.ctx.globalAlpha = pulseAlpha;\n        this.ctx.beginPath();\n        this.ctx.arc(screenPos.x, screenPos.y, shieldRadius, 0, Math.PI * 2);\n        this.ctx.stroke();\n        // Shield inner glow\n        const gradient = this.ctx.createRadialGradient(screenPos.x, screenPos.y, 0, screenPos.x, screenPos.y, shieldRadius);\n        gradient.addColorStop(0, 'rgba(100, 150, 255, 0)');\n        gradient.addColorStop(0.7, `rgba(100, 150, 255, ${pulseAlpha * 0.3})`);\n        gradient.addColorStop(1, 'rgba(100, 150, 255, 0)');\n        this.ctx.fillStyle = gradient;\n        this.ctx.globalAlpha = 1.0;\n        this.ctx.beginPath();\n        this.ctx.arc(screenPos.x, screenPos.y, shieldRadius, 0, Math.PI * 2);\n        this.ctx.fill();\n        this.ctx.restore();\n    }\n    /**\n     * Draw a Cannon building\n     */\n    drawMinigun(building, color, game, isEnemy) {\n        const screenPos = this.worldToScreen(building.position);\n        const radius = building.radius * this.zoom;\n        // Check visibility for enemy buildings\n        let shouldDim = false;\n        let displayColor = color;\n        if (isEnemy && this.viewingPlayer) {\n            const isVisible = game.isObjectVisibleToPlayer(building.position, this.viewingPlayer);\n            if (!isVisible) {\n                return; // Don't draw invisible enemy buildings\n            }\n            // Check if in shadow for dimming effect - darken color instead of using alpha\n            const inShadow = game.isPointInShadow(building.position);\n            if (inShadow) {\n                shouldDim = true;\n                displayColor = this.darkenColor(color, _constants__WEBPACK_IMPORTED_MODULE_1__.SHADE_OPACITY);\n            }\n        }\n        // Draw build progress indicator if not complete\n        if (!building.isComplete) {\n            this.ctx.fillStyle = 'rgba(0, 255, 255, 0.2)';\n            this.ctx.strokeStyle = '#00FFFF';\n            this.ctx.lineWidth = 2;\n            this.ctx.beginPath();\n            this.ctx.arc(screenPos.x, screenPos.y, radius, 0, Math.PI * 2);\n            this.ctx.fill();\n            this.ctx.stroke();\n            // Draw progress bar\n            const barWidth = radius * 2;\n            const barHeight = 4;\n            const barX = screenPos.x - barWidth / 2;\n            const barY = screenPos.y + radius + 5;\n            this.ctx.fillStyle = '#333333';\n            this.ctx.fillRect(barX, barY, barWidth, barHeight);\n            this.ctx.fillStyle = '#00FF00';\n            this.ctx.fillRect(barX, barY, barWidth * building.buildProgress, barHeight);\n            // Reset alpha\n            if (shouldDim) {\n                this.ctx.globalAlpha = 1.0;\n            }\n            return;\n        }\n        const bottomSpritePath = 'ASSETS/sprites/RADIANT/structures/radiantCannon_bottom.png';\n        const topSpritePath = 'ASSETS/sprites/RADIANT/structures/radiantCannon_top_outline.png';\n        const bottomSprite = this.getTintedSprite(bottomSpritePath, displayColor);\n        const topSprite = this.getTintedSprite(topSpritePath, displayColor);\n        if (bottomSprite && topSprite) {\n            const spriteScale = (radius * 2) / bottomSprite.width;\n            const bottomWidth = bottomSprite.width * spriteScale;\n            const bottomHeight = bottomSprite.height * spriteScale;\n            this.ctx.save();\n            this.ctx.translate(screenPos.x, screenPos.y);\n            this.ctx.drawImage(bottomSprite, -bottomWidth / 2, -bottomHeight / 2, bottomWidth, bottomHeight);\n            this.ctx.restore();\n            // Draw selection indicator if selected\n            if (building.isSelected) {\n                this.drawBuildingSelectionIndicator(screenPos, radius);\n            }\n            let gunAngle = 0;\n            if (building.target) {\n                const dx = building.target.position.x - building.position.x;\n                const dy = building.target.position.y - building.position.y;\n                gunAngle = Math.atan2(dy, dx);\n            }\n            const topWidth = topSprite.width * spriteScale;\n            const topHeight = topSprite.height * spriteScale;\n            const pivotOffsetFromBottomPx = _constants__WEBPACK_IMPORTED_MODULE_1__.DEPLOYED_TURRET_PIVOT_FROM_BOTTOM_PX * spriteScale;\n            const pivotY = topHeight / 2 - pivotOffsetFromBottomPx;\n            this.ctx.save();\n            this.ctx.translate(screenPos.x, screenPos.y);\n            this.ctx.rotate(gunAngle);\n            this.ctx.drawImage(topSprite, -topWidth / 2, -pivotY, topWidth, topHeight);\n            this.ctx.restore();\n        }\n        else {\n            // Draw base (circular platform)\n            this.ctx.fillStyle = displayColor;\n            this.ctx.strokeStyle = shouldDim ? this.darkenColor('#FFFFFF', _constants__WEBPACK_IMPORTED_MODULE_1__.SHADE_OPACITY) : '#FFFFFF';\n            this.ctx.lineWidth = 2;\n            this.ctx.beginPath();\n            this.ctx.arc(screenPos.x, screenPos.y, radius, 0, Math.PI * 2);\n            this.ctx.fill();\n            this.ctx.stroke();\n            // Draw selection indicator if selected\n            if (building.isSelected) {\n                this.drawBuildingSelectionIndicator(screenPos, radius);\n            }\n            // Draw turret base (smaller circle in center)\n            const turretBaseRadius = radius * 0.6;\n            this.ctx.fillStyle = shouldDim ? this.darkenColor('#666666', _constants__WEBPACK_IMPORTED_MODULE_1__.SHADE_OPACITY) : '#666666';\n            this.ctx.beginPath();\n            this.ctx.arc(screenPos.x, screenPos.y, turretBaseRadius, 0, Math.PI * 2);\n            this.ctx.fill();\n            // Draw minigun barrel (pointing toward target if exists)\n            let gunAngle = 0;\n            if (building.target) {\n                const dx = building.target.position.x - building.position.x;\n                const dy = building.target.position.y - building.position.y;\n                gunAngle = Math.atan2(dy, dx);\n            }\n            const barrelLength = radius * 1.2;\n            const barrelWidth = 4 * this.zoom;\n            this.ctx.strokeStyle = shouldDim ? this.darkenColor('#333333', _constants__WEBPACK_IMPORTED_MODULE_1__.SHADE_OPACITY) : '#333333';\n            this.ctx.lineWidth = barrelWidth;\n            this.ctx.lineCap = 'round';\n            this.ctx.beginPath();\n            this.ctx.moveTo(screenPos.x, screenPos.y);\n            this.ctx.lineTo(screenPos.x + Math.cos(gunAngle) * barrelLength, screenPos.y + Math.sin(gunAngle) * barrelLength);\n            this.ctx.stroke();\n        }\n        this.drawHealthDisplay(screenPos, building.health, building.maxHealth, radius, -radius - 10);\n    }\n    /**\n     * Draw a Space Dust Swirler building\n     */\n    drawSpaceDustSwirler(building, color, game, isEnemy) {\n        const screenPos = this.worldToScreen(building.position);\n        const radius = building.radius * this.zoom;\n        // Check visibility for enemy buildings\n        let shouldDim = false;\n        let displayColor = color;\n        if (isEnemy && this.viewingPlayer) {\n            const isVisible = game.isObjectVisibleToPlayer(building.position, this.viewingPlayer);\n            if (!isVisible) {\n                return; // Don't draw invisible enemy buildings\n            }\n            // Check if in shadow for dimming effect - darken color instead of using alpha\n            const inShadow = game.isPointInShadow(building.position);\n            if (inShadow) {\n                shouldDim = true;\n                displayColor = this.darkenColor(color, _constants__WEBPACK_IMPORTED_MODULE_1__.SHADE_OPACITY);\n            }\n        }\n        // Draw build progress indicator if not complete\n        if (!building.isComplete) {\n            this.ctx.fillStyle = 'rgba(138, 43, 226, 0.2)'; // Purple tint\n            this.ctx.strokeStyle = '#8A2BE2';\n            this.ctx.lineWidth = 2;\n            this.ctx.beginPath();\n            this.ctx.arc(screenPos.x, screenPos.y, radius, 0, Math.PI * 2);\n            this.ctx.fill();\n            this.ctx.stroke();\n            // Draw progress bar\n            const barWidth = radius * 2;\n            const barHeight = 4;\n            const barX = screenPos.x - barWidth / 2;\n            const barY = screenPos.y + radius + 5;\n            this.ctx.fillStyle = '#333333';\n            this.ctx.fillRect(barX, barY, barWidth, barHeight);\n            this.ctx.fillStyle = '#8A2BE2';\n            this.ctx.fillRect(barX, barY, barWidth * building.buildProgress, barHeight);\n            // Reset alpha\n            if (shouldDim) {\n                this.ctx.globalAlpha = 1.0;\n            }\n            return;\n        }\n        // Draw influence radius (faint circle) - use current radius for smooth animation\n        const influenceRadius = building.currentInfluenceRadius * this.zoom;\n        this.ctx.strokeStyle = displayColor;\n        this.ctx.globalAlpha = 0.15;\n        this.ctx.lineWidth = 1;\n        this.ctx.beginPath();\n        this.ctx.arc(screenPos.x, screenPos.y, influenceRadius, 0, Math.PI * 2);\n        this.ctx.stroke();\n        this.ctx.globalAlpha = 1.0;\n        // Draw base (circular platform with energy pattern)\n        this.ctx.fillStyle = displayColor;\n        this.ctx.strokeStyle = shouldDim ? this.darkenColor('#FFFFFF', _constants__WEBPACK_IMPORTED_MODULE_1__.SHADE_OPACITY) : '#FFFFFF';\n        this.ctx.lineWidth = 2;\n        this.ctx.beginPath();\n        this.ctx.arc(screenPos.x, screenPos.y, radius, 0, Math.PI * 2);\n        this.ctx.fill();\n        this.ctx.stroke();\n        // Draw selection indicator if selected\n        if (building.isSelected) {\n            this.drawBuildingSelectionIndicator(screenPos, radius);\n        }\n        // Draw swirl pattern in center (3 curved arcs rotating counter-clockwise)\n        const swirlRadius = radius * 0.7;\n        this.ctx.strokeStyle = shouldDim ? this.darkenColor('#8A2BE2', _constants__WEBPACK_IMPORTED_MODULE_1__.SHADE_OPACITY) : '#8A2BE2'; // Purple color for swirl\n        this.ctx.lineWidth = 3 * this.zoom;\n        this.ctx.lineCap = 'round';\n        for (let i = 0; i < 3; i++) {\n            const angle = (Date.now() / 500 + i * Math.PI * 2 / 3) % (Math.PI * 2); // Rotating animation\n            this.ctx.beginPath();\n            this.ctx.arc(screenPos.x, screenPos.y, swirlRadius, angle, angle + Math.PI / 2);\n            this.ctx.stroke();\n        }\n        // Draw central energy core\n        const coreRadius = radius * 0.25;\n        this.ctx.fillStyle = shouldDim ? this.darkenColor('#DDA0DD', _constants__WEBPACK_IMPORTED_MODULE_1__.SHADE_OPACITY) : '#DDA0DD'; // Plum color\n        this.ctx.beginPath();\n        this.ctx.arc(screenPos.x, screenPos.y, coreRadius, 0, Math.PI * 2);\n        this.ctx.fill();\n        // Draw health bar/number if damaged\n        this.drawHealthDisplay(screenPos, building.health, building.maxHealth, radius, -radius - 10);\n    }\n    /**\n     * Draw a Foundry building\n     */\n    drawSubsidiaryFactory(building, color, game, isEnemy) {\n        const screenPos = this.worldToScreen(building.position);\n        const radius = building.radius * this.zoom;\n        // Check visibility for enemy buildings\n        let shouldDim = false;\n        let displayColor = color;\n        if (isEnemy && this.viewingPlayer) {\n            const isVisible = game.isObjectVisibleToPlayer(building.position, this.viewingPlayer);\n            if (!isVisible) {\n                return; // Don't draw invisible enemy buildings\n            }\n            // Check if in shadow for dimming effect - darken color instead of using alpha\n            const inShadow = game.isPointInShadow(building.position);\n            if (inShadow) {\n                shouldDim = true;\n                displayColor = this.darkenColor(color, _constants__WEBPACK_IMPORTED_MODULE_1__.SHADE_OPACITY);\n            }\n        }\n        // Draw build progress indicator if not complete\n        if (!building.isComplete) {\n            this.ctx.fillStyle = 'rgba(255, 215, 0, 0.2)'; // Gold tint\n            this.ctx.strokeStyle = '#FFD700';\n            this.ctx.lineWidth = 2;\n            this.ctx.beginPath();\n            this.ctx.arc(screenPos.x, screenPos.y, radius, 0, Math.PI * 2);\n            this.ctx.fill();\n            this.ctx.stroke();\n            // Draw progress bar\n            const barWidth = radius * 2;\n            const barHeight = 4;\n            const barX = screenPos.x - barWidth / 2;\n            const barY = screenPos.y + radius + 5;\n            this.ctx.fillStyle = '#333333';\n            this.ctx.fillRect(barX, barY, barWidth, barHeight);\n            this.ctx.fillStyle = '#FFD700';\n            this.ctx.fillRect(barX, barY, barWidth * building.buildProgress, barHeight);\n            // Reset alpha\n            if (shouldDim) {\n                this.ctx.globalAlpha = 1.0;\n            }\n            return;\n        }\n        // Draw main structure (hexagon shape for industrial look)\n        this.ctx.fillStyle = displayColor;\n        this.ctx.strokeStyle = shouldDim ? this.darkenColor('#FFFFFF', _constants__WEBPACK_IMPORTED_MODULE_1__.SHADE_OPACITY) : '#FFFFFF';\n        this.ctx.lineWidth = 2;\n        this.ctx.beginPath();\n        for (let i = 0; i < 6; i++) {\n            const angle = (Math.PI / 3) * i;\n            const x = screenPos.x + Math.cos(angle) * radius;\n            const y = screenPos.y + Math.sin(angle) * radius;\n            if (i === 0) {\n                this.ctx.moveTo(x, y);\n            }\n            else {\n                this.ctx.lineTo(x, y);\n            }\n        }\n        this.ctx.closePath();\n        this.ctx.fill();\n        this.ctx.stroke();\n        // Draw selection indicator if selected\n        if (building.isSelected) {\n            this.drawBuildingSelectionIndicator(screenPos, radius);\n        }\n        // Draw production indicator (rotating inner hexagon)\n        const innerRadius = radius * 0.6;\n        const rotation = (Date.now() / 1000) % (Math.PI * 2);\n        this.ctx.strokeStyle = shouldDim ? this.darkenColor('#FFD700', _constants__WEBPACK_IMPORTED_MODULE_1__.SHADE_OPACITY) : '#FFD700'; // Gold color\n        this.ctx.lineWidth = 2 * this.zoom;\n        this.ctx.beginPath();\n        for (let i = 0; i < 6; i++) {\n            const angle = (Math.PI / 3) * i + rotation;\n            const x = screenPos.x + Math.cos(angle) * innerRadius;\n            const y = screenPos.y + Math.sin(angle) * innerRadius;\n            if (i === 0) {\n                this.ctx.moveTo(x, y);\n            }\n            else {\n                this.ctx.lineTo(x, y);\n            }\n        }\n        this.ctx.closePath();\n        this.ctx.stroke();\n        // Draw central core\n        const coreRadius = radius * 0.3;\n        this.ctx.fillStyle = shouldDim ? this.darkenColor('#FFD700', _constants__WEBPACK_IMPORTED_MODULE_1__.SHADE_OPACITY) : '#FFD700';\n        this.ctx.beginPath();\n        this.ctx.arc(screenPos.x, screenPos.y, coreRadius, 0, Math.PI * 2);\n        this.ctx.fill();\n        // Draw health bar/number if damaged\n        this.drawHealthDisplay(screenPos, building.health, building.maxHealth, radius, -radius - 10);\n    }\n    /**\n     * Draw a Grave projectile with trail\n     */\n    drawGraveProjectile(projectile, color) {\n        const screenPos = this.worldToScreen(projectile.position);\n        const size = 4 * this.zoom;\n        // Draw trail if attacking\n        if (projectile.isAttacking && projectile.trail.length > 1) {\n            this.ctx.strokeStyle = color;\n            this.ctx.lineWidth = 2 * this.zoom;\n            this.ctx.globalAlpha = 0.5;\n            this.ctx.beginPath();\n            for (let i = 0; i < projectile.trail.length; i++) {\n                const trailPos = this.worldToScreen(projectile.trail[i]);\n                if (i === 0) {\n                    this.ctx.moveTo(trailPos.x, trailPos.y);\n                }\n                else {\n                    this.ctx.lineTo(trailPos.x, trailPos.y);\n                }\n            }\n            this.ctx.stroke();\n            this.ctx.globalAlpha = 1.0;\n        }\n        // Draw projectile as a circle\n        this.ctx.fillStyle = color;\n        this.ctx.strokeStyle = '#FFFFFF';\n        this.ctx.lineWidth = 1 * this.zoom;\n        this.ctx.beginPath();\n        this.ctx.arc(screenPos.x, screenPos.y, size, 0, Math.PI * 2);\n        this.ctx.fill();\n        this.ctx.stroke();\n        // Add a glow effect when attacking\n        if (projectile.isAttacking) {\n            this.ctx.fillStyle = `rgba(255, 255, 255, 0.3)`;\n            this.ctx.beginPath();\n            this.ctx.arc(screenPos.x, screenPos.y, size * 1.5, 0, Math.PI * 2);\n            this.ctx.fill();\n        }\n    }\n    /**\n     * Draw connection lines with visual indicators for line of sight\n     */\n    drawConnections(player, suns, asteroids, players) {\n        if (!player.stellarForge)\n            return;\n        if (this.viewingPlayer && player !== this.viewingPlayer)\n            return;\n        const forgeScreenPos = this.worldToScreen(player.stellarForge.position);\n        // Draw lines from mirrors to sun and forge\n        for (const mirror of player.solarMirrors) {\n            const mirrorScreenPos = this.worldToScreen(mirror.position);\n            // Check line of sight to sun\n            const hasLoSToSun = mirror.hasLineOfSightToLight(suns, asteroids);\n            const closestSun = hasLoSToSun\n                ? mirror.getClosestVisibleSun(suns, asteroids)\n                : mirror.getClosestSun(suns);\n            // Check line of sight to forge\n            const hasLoSToForge = mirror.hasLineOfSightToForge(player.stellarForge, asteroids, players);\n            // Draw line to sun only when blocked\n            if (closestSun && !hasLoSToSun) {\n                const sunScreenPos = this.worldToScreen(closestSun.position);\n                this.ctx.strokeStyle = 'rgba(255, 0, 0, 0.4)';\n                this.ctx.lineWidth = 1.5;\n                this.ctx.setLineDash([3, 3]);\n                this.ctx.beginPath();\n                this.ctx.moveTo(mirrorScreenPos.x, mirrorScreenPos.y);\n                this.ctx.lineTo(sunScreenPos.x, sunScreenPos.y);\n                this.ctx.stroke();\n                this.ctx.setLineDash([]);\n            }\n            // Draw line to forge only when blocked\n            if (!hasLoSToForge) {\n                this.ctx.strokeStyle = 'rgba(255, 0, 0, 0.4)';\n                this.ctx.lineWidth = 1.5;\n                this.ctx.setLineDash([3, 3]);\n                this.ctx.beginPath();\n                this.ctx.moveTo(mirrorScreenPos.x, mirrorScreenPos.y);\n                this.ctx.lineTo(forgeScreenPos.x, forgeScreenPos.y);\n                this.ctx.stroke();\n                this.ctx.setLineDash([]);\n            }\n            // Draw combined status indicator on the mirror\n            if (hasLoSToSun && hasLoSToForge) {\n                // Both clear - draw bright yellow glow\n                this.ctx.fillStyle = 'rgba(255, 255, 0, 0.5)';\n                this.ctx.beginPath();\n                this.ctx.arc(mirrorScreenPos.x, mirrorScreenPos.y, _constants__WEBPACK_IMPORTED_MODULE_1__.MIRROR_ACTIVE_GLOW_RADIUS * this.zoom, 0, Math.PI * 2);\n                this.ctx.fill();\n            }\n        }\n    }\n    /**\n     * Draw UI overlay\n     */\n    drawUI(game) {\n        // Only show info if showInfo is true\n        if (this.showInfo) {\n            const dpr = window.devicePixelRatio || 1;\n            const screenWidth = this.canvas.width / dpr;\n            const screenHeight = this.canvas.height / dpr;\n            const isCompactLayout = screenWidth < 600;\n            const infoFontSize = isCompactLayout ? 13 : 16;\n            const infoLineHeight = infoFontSize + 4;\n            const infoBoxWidth = Math.min(300, screenWidth - 20);\n            const infoBoxHeight = 20 + infoLineHeight * 5 + game.players.length * 60;\n            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\n            this.ctx.fillRect(10, 10, infoBoxWidth, infoBoxHeight);\n            this.ctx.fillStyle = '#FFFFFF';\n            this.ctx.font = `${infoFontSize}px Doto`;\n            let infoY = 30;\n            this.ctx.fillText(`SoL - Speed of Light RTS`, 20, infoY);\n            infoY += infoLineHeight;\n            this.ctx.fillText(`Game Time: ${game.gameTime.toFixed(1)}s`, 20, infoY);\n            infoY += infoLineHeight;\n            this.ctx.fillText(`Dust Particles: ${game.spaceDust.length}`, 20, infoY);\n            infoY += infoLineHeight;\n            this.ctx.fillText(`Asteroids: ${game.asteroids.length}`, 20, infoY);\n            infoY += infoLineHeight;\n            this.ctx.fillText(`Warp Gates: ${game.warpGates.length}`, 20, infoY);\n            let y = infoY + infoLineHeight;\n            for (const player of game.players) {\n                const color = this.getFactionColor(player.faction);\n                this.ctx.fillStyle = color;\n                this.ctx.fillText(`${player.name} (${player.faction})`, 20, y);\n                this.ctx.fillStyle = '#FFFFFF';\n                this.ctx.fillText(`Energy: ${player.energy.toFixed(1)}`, 20, y + 20);\n                if (player.stellarForge) {\n                    const status = player.stellarForge.isReceivingLight ? ' Light' : ' No Light';\n                    this.ctx.fillText(`${status} | HP: ${player.stellarForge.health.toFixed(0)}`, 20, y + 40);\n                }\n                y += 60;\n            }\n            // Draw controls help\n            const controlLines = isCompactLayout\n                ? GameRenderer.CONTROL_LINES_COMPACT\n                : GameRenderer.CONTROL_LINES_FULL;\n            const controlFontSize = isCompactLayout ? 12 : 14;\n            const controlLineHeight = controlFontSize + 4;\n            const controlBoxWidth = Math.min(450, screenWidth - 20);\n            const controlBoxHeight = controlLineHeight * controlLines.length + 14;\n            const controlBoxX = 10;\n            const controlBoxY = screenHeight - controlBoxHeight - 10;\n            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\n            this.ctx.fillRect(controlBoxX, controlBoxY, controlBoxWidth, controlBoxHeight);\n            this.ctx.fillStyle = '#FFFFFF';\n            this.ctx.font = `${controlFontSize}px Doto`;\n            let controlTextY = controlBoxY + controlLineHeight;\n            for (const line of controlLines) {\n                this.ctx.fillText(line, 20, controlTextY);\n                controlTextY += controlLineHeight;\n            }\n        }\n    }\n    /**\n     * Draw selection rectangle\n     */\n    drawSelectionRectangle() {\n        if (!this.selectionStart || !this.selectionEnd)\n            return;\n        const x = Math.min(this.selectionStart.x, this.selectionEnd.x);\n        const y = Math.min(this.selectionStart.y, this.selectionEnd.y);\n        const width = Math.abs(this.selectionEnd.x - this.selectionStart.x);\n        const height = Math.abs(this.selectionEnd.y - this.selectionStart.y);\n        // Draw selection rectangle\n        this.ctx.strokeStyle = 'rgba(0, 255, 0, 0.8)';\n        this.ctx.lineWidth = 2;\n        this.ctx.setLineDash([5, 5]);\n        this.ctx.strokeRect(x, y, width, height);\n        // Draw filled background\n        this.ctx.fillStyle = 'rgba(0, 255, 0, 0.1)';\n        this.ctx.fillRect(x, y, width, height);\n        this.ctx.setLineDash([]);\n    }\n    /**\n     * Draw ability arrow for hero units\n     */\n    drawAbilityArrow() {\n        if (!this.abilityArrowStart || !this.abilityArrowEnd)\n            return;\n        const dx = this.abilityArrowEnd.x - this.abilityArrowStart.x;\n        const dy = this.abilityArrowEnd.y - this.abilityArrowStart.y;\n        const length = Math.sqrt(dx * dx + dy * dy);\n        // Don't draw if arrow is too short\n        if (length < _constants__WEBPACK_IMPORTED_MODULE_1__.ABILITY_ARROW_MIN_LENGTH)\n            return;\n        // Draw arrow shaft\n        this.ctx.strokeStyle = 'rgba(255, 215, 0, 0.9)'; // Gold color for hero abilities\n        this.ctx.lineWidth = 4;\n        this.ctx.setLineDash([]);\n        this.ctx.beginPath();\n        this.ctx.moveTo(this.abilityArrowStart.x, this.abilityArrowStart.y);\n        this.ctx.lineTo(this.abilityArrowEnd.x, this.abilityArrowEnd.y);\n        this.ctx.stroke();\n        // Draw arrowhead\n        const angle = Math.atan2(dy, dx);\n        const arrowHeadLength = 20;\n        const arrowHeadAngle = Math.PI / 6; // 30 degrees\n        this.ctx.fillStyle = 'rgba(255, 215, 0, 0.9)';\n        this.ctx.beginPath();\n        this.ctx.moveTo(this.abilityArrowEnd.x, this.abilityArrowEnd.y);\n        this.ctx.lineTo(this.abilityArrowEnd.x - arrowHeadLength * Math.cos(angle - arrowHeadAngle), this.abilityArrowEnd.y - arrowHeadLength * Math.sin(angle - arrowHeadAngle));\n        this.ctx.lineTo(this.abilityArrowEnd.x - arrowHeadLength * Math.cos(angle + arrowHeadAngle), this.abilityArrowEnd.y - arrowHeadLength * Math.sin(angle + arrowHeadAngle));\n        this.ctx.closePath();\n        this.ctx.fill();\n        // Draw a circle at the start point\n        this.ctx.fillStyle = 'rgba(255, 215, 0, 0.5)';\n        this.ctx.beginPath();\n        this.ctx.arc(this.abilityArrowStart.x, this.abilityArrowStart.y, 8, 0, Math.PI * 2);\n        this.ctx.fill();\n    }\n    /**\n     * Draw a path preview for selected units (not from base)\n     */\n    drawUnitPathPreview() {\n        // Only draw if we have path points and no forge (meaning it's a unit path, not a base path)\n        if (!this.pathPreviewForge && this.pathPreviewPoints.length > 0) {\n            // Get the average position of selected units as the start point\n            let avgX = 0;\n            let avgY = 0;\n            let count = 0;\n            for (const unit of this.selectedUnits) {\n                avgX += unit.position.x;\n                avgY += unit.position.y;\n                count++;\n            }\n            if (count > 0) {\n                const startWorld = new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(avgX / count, avgY / count);\n                this.drawMinionPathPreview(startWorld, this.pathPreviewPoints, this.pathPreviewEnd);\n            }\n        }\n    }\n    /**\n     * Draw a path preview while the player is actively drawing a minion route.\n     */\n    drawMinionPathPreview(startWorld, waypoints, endWorld) {\n        this.ctx.strokeStyle = 'rgba(255, 255, 0, 0.9)';\n        this.ctx.lineWidth = 3;\n        this.ctx.setLineDash([6, 6]);\n        this.ctx.beginPath();\n        const startScreen = this.worldToScreen(startWorld);\n        this.ctx.moveTo(startScreen.x, startScreen.y);\n        for (let i = 0; i < waypoints.length; i++) {\n            const waypointScreen = this.worldToScreen(waypoints[i]);\n            this.ctx.lineTo(waypointScreen.x, waypointScreen.y);\n        }\n        if (endWorld) {\n            const endScreen = this.worldToScreen(endWorld);\n            this.ctx.lineTo(endScreen.x, endScreen.y);\n        }\n        this.ctx.stroke();\n        this.ctx.setLineDash([]);\n        this.ctx.fillStyle = 'rgba(255, 255, 0, 0.9)';\n        for (let i = 0; i < waypoints.length; i++) {\n            const waypointScreen = this.worldToScreen(waypoints[i]);\n            this.ctx.beginPath();\n            this.ctx.arc(waypointScreen.x, waypointScreen.y, 4, 0, Math.PI * 2);\n            this.ctx.fill();\n        }\n        if (endWorld) {\n            const endScreen = this.worldToScreen(endWorld);\n            this.ctx.strokeStyle = 'rgba(255, 255, 0, 0.9)';\n            this.ctx.lineWidth = 2;\n            this.ctx.beginPath();\n            this.ctx.arc(endScreen.x, endScreen.y, 6, 0, Math.PI * 2);\n            this.ctx.stroke();\n        }\n    }\n    /**\n     * Create a tap visual effect at screen position\n     */\n    createTapEffect(screenX, screenY) {\n        this.tapEffects.push({\n            position: new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(screenX, screenY),\n            progress: 0\n        });\n    }\n    /**\n     * Create a swipe visual effect from start to end screen positions\n     */\n    createSwipeEffect(startX, startY, endX, endY) {\n        this.swipeEffects.push({\n            start: new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(startX, startY),\n            end: new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(endX, endY),\n            progress: 0\n        });\n    }\n    /**\n     * Create a warp gate shockwave effect at a world position\n     */\n    createWarpGateShockwave(position) {\n        this.warpGateShockwaves.push({\n            position: new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(position.x, position.y),\n            progress: 0\n        });\n    }\n    /**\n     * Create a production button wave effect at a world position\n     */\n    createProductionButtonWave(position) {\n        this.productionButtonWaves.push({\n            position: new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(position.x, position.y),\n            progress: 0\n        });\n    }\n    /**\n     * Update and draw tap effects (expanding ripple)\n     */\n    updateAndDrawTapEffects() {\n        // Update and draw each tap effect\n        for (let i = this.tapEffects.length - 1; i >= 0; i--) {\n            const effect = this.tapEffects[i];\n            effect.progress += _constants__WEBPACK_IMPORTED_MODULE_1__.TAP_EFFECT_SPEED; // Increment progress (0 to 1)\n            if (effect.progress >= 1) {\n                // Remove completed effects\n                this.tapEffects.splice(i, 1);\n                continue;\n            }\n            // Draw expanding ripple\n            const radius = _constants__WEBPACK_IMPORTED_MODULE_1__.TAP_EFFECT_MAX_RADIUS * effect.progress;\n            const alpha = 1 - effect.progress; // Fade out\n            this.ctx.strokeStyle = `rgba(100, 200, 255, ${alpha})`;\n            this.ctx.lineWidth = 3;\n            this.ctx.beginPath();\n            this.ctx.arc(effect.position.x, effect.position.y, radius, 0, Math.PI * 2);\n            this.ctx.stroke();\n            // Draw inner glow\n            const gradient = this.ctx.createRadialGradient(effect.position.x, effect.position.y, 0, effect.position.x, effect.position.y, radius * 0.5);\n            gradient.addColorStop(0, `rgba(100, 200, 255, ${alpha * 0.5})`);\n            gradient.addColorStop(1, 'rgba(100, 200, 255, 0)');\n            this.ctx.fillStyle = gradient;\n            this.ctx.beginPath();\n            this.ctx.arc(effect.position.x, effect.position.y, radius * 0.5, 0, Math.PI * 2);\n            this.ctx.fill();\n        }\n    }\n    /**\n     * Update and draw swipe effects (directional trail)\n     */\n    updateAndDrawSwipeEffects() {\n        // Update and draw each swipe effect\n        for (let i = this.swipeEffects.length - 1; i >= 0; i--) {\n            const effect = this.swipeEffects[i];\n            effect.progress += _constants__WEBPACK_IMPORTED_MODULE_1__.SWIPE_EFFECT_SPEED; // Increment progress (0 to 1)\n            if (effect.progress >= 1) {\n                // Remove completed effects\n                this.swipeEffects.splice(i, 1);\n                continue;\n            }\n            // Calculate direction and length\n            const dx = effect.end.x - effect.start.x;\n            const dy = effect.end.y - effect.start.y;\n            const length = Math.sqrt(dx * dx + dy * dy);\n            if (length < 5)\n                continue; // Skip very short swipes\n            // Draw arrow trail\n            const alpha = 1 - effect.progress;\n            const currentLength = length * effect.progress;\n            // Draw line\n            this.ctx.strokeStyle = `rgba(255, 200, 100, ${alpha * 0.7})`;\n            this.ctx.lineWidth = 4;\n            this.ctx.lineCap = 'round';\n            this.ctx.beginPath();\n            this.ctx.moveTo(effect.start.x, effect.start.y);\n            const endX = effect.start.x + (dx / length) * currentLength;\n            const endY = effect.start.y + (dy / length) * currentLength;\n            this.ctx.lineTo(endX, endY);\n            this.ctx.stroke();\n            // Draw arrow head at the end\n            if (effect.progress > 0.3) {\n                const angle = Math.atan2(dy, dx);\n                this.ctx.fillStyle = `rgba(255, 200, 100, ${alpha})`;\n                this.ctx.beginPath();\n                this.ctx.moveTo(endX, endY);\n                this.ctx.lineTo(endX - _constants__WEBPACK_IMPORTED_MODULE_1__.SWIPE_ARROW_SIZE * Math.cos(angle - Math.PI / 6), endY - _constants__WEBPACK_IMPORTED_MODULE_1__.SWIPE_ARROW_SIZE * Math.sin(angle - Math.PI / 6));\n                this.ctx.lineTo(endX - _constants__WEBPACK_IMPORTED_MODULE_1__.SWIPE_ARROW_SIZE * Math.cos(angle + Math.PI / 6), endY - _constants__WEBPACK_IMPORTED_MODULE_1__.SWIPE_ARROW_SIZE * Math.sin(angle + Math.PI / 6));\n                this.ctx.closePath();\n                this.ctx.fill();\n            }\n            // Draw glow trail\n            for (let j = 0; j < 5; j++) {\n                const t = j / 5;\n                const px = effect.start.x + (dx / length) * currentLength * t;\n                const py = effect.start.y + (dy / length) * currentLength * t;\n                const glowAlpha = alpha * (1 - t) * 0.3;\n                const gradient = this.ctx.createRadialGradient(px, py, 0, px, py, 10);\n                gradient.addColorStop(0, `rgba(255, 200, 100, ${glowAlpha})`);\n                gradient.addColorStop(1, 'rgba(255, 200, 100, 0)');\n                this.ctx.fillStyle = gradient;\n                this.ctx.beginPath();\n                this.ctx.arc(px, py, 10, 0, Math.PI * 2);\n                this.ctx.fill();\n            }\n        }\n    }\n    /**\n     * Update and draw warp gate shockwave effects\n     */\n    updateAndDrawWarpGateShockwaves() {\n        for (let i = this.warpGateShockwaves.length - 1; i >= 0; i--) {\n            const effect = this.warpGateShockwaves[i];\n            effect.progress += _constants__WEBPACK_IMPORTED_MODULE_1__.WARP_GATE_SHOCKWAVE_PROGRESS_PER_FRAME;\n            if (effect.progress >= 1) {\n                this.warpGateShockwaves.splice(i, 1);\n                continue;\n            }\n            const screenPos = this.worldToScreen(effect.position);\n            const radius = _constants__WEBPACK_IMPORTED_MODULE_1__.WARP_GATE_SHOCKWAVE_MAX_RADIUS_PX * effect.progress * this.zoom;\n            const alpha = (1 - effect.progress) * 0.8;\n            this.ctx.strokeStyle = `rgba(0, 255, 255, ${alpha})`;\n            this.ctx.lineWidth = Math.max(2, 3 * this.zoom);\n            this.ctx.beginPath();\n            this.ctx.arc(screenPos.x, screenPos.y, radius, 0, Math.PI * 2);\n            this.ctx.stroke();\n        }\n    }\n    /**\n     * Update and draw production button wave effects\n     */\n    updateAndDrawProductionButtonWaves() {\n        for (let i = this.productionButtonWaves.length - 1; i >= 0; i--) {\n            const effect = this.productionButtonWaves[i];\n            effect.progress += _constants__WEBPACK_IMPORTED_MODULE_1__.PRODUCTION_BUTTON_WAVE_PROGRESS_PER_FRAME;\n            if (effect.progress >= 1) {\n                this.productionButtonWaves.splice(i, 1);\n                continue;\n            }\n            const screenPos = this.worldToScreen(effect.position);\n            const radius = _constants__WEBPACK_IMPORTED_MODULE_1__.PRODUCTION_BUTTON_WAVE_MAX_RADIUS_PX * effect.progress * this.zoom;\n            const alpha = (1 - effect.progress) * 0.9;\n            this.ctx.strokeStyle = `rgba(255, 215, 0, ${alpha})`;\n            this.ctx.lineWidth = Math.max(1, 2 * this.zoom);\n            this.ctx.beginPath();\n            this.ctx.arc(screenPos.x, screenPos.y, radius, 0, Math.PI * 2);\n            this.ctx.stroke();\n            const gradient = this.ctx.createRadialGradient(screenPos.x, screenPos.y, 0, screenPos.x, screenPos.y, radius);\n            gradient.addColorStop(0, `rgba(255, 215, 0, ${alpha * 0.35})`);\n            gradient.addColorStop(1, 'rgba(255, 215, 0, 0)');\n            this.ctx.fillStyle = gradient;\n            this.ctx.beginPath();\n            this.ctx.arc(screenPos.x, screenPos.y, radius * 0.6, 0, Math.PI * 2);\n            this.ctx.fill();\n        }\n    }\n    /**\n     * Draw damage numbers floating up from damaged units\n     */\n    drawDamageNumbers(game) {\n        for (const damageNumber of game.damageNumbers) {\n            const screenPos = this.worldToScreen(damageNumber.position);\n            const opacity = damageNumber.getOpacity(game.gameTime);\n            // Determine what to display based on mode\n            const displayValue = this.damageDisplayMode === 'remaining-life'\n                ? damageNumber.remainingHealth\n                : damageNumber.damage;\n            // Calculate size based on damage proportion to max health\n            // Range: 8px (small) to 24px (large)\n            const damageRatio = damageNumber.damage / damageNumber.maxHealth;\n            const fontSize = Math.max(8, Math.min(24, 8 + damageRatio * 80));\n            this.ctx.font = `bold ${fontSize}px Doto`;\n            // For remaining life mode, color based on health percentage\n            if (this.damageDisplayMode === 'remaining-life') {\n                const healthPercent = damageNumber.remainingHealth / damageNumber.maxHealth;\n                const color = this.getHealthColor(healthPercent);\n                this.ctx.fillStyle = `rgba(${color.r}, ${color.g}, ${color.b}, ${opacity})`;\n            }\n            else {\n                // Damage numbers are red\n                this.ctx.fillStyle = `rgba(255, 100, 100, ${opacity})`;\n            }\n            this.ctx.textAlign = 'center';\n            this.ctx.textBaseline = 'middle';\n            // Add stroke for readability\n            this.ctx.strokeStyle = `rgba(0, 0, 0, ${opacity * 0.8})`;\n            this.ctx.lineWidth = 2;\n            this.ctx.strokeText(displayValue.toString(), screenPos.x, screenPos.y);\n            this.ctx.fillText(displayValue.toString(), screenPos.x, screenPos.y);\n        }\n    }\n    /**\n     * Get health color based on percentage (green -> yellow -> red)\n     */\n    getHealthColor(healthPercent) {\n        if (healthPercent > 0.6) {\n            // Green zone: interpolate from green (0, 255, 0) to yellow (255, 255, 0)\n            const t = (healthPercent - 0.6) / 0.4; // 0 at 60%, 1 at 100%\n            return {\n                r: Math.round(255 * (1 - t)),\n                g: 255,\n                b: 0\n            };\n        }\n        else if (healthPercent > 0.3) {\n            // Yellow zone: interpolate from orange-red (255, 165, 0) to yellow (255, 255, 0)\n            const t = (healthPercent - 0.3) / 0.3; // 0 at 30%, 1 at 60%\n            return {\n                r: 255,\n                g: Math.round(165 + 90 * t),\n                b: 0\n            };\n        }\n        else {\n            // Red zone: interpolate from dark red (180, 0, 0) to orange-red (255, 165, 0)\n            const t = healthPercent / 0.3; // 0 at 0%, 1 at 30%\n            return {\n                r: Math.round(180 + 75 * t),\n                g: Math.round(165 * t),\n                b: 0\n            };\n        }\n    }\n    /**\n     * Draw health display (bar or number) for an entity\n     */\n    drawHealthDisplay(screenPos, currentHealth, maxHealth, size, yOffset) {\n        if (currentHealth >= maxHealth) {\n            return; // Don't draw if at full health\n        }\n        const healthPercent = currentHealth / maxHealth;\n        if (this.healthDisplayMode === 'bar') {\n            // Draw health bar\n            const barWidth = size * 3;\n            const barHeight = 3;\n            const barX = screenPos.x - barWidth / 2;\n            const barY = screenPos.y + yOffset;\n            this.ctx.fillStyle = '#333';\n            this.ctx.fillRect(barX, barY, barWidth, barHeight);\n            this.ctx.fillStyle = healthPercent > 0.5 ? '#00FF00' : healthPercent > 0.25 ? '#FFFF00' : '#FF0000';\n            this.ctx.fillRect(barX, barY, barWidth * healthPercent, barHeight);\n        }\n        else {\n            // Draw health number\n            const healthColor = this.getHealthColor(healthPercent);\n            const fontSize = Math.max(10, size * 1.5);\n            this.ctx.font = `bold ${fontSize}px Doto`;\n            this.ctx.fillStyle = `rgb(${healthColor.r}, ${healthColor.g}, ${healthColor.b})`;\n            this.ctx.textAlign = 'center';\n            this.ctx.textBaseline = 'bottom';\n            // Add stroke for readability\n            this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';\n            this.ctx.lineWidth = 2;\n            this.ctx.strokeText(Math.round(currentHealth).toString(), screenPos.x, screenPos.y + yOffset);\n            this.ctx.fillText(Math.round(currentHealth).toString(), screenPos.x, screenPos.y + yOffset);\n        }\n    }\n    /**\n     * Render the entire game state\n     */\n    render(game) {\n        // Clear canvas with color scheme background\n        this.ctx.fillStyle = this.colorScheme.background;\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n        // Draw parallax star layers\n        for (const layer of this.starLayers) {\n            this.ctx.fillStyle = '#FFFFFF';\n            const dpr = window.devicePixelRatio || 1;\n            for (const star of layer.stars) {\n                // Calculate star position with parallax effect\n                const parallaxX = this.parallaxCamera.x * layer.parallaxFactor;\n                const parallaxY = this.parallaxCamera.y * layer.parallaxFactor;\n                // Convert to screen space\n                const centerX = (this.canvas.width / dpr) / 2;\n                const centerY = (this.canvas.height / dpr) / 2;\n                const screenX = centerX + (star.x - parallaxX);\n                const screenY = centerY + (star.y - parallaxY);\n                // Wrap stars around screen edges for infinite scrolling effect\n                const wrappedX = ((screenX + centerX) % (centerX * 2 + _constants__WEBPACK_IMPORTED_MODULE_1__.STAR_WRAP_SIZE)) - centerX;\n                const wrappedY = ((screenY + centerY) % (centerY * 2 + _constants__WEBPACK_IMPORTED_MODULE_1__.STAR_WRAP_SIZE)) - centerY;\n                // Only draw if on screen\n                if (wrappedX >= -100 && wrappedX <= this.canvas.width / dpr + 100 &&\n                    wrappedY >= -100 && wrappedY <= this.canvas.height / dpr + 100) {\n                    this.ctx.globalAlpha = star.brightness;\n                    this.ctx.fillRect(wrappedX, wrappedY, star.size, star.size);\n                }\n            }\n            this.ctx.globalAlpha = 1.0;\n        }\n        const viewingPlayerIndex = this.viewingPlayer ? game.players.indexOf(this.viewingPlayer) : null;\n        // Draw space dust particles (with culling)\n        for (const particle of game.spaceDust) {\n            // Only render particles within map boundaries\n            if (this.isWithinRenderBounds(particle.position, game.mapSize, 10)) {\n                this.drawSpaceDust(particle, game, viewingPlayerIndex);\n            }\n        }\n        // Draw suns\n        for (const sun of game.suns) {\n            this.drawSun(sun);\n        }\n        // Draw sun rays with raytracing (light and shadows)\n        this.drawSunRays(game);\n        // Draw lens flare effects for visible suns\n        for (const sun of game.suns) {\n            this.drawLensFlare(sun);\n        }\n        // Draw asteroids (with culling - skip rendering beyond map bounds)\n        for (const asteroid of game.asteroids) {\n            // Only render asteroids within map boundaries\n            if (this.isWithinRenderBounds(asteroid.position, game.mapSize, asteroid.size)) {\n                this.drawAsteroid(asteroid);\n            }\n        }\n        // Draw influence circles (with proper handling of overlaps)\n        const influenceCircles = [];\n        for (let i = 0; i < game.players.length; i++) {\n            const player = game.players[i];\n            if (viewingPlayerIndex !== null && i !== viewingPlayerIndex) {\n                continue;\n            }\n            if (player.stellarForge && !player.isDefeated()) {\n                const color = i === 0 ? this.playerColor : this.enemyColor;\n                influenceCircles.push({\n                    position: player.stellarForge.position,\n                    radius: _constants__WEBPACK_IMPORTED_MODULE_1__.INFLUENCE_RADIUS,\n                    color: color\n                });\n            }\n        }\n        // Draw influence circles grouped by color to handle overlaps\n        const circlesByColor = new Map();\n        for (const circle of influenceCircles) {\n            if (!circlesByColor.has(circle.color)) {\n                circlesByColor.set(circle.color, []);\n            }\n            circlesByColor.get(circle.color).push({ position: circle.position, radius: circle.radius });\n        }\n        // Draw each color group\n        for (const [color, circles] of circlesByColor) {\n            if (circles.length === 1) {\n                // Single circle, draw normally\n                this.drawInfluenceCircle(circles[0].position, circles[0].radius, color);\n            }\n            else {\n                // Multiple circles of same color\n                // To get union effect, we'll use a temporary canvas\n                this.ctx.save();\n                // Create path with all circles\n                this.ctx.beginPath();\n                for (const circle of circles) {\n                    const screenPos = this.worldToScreen(circle.position);\n                    const screenRadius = circle.radius * this.zoom;\n                    this.ctx.moveTo(screenPos.x + screenRadius, screenPos.y);\n                    this.ctx.arc(screenPos.x, screenPos.y, screenRadius, 0, Math.PI * 2);\n                }\n                // Fill with transparent color first to create union\n                this.ctx.globalCompositeOperation = 'source-over';\n                this.ctx.fillStyle = color;\n                this.ctx.globalAlpha = 0.05;\n                this.ctx.fill();\n                // Now stroke the outer boundary\n                // This approach still shows inner boundaries, so let's just draw each circle\n                this.ctx.globalAlpha = 0.3;\n                this.ctx.strokeStyle = color;\n                this.ctx.lineWidth = 2;\n                this.ctx.stroke();\n                this.ctx.restore();\n            }\n        }\n        // Draw connections first (so they appear behind structures)\n        for (const player of game.players) {\n            if (!player.isDefeated()) {\n                this.drawConnections(player, game.suns, game.asteroids, game.players);\n            }\n        }\n        // Draw structures\n        for (const player of game.players) {\n            if (player.isDefeated())\n                continue;\n            const color = this.getFactionColor(player.faction);\n            const isEnemy = this.viewingPlayer !== null && player !== this.viewingPlayer;\n            // Draw Solar Mirrors (including enemy mirrors with visibility checks)\n            for (const mirror of player.solarMirrors) {\n                this.drawSolarMirror(mirror, color, game, isEnemy);\n            }\n            // Draw Stellar Forge\n            if (player.stellarForge) {\n                this.drawStellarForge(player.stellarForge, color, game, isEnemy);\n            }\n        }\n        // Draw warp gates\n        for (const gate of game.warpGates) {\n            this.drawWarpGate(gate);\n        }\n        // Draw warp gate shockwaves\n        this.updateAndDrawWarpGateShockwaves();\n        // Draw merged range outlines for selected starlings before drawing units\n        this.drawMergedStarlingRanges(game);\n        // Draw units\n        for (const player of game.players) {\n            if (player.isDefeated())\n                continue;\n            const color = this.getFactionColor(player.faction);\n            const isEnemy = this.viewingPlayer !== null && player !== this.viewingPlayer;\n            for (const unit of player.units) {\n                if (unit instanceof _game_core__WEBPACK_IMPORTED_MODULE_0__.Grave) {\n                    this.drawGrave(unit, color, game, isEnemy);\n                }\n                else if (unit instanceof _game_core__WEBPACK_IMPORTED_MODULE_0__.Starling) {\n                    this.drawStarling(unit, color, game, isEnemy);\n                }\n                else if (unit instanceof _game_core__WEBPACK_IMPORTED_MODULE_0__.Ray) {\n                    this.drawRay(unit, color, game, isEnemy);\n                }\n                else if (unit instanceof _game_core__WEBPACK_IMPORTED_MODULE_0__.InfluenceBall) {\n                    this.drawInfluenceBall(unit, color, game, isEnemy);\n                }\n                else if (unit instanceof _game_core__WEBPACK_IMPORTED_MODULE_0__.TurretDeployer) {\n                    this.drawTurretDeployer(unit, color, game, isEnemy);\n                }\n                else if (unit instanceof _game_core__WEBPACK_IMPORTED_MODULE_0__.Driller) {\n                    this.drawDriller(unit, color, game, isEnemy);\n                }\n                else if (unit instanceof _game_core__WEBPACK_IMPORTED_MODULE_0__.Dagger) {\n                    this.drawDagger(unit, color, game, isEnemy);\n                }\n                else if (unit instanceof _game_core__WEBPACK_IMPORTED_MODULE_0__.Beam) {\n                    this.drawBeam(unit, color, game, isEnemy);\n                }\n                else if (unit instanceof _game_core__WEBPACK_IMPORTED_MODULE_0__.Mortar) {\n                    this.drawMortar(unit, color, game, isEnemy);\n                }\n                else if (unit instanceof _game_core__WEBPACK_IMPORTED_MODULE_0__.Preist) {\n                    this.drawPreist(unit, color, game, isEnemy);\n                }\n                else if (unit instanceof _game_core__WEBPACK_IMPORTED_MODULE_0__.Tank) {\n                    this.drawTank(unit, color, game, isEnemy);\n                }\n                else {\n                    this.drawUnit(unit, color, game, isEnemy);\n                }\n            }\n        }\n        // Draw move order lines for selected starlings (single line per group)\n        this.drawStarlingMoveLines(game);\n        // Draw buildings\n        for (const player of game.players) {\n            if (player.isDefeated())\n                continue;\n            const color = this.getFactionColor(player.faction);\n            const isEnemy = this.viewingPlayer !== null && player !== this.viewingPlayer;\n            for (const building of player.buildings) {\n                if (building instanceof _game_core__WEBPACK_IMPORTED_MODULE_0__.Minigun) {\n                    this.drawMinigun(building, color, game, isEnemy);\n                }\n                else if (building instanceof _game_core__WEBPACK_IMPORTED_MODULE_0__.SpaceDustSwirler) {\n                    this.drawSpaceDustSwirler(building, color, game, isEnemy);\n                }\n                else if (building instanceof _game_core__WEBPACK_IMPORTED_MODULE_0__.SubsidiaryFactory) {\n                    this.drawSubsidiaryFactory(building, color, game, isEnemy);\n                }\n            }\n        }\n        // Draw muzzle flashes\n        for (const flash of game.muzzleFlashes) {\n            this.drawMuzzleFlash(flash);\n        }\n        // Draw bullet casings\n        for (const casing of game.bulletCasings) {\n            this.drawBulletCasing(casing);\n        }\n        // Draw bouncing bullets\n        for (const bullet of game.bouncingBullets) {\n            this.drawBouncingBullet(bullet);\n        }\n        // Draw ability bullets\n        for (const bullet of game.abilityBullets) {\n            this.drawAbilityBullet(bullet);\n        }\n        // Draw minion projectiles\n        for (const projectile of game.minionProjectiles) {\n            this.drawMinionProjectile(projectile);\n        }\n        // Draw mortar projectiles\n        for (const projectile of game.mortarProjectiles) {\n            this.drawMortarProjectile(projectile);\n        }\n        // Draw laser beams\n        for (const laser of game.laserBeams) {\n            this.drawLaserBeam(laser);\n        }\n        // Draw impact particles (only on high graphics quality)\n        if (this.graphicsQuality === 'high') {\n            for (const particle of game.impactParticles) {\n                this.drawImpactParticle(particle);\n            }\n        }\n        // Draw influence zones\n        for (const zone of game.influenceZones) {\n            this.drawInfluenceZone(zone);\n        }\n        // Draw influence ball projectiles\n        for (const projectile of game.influenceBallProjectiles) {\n            this.drawInfluenceBallProjectile(projectile);\n        }\n        // Draw crescent waves\n        for (const wave of game.crescentWaves) {\n            this.drawCrescentWave(wave);\n        }\n        // Draw deployed turrets\n        for (const turret of game.deployedTurrets) {\n            this.drawDeployedTurret(turret);\n        }\n        // Draw damage numbers\n        this.drawDamageNumbers(game);\n        // Draw border fade to black effect\n        this.drawBorderFade(game.mapSize);\n        // Draw UI\n        this.drawUI(game);\n        // Draw selection rectangle\n        this.drawSelectionRectangle();\n        // Draw ability arrow for hero units\n        this.drawAbilityArrow();\n        // Draw unit path preview\n        this.drawUnitPathPreview();\n        // Draw tap and swipe visual effects\n        this.updateAndDrawProductionButtonWaves();\n        this.updateAndDrawTapEffects();\n        this.updateAndDrawSwipeEffects();\n        // Check for victory\n        const winner = game.checkVictoryConditions();\n        if (winner) {\n            this.drawEndGameStatsScreen(game, winner);\n        }\n        // Draw countdown overlay\n        if (game.isCountdownActive) {\n            // Semi-transparent overlay\n            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';\n            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n            // Countdown text\n            this.ctx.fillStyle = '#FFD700';\n            this.ctx.font = 'bold 120px Doto';\n            this.ctx.textAlign = 'center';\n            this.ctx.textBaseline = 'middle';\n            const countdownValue = Math.ceil(game.countdownTime);\n            const displayText = countdownValue > 0 ? countdownValue.toString() : 'Go!';\n            this.ctx.fillText(displayText, this.canvas.width / 2, this.canvas.height / 2);\n            this.ctx.textAlign = 'left';\n            this.ctx.textBaseline = 'alphabetic';\n        }\n        // Draw in-game menu button (top-left, always visible when not in countdown)\n        if (!game.isCountdownActive && !winner) {\n            this.drawMenuButton();\n        }\n        // Draw production progress indicator (top-right)\n        if (!game.isCountdownActive && !winner) {\n            this.drawProductionProgress(game);\n        }\n        // Draw in-game menu overlay if open\n        if (this.showInGameMenu && !winner) {\n            this.drawInGameMenuOverlay();\n        }\n    }\n    /**\n     * Draw in-game menu button in top-left corner\n     */\n    drawMenuButton() {\n        const dpr = window.devicePixelRatio || 1;\n        const buttonSize = 50;\n        const margin = 10;\n        // Draw button background\n        this.ctx.fillStyle = 'rgba(50, 50, 50, 0.8)';\n        this.ctx.fillRect(margin, margin, buttonSize, buttonSize);\n        // Draw border\n        this.ctx.strokeStyle = '#FFFFFF';\n        this.ctx.lineWidth = 2;\n        this.ctx.strokeRect(margin, margin, buttonSize, buttonSize);\n        // Draw hamburger icon (three horizontal lines)\n        this.ctx.fillStyle = '#FFFFFF';\n        const lineWidth = 30;\n        const lineHeight = 3;\n        const lineSpacing = 8;\n        const startX = margin + (buttonSize - lineWidth) / 2;\n        const startY = margin + (buttonSize - lineHeight * 3 - lineSpacing * 2) / 2;\n        this.ctx.fillRect(startX, startY, lineWidth, lineHeight);\n        this.ctx.fillRect(startX, startY + lineHeight + lineSpacing, lineWidth, lineHeight);\n        this.ctx.fillRect(startX, startY + (lineHeight + lineSpacing) * 2, lineWidth, lineHeight);\n    }\n    /**\n     * Draw production progress indicator in top-right corner\n     */\n    drawProductionProgress(game) {\n        const dpr = window.devicePixelRatio || 1;\n        const screenWidth = this.canvas.width / dpr;\n        const margin = 10;\n        const boxWidth = 200;\n        const boxHeight = 60;\n        const x = screenWidth - boxWidth - margin;\n        let y = margin;\n        // Check for player's production\n        const player = game.players.find((p) => !p.isAi);\n        if (!player) {\n            return;\n        }\n        // Draw hero production from stellar forge\n        if (player.stellarForge && player.stellarForge.heroProductionUnitType) {\n            const forge = player.stellarForge;\n            // Draw background box\n            this.ctx.fillStyle = 'rgba(50, 50, 50, 0.9)';\n            this.ctx.fillRect(x, y, boxWidth, boxHeight);\n            // Draw border\n            this.ctx.strokeStyle = '#FFD700';\n            this.ctx.lineWidth = 2;\n            this.ctx.strokeRect(x, y, boxWidth, boxHeight);\n            // Draw production name\n            this.ctx.fillStyle = '#FFFFFF';\n            this.ctx.font = 'bold 14px Doto';\n            this.ctx.textAlign = 'left';\n            this.ctx.textBaseline = 'top';\n            const productionName = this.getProductionDisplayName(forge.heroProductionUnitType);\n            this.ctx.fillText(productionName, x + 8, y + 8);\n            // Calculate progress (guard against division by zero)\n            const progress = forge.heroProductionDurationSec > 0\n                ? 1 - (forge.heroProductionRemainingSec / forge.heroProductionDurationSec)\n                : 0;\n            // Draw progress bar\n            this.drawProgressBar(x + 8, y + 32, boxWidth - 16, 16, progress);\n            y += boxHeight + 8;\n        }\n        // Draw building construction progress\n        // Note: find() stops at first match, typically only one building under construction\n        const buildingInProgress = player.buildings.find((building) => !building.isComplete);\n        if (buildingInProgress) {\n            // Draw background box\n            this.ctx.fillStyle = 'rgba(50, 50, 50, 0.9)';\n            this.ctx.fillRect(x, y, boxWidth, boxHeight);\n            // Draw border\n            this.ctx.strokeStyle = '#FFD700';\n            this.ctx.lineWidth = 2;\n            this.ctx.strokeRect(x, y, boxWidth, boxHeight);\n            // Draw building name\n            this.ctx.fillStyle = '#FFFFFF';\n            this.ctx.font = 'bold 14px Doto';\n            this.ctx.textAlign = 'left';\n            this.ctx.textBaseline = 'top';\n            const buildingName = this.getBuildingDisplayName(buildingInProgress);\n            this.ctx.fillText(`Building ${buildingName}`, x + 8, y + 8);\n            // Draw progress bar\n            this.drawProgressBar(x + 8, y + 32, boxWidth - 16, 16, buildingInProgress.buildProgress);\n        }\n        // Reset text alignment\n        this.ctx.textAlign = 'left';\n        this.ctx.textBaseline = 'alphabetic';\n    }\n    /**\n     * Draw a progress bar\n     */\n    drawProgressBar(x, y, width, height, progress) {\n        // Draw progress bar background\n        this.ctx.fillStyle = 'rgba(100, 100, 100, 0.8)';\n        this.ctx.fillRect(x, y, width, height);\n        // Draw progress bar fill\n        this.ctx.fillStyle = '#4CAF50';\n        this.ctx.fillRect(x, y, width * progress, height);\n        // Draw progress bar border\n        this.ctx.strokeStyle = '#FFD700';\n        this.ctx.lineWidth = 1;\n        this.ctx.strokeRect(x, y, width, height);\n        // Draw progress percentage\n        this.ctx.fillStyle = '#FFFFFF';\n        this.ctx.font = 'bold 12px Doto';\n        this.ctx.textAlign = 'center';\n        this.ctx.textBaseline = 'middle';\n        this.ctx.fillText(`${Math.floor(progress * 100)}%`, x + width / 2, y + height / 2);\n    }\n    /**\n     * Get display name for building type\n     */\n    getBuildingDisplayName(building) {\n        if (building instanceof _game_core__WEBPACK_IMPORTED_MODULE_0__.Minigun) {\n            return 'Cannon';\n        }\n        else if (building instanceof _game_core__WEBPACK_IMPORTED_MODULE_0__.SpaceDustSwirler) {\n            return 'Space Dust Swirler';\n        }\n        else if (building instanceof _game_core__WEBPACK_IMPORTED_MODULE_0__.SubsidiaryFactory) {\n            return 'Foundry';\n        }\n        return 'Building';\n    }\n    /**\n     * Get display name for production unit type\n     */\n    getProductionDisplayName(unitType) {\n        const nameMap = {\n            'marine': 'Marine',\n            'grave': 'Grave',\n            'ray': 'Ray',\n            'influenceball': 'Influence Ball',\n            'turretdeployer': 'Turret Deployer',\n            'driller': 'Driller',\n            'dagger': 'Dagger',\n            'beam': 'Beam'\n        };\n        return nameMap[unitType.toLowerCase()] || unitType;\n    }\n    getInGameMenuLayout() {\n        const dpr = window.devicePixelRatio || 1;\n        const screenWidth = this.canvas.width / dpr;\n        const screenHeight = this.canvas.height / dpr;\n        const isCompactLayout = screenWidth < 600;\n        const panelWidth = Math.min(480, screenWidth - 40);\n        const panelHeight = Math.min(460, screenHeight - 40);\n        const panelX = (screenWidth - panelWidth) / 2;\n        const panelY = (screenHeight - panelHeight) / 2;\n        const panelPaddingX = isCompactLayout ? 14 : 20;\n        const panelPaddingY = isCompactLayout ? 16 : 20;\n        const titleY = panelY + (isCompactLayout ? 34 : 42);\n        const tabHeight = isCompactLayout ? 30 : 34;\n        const tabGap = 12;\n        const tabWidth = (panelWidth - panelPaddingX * 2 - tabGap * 2) / 3;\n        const tabY = titleY + (isCompactLayout ? 16 : 18);\n        const tabX = panelX + panelPaddingX;\n        const tabs = [\n            { tab: 'main', x: tabX, y: tabY, width: tabWidth, height: tabHeight },\n            { tab: 'options', x: tabX + tabWidth + tabGap, y: tabY, width: tabWidth, height: tabHeight },\n            { tab: 'graphics', x: tabX + (tabWidth + tabGap) * 2, y: tabY, width: tabWidth, height: tabHeight }\n        ];\n        const contentTopY = tabY + tabHeight + (isCompactLayout ? 16 : 20);\n        const contentBottomY = panelY + panelHeight - panelPaddingY;\n        const buttonWidth = Math.min(300, panelWidth - panelPaddingX * 2);\n        const buttonHeight = isCompactLayout ? 44 : 50;\n        const buttonX = panelX + (panelWidth - buttonWidth) / 2;\n        const buttonSpacing = isCompactLayout ? 14 : 20;\n        const graphicsListX = panelX + panelPaddingX;\n        const graphicsListY = contentTopY;\n        const graphicsListWidth = panelWidth - panelPaddingX * 2;\n        const graphicsListHeight = Math.max(0, contentBottomY - contentTopY);\n        const graphicsRowHeight = isCompactLayout ? 44 : 48;\n        const graphicsButtonWidth = isCompactLayout ? 54 : 60;\n        const graphicsButtonHeight = isCompactLayout ? 26 : 30;\n        const graphicsButtonGap = 8;\n        return {\n            screenWidth,\n            screenHeight,\n            panelX,\n            panelY,\n            panelWidth,\n            panelHeight,\n            isCompactLayout,\n            titleY,\n            tabs,\n            contentTopY,\n            contentBottomY,\n            buttonWidth,\n            buttonHeight,\n            buttonX,\n            buttonSpacing,\n            graphicsListX,\n            graphicsListY,\n            graphicsListWidth,\n            graphicsListHeight,\n            graphicsRowHeight,\n            graphicsButtonWidth,\n            graphicsButtonHeight,\n            graphicsButtonGap\n        };\n    }\n    getGraphicsMenuMaxScroll(layout) {\n        const contentHeight = this.graphicsOptions.length * layout.graphicsRowHeight;\n        return Math.max(0, contentHeight - layout.graphicsListHeight);\n    }\n    handleInGameMenuScroll(screenX, screenY, deltaY) {\n        if (!this.showInGameMenu || this.inGameMenuTab !== 'graphics') {\n            return false;\n        }\n        const layout = this.getInGameMenuLayout();\n        const isWithinList = screenX >= layout.graphicsListX &&\n            screenX <= layout.graphicsListX + layout.graphicsListWidth &&\n            screenY >= layout.graphicsListY &&\n            screenY <= layout.graphicsListY + layout.graphicsListHeight;\n        if (!isWithinList) {\n            return false;\n        }\n        const maxScroll = this.getGraphicsMenuMaxScroll(layout);\n        if (maxScroll === 0) {\n            return true;\n        }\n        this.graphicsMenuScrollOffset = Math.min(maxScroll, Math.max(0, this.graphicsMenuScrollOffset + deltaY));\n        return true;\n    }\n    getInGameMenuAction(screenX, screenY) {\n        if (!this.showInGameMenu) {\n            return null;\n        }\n        const layout = this.getInGameMenuLayout();\n        for (const tab of layout.tabs) {\n            const isWithinTab = screenX >= tab.x &&\n                screenX <= tab.x + tab.width &&\n                screenY >= tab.y &&\n                screenY <= tab.y + tab.height;\n            if (isWithinTab) {\n                return { type: 'tab', tab: tab.tab };\n            }\n        }\n        if (this.inGameMenuTab === 'main') {\n            let buttonY = layout.contentTopY;\n            const buttons = [\n                { action: { type: 'resume' } },\n                { action: { type: 'toggleInfo' } },\n                { action: { type: 'surrender' } }\n            ];\n            for (const button of buttons) {\n                const isWithinButton = screenX >= layout.buttonX &&\n                    screenX <= layout.buttonX + layout.buttonWidth &&\n                    screenY >= buttonY &&\n                    screenY <= buttonY + layout.buttonHeight;\n                if (isWithinButton) {\n                    return button.action;\n                }\n                buttonY += layout.buttonHeight + layout.buttonSpacing;\n            }\n            return null;\n        }\n        if (this.inGameMenuTab === 'options') {\n            let optionY = layout.contentTopY;\n            const optionHeight = layout.buttonHeight;\n            const optionSpacing = layout.buttonSpacing;\n            const optionX = layout.buttonX;\n            const optionWidth = layout.buttonWidth;\n            const buttonWidth = optionWidth * 0.35;\n            const buttonGap = 10;\n            // Damage Display Mode buttons\n            const damageButton1X = optionX + optionWidth - buttonWidth * 2 - buttonGap;\n            const damageButton2X = optionX + optionWidth - buttonWidth;\n            if (screenY >= optionY && screenY <= optionY + optionHeight) {\n                if (screenX >= damageButton1X && screenX <= damageButton1X + buttonWidth) {\n                    return { type: 'damageDisplayMode', mode: 'damage' };\n                }\n                if (screenX >= damageButton2X && screenX <= damageButton2X + buttonWidth) {\n                    return { type: 'damageDisplayMode', mode: 'remaining-life' };\n                }\n            }\n            optionY += optionHeight + optionSpacing;\n            // Health Display Mode buttons\n            const healthButton1X = optionX + optionWidth - buttonWidth * 2 - buttonGap;\n            const healthButton2X = optionX + optionWidth - buttonWidth;\n            if (screenY >= optionY && screenY <= optionY + optionHeight) {\n                if (screenX >= healthButton1X && screenX <= healthButton1X + buttonWidth) {\n                    return { type: 'healthDisplayMode', mode: 'bar' };\n                }\n                if (screenX >= healthButton2X && screenX <= healthButton2X + buttonWidth) {\n                    return { type: 'healthDisplayMode', mode: 'number' };\n                }\n            }\n            return null;\n        }\n        const isWithinList = screenX >= layout.graphicsListX &&\n            screenX <= layout.graphicsListX + layout.graphicsListWidth &&\n            screenY >= layout.graphicsListY &&\n            screenY <= layout.graphicsListY + layout.graphicsListHeight;\n        if (!isWithinList) {\n            return null;\n        }\n        const contentHeight = this.graphicsOptions.length * layout.graphicsRowHeight;\n        const localY = screenY - layout.graphicsListY + this.graphicsMenuScrollOffset;\n        if (localY < 0 || localY > contentHeight) {\n            return null;\n        }\n        const rowIndex = Math.floor(localY / layout.graphicsRowHeight);\n        const option = this.graphicsOptions[rowIndex];\n        if (!option) {\n            return null;\n        }\n        const buttonAreaWidth = layout.graphicsButtonWidth * 3 + layout.graphicsButtonGap * 2;\n        const buttonStartX = layout.graphicsListX + layout.graphicsListWidth - buttonAreaWidth - 8;\n        const rowY = layout.graphicsListY + rowIndex * layout.graphicsRowHeight - this.graphicsMenuScrollOffset;\n        const buttonY = rowY + (layout.graphicsRowHeight - layout.graphicsButtonHeight) / 2;\n        const variants = ['svg', 'png', 'stub'];\n        for (let i = 0; i < variants.length; i += 1) {\n            const buttonX = buttonStartX + i * (layout.graphicsButtonWidth + layout.graphicsButtonGap);\n            const isWithinButton = screenX >= buttonX &&\n                screenX <= buttonX + layout.graphicsButtonWidth &&\n                screenY >= buttonY &&\n                screenY <= buttonY + layout.graphicsButtonHeight;\n            if (isWithinButton) {\n                return { type: 'graphicsVariant', key: option.key, variant: variants[i] };\n            }\n        }\n        return null;\n    }\n    /**\n     * Draw in-game menu overlay\n     */\n    drawInGameMenuOverlay() {\n        const layout = this.getInGameMenuLayout();\n        const screenWidth = layout.screenWidth;\n        const screenHeight = layout.screenHeight;\n        const isCompactLayout = layout.isCompactLayout;\n        // Semi-transparent background\n        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';\n        this.ctx.fillRect(0, 0, screenWidth, screenHeight);\n        // Menu panel\n        const panelWidth = layout.panelWidth;\n        const panelHeight = layout.panelHeight;\n        const panelX = layout.panelX;\n        const panelY = layout.panelY;\n        this.ctx.fillStyle = 'rgba(30, 30, 30, 0.95)';\n        this.ctx.fillRect(panelX, panelY, panelWidth, panelHeight);\n        // Panel border\n        this.ctx.strokeStyle = '#FFD700';\n        this.ctx.lineWidth = 3;\n        this.ctx.strokeRect(panelX, panelY, panelWidth, panelHeight);\n        // Title\n        this.ctx.fillStyle = '#FFD700';\n        this.ctx.font = `bold ${isCompactLayout ? 22 : 30}px Doto`;\n        this.ctx.textAlign = 'center';\n        this.ctx.fillText('GAME MENU', screenWidth / 2, layout.titleY);\n        for (const tab of layout.tabs) {\n            const isActive = this.inGameMenuTab === tab.tab;\n            this.ctx.fillStyle = isActive ? 'rgba(255, 215, 0, 0.3)' : 'rgba(60, 60, 60, 0.9)';\n            this.ctx.fillRect(tab.x, tab.y, tab.width, tab.height);\n            this.ctx.strokeStyle = isActive ? '#FFD700' : '#FFFFFF';\n            this.ctx.lineWidth = 2;\n            this.ctx.strokeRect(tab.x, tab.y, tab.width, tab.height);\n            this.ctx.fillStyle = '#FFFFFF';\n            this.ctx.font = `${isCompactLayout ? 14 : 16}px Doto`;\n            const tabLabel = tab.tab === 'main' ? 'Main' : tab.tab === 'options' ? 'Options' : 'Graphics';\n            this.ctx.fillText(tabLabel, tab.x + tab.width / 2, tab.y + tab.height * 0.68);\n        }\n        if (this.inGameMenuTab === 'main') {\n            // Menu buttons\n            let buttonY = layout.contentTopY;\n            const buttonWidth = layout.buttonWidth;\n            const buttonHeight = layout.buttonHeight;\n            const buttonX = layout.buttonX;\n            const buttonSpacing = layout.buttonSpacing;\n            // Helper function to draw a button\n            const drawButton = (label, y) => {\n                this.ctx.fillStyle = 'rgba(80, 80, 80, 0.9)';\n                this.ctx.fillRect(buttonX, y, buttonWidth, buttonHeight);\n                this.ctx.strokeStyle = '#FFFFFF';\n                this.ctx.lineWidth = 2;\n                this.ctx.strokeRect(buttonX, y, buttonWidth, buttonHeight);\n                this.ctx.fillStyle = '#FFFFFF';\n                this.ctx.font = `${isCompactLayout ? 18 : 20}px Doto`;\n                this.ctx.fillText(label, screenWidth / 2, y + (buttonHeight * 0.65));\n            };\n            drawButton('Resume', buttonY);\n            buttonY += buttonHeight + buttonSpacing;\n            drawButton(this.showInfo ? 'Hide Info' : 'Show Info', buttonY);\n            buttonY += buttonHeight + buttonSpacing;\n            drawButton('Surrender', buttonY);\n        }\n        else if (this.inGameMenuTab === 'options') {\n            // Options tab content\n            let optionY = layout.contentTopY;\n            const optionHeight = layout.buttonHeight;\n            const optionSpacing = layout.buttonSpacing;\n            const optionX = layout.buttonX;\n            const optionWidth = layout.buttonWidth;\n            // Helper function to draw an option toggle\n            const drawOptionToggle = (label, y, isActive) => {\n                // Draw label\n                this.ctx.fillStyle = '#FFFFFF';\n                this.ctx.font = `${isCompactLayout ? 16 : 18}px Doto`;\n                this.ctx.textAlign = 'left';\n                this.ctx.fillText(label, optionX, y + (optionHeight * 0.4));\n                // Draw toggle buttons\n                const buttonWidth = optionWidth * 0.35;\n                const buttonGap = 10;\n                const button1X = optionX + optionWidth - buttonWidth * 2 - buttonGap;\n                const button2X = optionX + optionWidth - buttonWidth;\n                return { button1X, button2X, buttonWidth };\n            };\n            // Damage Display Mode option\n            this.ctx.fillStyle = '#AAAAAA';\n            this.ctx.font = `${isCompactLayout ? 14 : 16}px Doto`;\n            this.ctx.textAlign = 'left';\n            this.ctx.fillText('Damage Display:', optionX, optionY + (optionHeight * 0.4));\n            const damageButtons = {\n                button1X: optionX + optionWidth - optionWidth * 0.35 * 2 - 10,\n                button2X: optionX + optionWidth - optionWidth * 0.35,\n                buttonWidth: optionWidth * 0.35\n            };\n            // Damage button\n            const isDamageMode = this.damageDisplayMode === 'damage';\n            this.ctx.fillStyle = isDamageMode ? 'rgba(255, 215, 0, 0.6)' : 'rgba(80, 80, 80, 0.9)';\n            this.ctx.fillRect(damageButtons.button1X, optionY, damageButtons.buttonWidth, optionHeight);\n            this.ctx.strokeStyle = isDamageMode ? '#FFD700' : '#FFFFFF';\n            this.ctx.lineWidth = 2;\n            this.ctx.strokeRect(damageButtons.button1X, optionY, damageButtons.buttonWidth, optionHeight);\n            this.ctx.fillStyle = '#FFFFFF';\n            this.ctx.font = `${isCompactLayout ? 14 : 16}px Doto`;\n            this.ctx.textAlign = 'center';\n            this.ctx.fillText('Dmg #', damageButtons.button1X + damageButtons.buttonWidth / 2, optionY + (optionHeight * 0.65));\n            // Remaining Life button\n            const isRemainingMode = this.damageDisplayMode === 'remaining-life';\n            this.ctx.fillStyle = isRemainingMode ? 'rgba(255, 215, 0, 0.6)' : 'rgba(80, 80, 80, 0.9)';\n            this.ctx.fillRect(damageButtons.button2X, optionY, damageButtons.buttonWidth, optionHeight);\n            this.ctx.strokeStyle = isRemainingMode ? '#FFD700' : '#FFFFFF';\n            this.ctx.lineWidth = 2;\n            this.ctx.strokeRect(damageButtons.button2X, optionY, damageButtons.buttonWidth, optionHeight);\n            this.ctx.fillStyle = '#FFFFFF';\n            this.ctx.font = `${isCompactLayout ? 14 : 16}px Doto`;\n            this.ctx.textAlign = 'center';\n            this.ctx.fillText('HP Left', damageButtons.button2X + damageButtons.buttonWidth / 2, optionY + (optionHeight * 0.65));\n            optionY += optionHeight + optionSpacing;\n            // Health Display Mode option\n            this.ctx.fillStyle = '#AAAAAA';\n            this.ctx.font = `${isCompactLayout ? 14 : 16}px Doto`;\n            this.ctx.textAlign = 'left';\n            this.ctx.fillText('Health Display:', optionX, optionY + (optionHeight * 0.4));\n            const healthButtons = {\n                button1X: optionX + optionWidth - optionWidth * 0.35 * 2 - 10,\n                button2X: optionX + optionWidth - optionWidth * 0.35,\n                buttonWidth: optionWidth * 0.35\n            };\n            // Bar button\n            const isBarMode = this.healthDisplayMode === 'bar';\n            this.ctx.fillStyle = isBarMode ? 'rgba(255, 215, 0, 0.6)' : 'rgba(80, 80, 80, 0.9)';\n            this.ctx.fillRect(healthButtons.button1X, optionY, healthButtons.buttonWidth, optionHeight);\n            this.ctx.strokeStyle = isBarMode ? '#FFD700' : '#FFFFFF';\n            this.ctx.lineWidth = 2;\n            this.ctx.strokeRect(healthButtons.button1X, optionY, healthButtons.buttonWidth, optionHeight);\n            this.ctx.fillStyle = '#FFFFFF';\n            this.ctx.font = `${isCompactLayout ? 14 : 16}px Doto`;\n            this.ctx.textAlign = 'center';\n            this.ctx.fillText('Bar', healthButtons.button1X + healthButtons.buttonWidth / 2, optionY + (optionHeight * 0.65));\n            // Number button\n            const isNumberMode = this.healthDisplayMode === 'number';\n            this.ctx.fillStyle = isNumberMode ? 'rgba(255, 215, 0, 0.6)' : 'rgba(80, 80, 80, 0.9)';\n            this.ctx.fillRect(healthButtons.button2X, optionY, healthButtons.buttonWidth, optionHeight);\n            this.ctx.strokeStyle = isNumberMode ? '#FFD700' : '#FFFFFF';\n            this.ctx.lineWidth = 2;\n            this.ctx.strokeRect(healthButtons.button2X, optionY, healthButtons.buttonWidth, optionHeight);\n            this.ctx.fillStyle = '#FFFFFF';\n            this.ctx.font = `${isCompactLayout ? 14 : 16}px Doto`;\n            this.ctx.textAlign = 'center';\n            this.ctx.fillText('Number', healthButtons.button2X + healthButtons.buttonWidth / 2, optionY + (optionHeight * 0.65));\n        }\n        else {\n            const maxScroll = this.getGraphicsMenuMaxScroll(layout);\n            if (this.graphicsMenuScrollOffset > maxScroll) {\n                this.graphicsMenuScrollOffset = maxScroll;\n            }\n            this.ctx.fillStyle = 'rgba(20, 20, 20, 0.85)';\n            this.ctx.fillRect(layout.graphicsListX, layout.graphicsListY, layout.graphicsListWidth, layout.graphicsListHeight);\n            this.ctx.save();\n            this.ctx.beginPath();\n            this.ctx.rect(layout.graphicsListX, layout.graphicsListY, layout.graphicsListWidth, layout.graphicsListHeight);\n            this.ctx.clip();\n            const labelX = layout.graphicsListX + 8;\n            const buttonAreaWidth = layout.graphicsButtonWidth * 3 + layout.graphicsButtonGap * 2;\n            const buttonStartX = layout.graphicsListX + layout.graphicsListWidth - buttonAreaWidth - 8;\n            const variants = [\n                { variant: 'svg', label: 'SVG' },\n                { variant: 'png', label: 'PNG' },\n                { variant: 'stub', label: 'Stub' }\n            ];\n            for (let i = 0; i < this.graphicsOptions.length; i += 1) {\n                const option = this.graphicsOptions[i];\n                const rowY = layout.graphicsListY + i * layout.graphicsRowHeight - this.graphicsMenuScrollOffset;\n                if (rowY + layout.graphicsRowHeight < layout.graphicsListY || rowY > layout.graphicsListY + layout.graphicsListHeight) {\n                    continue;\n                }\n                this.ctx.fillStyle = i % 2 === 0 ? 'rgba(40, 40, 40, 0.6)' : 'rgba(55, 55, 55, 0.6)';\n                this.ctx.fillRect(layout.graphicsListX, rowY, layout.graphicsListWidth, layout.graphicsRowHeight);\n                this.ctx.fillStyle = '#FFFFFF';\n                this.ctx.font = `${isCompactLayout ? 13 : 15}px Doto`;\n                this.ctx.textAlign = 'left';\n                this.ctx.fillText(option.label, labelX, rowY + layout.graphicsRowHeight * 0.65);\n                const selectedVariant = this.getGraphicVariant(option.key);\n                const buttonY = rowY + (layout.graphicsRowHeight - layout.graphicsButtonHeight) / 2;\n                for (let j = 0; j < variants.length; j += 1) {\n                    const variant = variants[j];\n                    const buttonX = buttonStartX + j * (layout.graphicsButtonWidth + layout.graphicsButtonGap);\n                    const isSelected = selectedVariant === variant.variant;\n                    const isAvailable = variant.variant === 'stub' ||\n                        (variant.variant === 'svg' && option.svgPath) ||\n                        (variant.variant === 'png' && option.pngPath);\n                    this.ctx.fillStyle = isSelected ? 'rgba(255, 215, 0, 0.6)' : 'rgba(80, 80, 80, 0.9)';\n                    if (!isAvailable) {\n                        this.ctx.fillStyle = 'rgba(50, 50, 50, 0.5)';\n                    }\n                    this.ctx.fillRect(buttonX, buttonY, layout.graphicsButtonWidth, layout.graphicsButtonHeight);\n                    this.ctx.strokeStyle = isSelected ? '#FFD700' : '#FFFFFF';\n                    this.ctx.lineWidth = 1.5;\n                    this.ctx.strokeRect(buttonX, buttonY, layout.graphicsButtonWidth, layout.graphicsButtonHeight);\n                    this.ctx.fillStyle = isAvailable ? '#FFFFFF' : '#888888';\n                    this.ctx.font = `${isCompactLayout ? 11 : 12}px Doto`;\n                    this.ctx.textAlign = 'center';\n                    this.ctx.fillText(variant.label, buttonX + layout.graphicsButtonWidth / 2, buttonY + layout.graphicsButtonHeight * 0.68);\n                }\n            }\n            this.ctx.restore();\n        }\n        this.ctx.textAlign = 'left';\n    }\n    /**\n     * Draw end-game statistics screen\n     */\n    drawEndGameStatsScreen(game, winner) {\n        const dpr = window.devicePixelRatio || 1;\n        const screenWidth = this.canvas.width / dpr;\n        const screenHeight = this.canvas.height / dpr;\n        const isCompactLayout = screenWidth < 700;\n        // Semi-transparent background\n        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';\n        this.ctx.fillRect(0, 0, screenWidth, screenHeight);\n        // Victory message\n        this.ctx.fillStyle = this.getFactionColor(winner.faction);\n        const victoryFontSize = Math.max(28, Math.min(48, screenWidth * 0.12));\n        this.ctx.font = `bold ${victoryFontSize}px Doto`;\n        this.ctx.textAlign = 'center';\n        this.ctx.fillText(`${winner.name} WINS!`, screenWidth / 2, 80);\n        // Stats panel\n        const panelWidth = Math.min(700, screenWidth - 40);\n        const panelHeight = Math.min(450, screenHeight - 200);\n        const panelX = (screenWidth - panelWidth) / 2;\n        const panelY = 130;\n        this.ctx.fillStyle = 'rgba(30, 30, 30, 0.95)';\n        this.ctx.fillRect(panelX, panelY, panelWidth, panelHeight);\n        this.ctx.strokeStyle = '#FFD700';\n        this.ctx.lineWidth = 3;\n        this.ctx.strokeRect(panelX, panelY, panelWidth, panelHeight);\n        // Match statistics title\n        this.ctx.fillStyle = '#FFD700';\n        const statsTitleSize = Math.max(18, Math.min(28, screenWidth * 0.07));\n        this.ctx.font = `bold ${statsTitleSize}px Doto`;\n        this.ctx.fillText('MATCH STATISTICS', screenWidth / 2, panelY + 50);\n        // Draw stats for each player\n        const statsFontSize = Math.max(14, Math.min(20, screenWidth * 0.045));\n        this.ctx.font = `${statsFontSize}px Doto`;\n        let y = panelY + 100;\n        const horizontalPadding = 24;\n        const labelColumnWidth = Math.max(100, Math.min(200, panelWidth * 0.4));\n        const playerCount = game.players.length;\n        const availablePlayerWidth = panelWidth - horizontalPadding * 2 - labelColumnWidth;\n        const playerColumnWidth = Math.max(50, availablePlayerWidth / playerCount);\n        const leftCol = panelX + horizontalPadding;\n        const playerStartX = leftCol + labelColumnWidth;\n        // Headers\n        this.ctx.fillStyle = '#FFFFFF';\n        this.ctx.textAlign = 'left';\n        this.ctx.fillText('Statistic', leftCol, y);\n        this.ctx.textAlign = 'right';\n        for (let i = 0; i < game.players.length; i++) {\n            const player = game.players[i];\n            const color = this.getFactionColor(player.faction);\n            this.ctx.fillStyle = color;\n            const colX = playerStartX + playerColumnWidth * (i + 1);\n            this.ctx.fillText(player.name, colX, y);\n        }\n        y += isCompactLayout ? 32 : 40;\n        // Stat rows\n        const stats = [\n            { label: 'Units Created', key: 'unitsCreated' },\n            { label: 'Units Lost', key: 'unitsLost' },\n            { label: 'Energy Gathered', key: 'energyGathered' }\n        ];\n        for (const stat of stats) {\n            this.ctx.fillStyle = '#FFFFFF';\n            this.ctx.textAlign = 'left';\n            this.ctx.fillText(stat.label, leftCol, y);\n            this.ctx.textAlign = 'right';\n            for (let i = 0; i < game.players.length; i++) {\n                const player = game.players[i];\n                const value = stat.key === 'energy' ? player[stat.key].toFixed(1) : player[stat.key];\n                const colX = playerStartX + playerColumnWidth * (i + 1);\n                this.ctx.fillText(String(value), colX, y);\n            }\n            y += isCompactLayout ? 28 : 35;\n        }\n        // Continue button\n        const buttonWidth = Math.min(300, screenWidth - 60);\n        const buttonHeight = isCompactLayout ? 50 : 60;\n        const buttonX = (screenWidth - buttonWidth) / 2;\n        const buttonY = Math.min(panelY + panelHeight + 30, screenHeight - buttonHeight - 20);\n        this.ctx.fillStyle = 'rgba(80, 80, 80, 0.9)';\n        this.ctx.fillRect(buttonX, buttonY, buttonWidth, buttonHeight);\n        this.ctx.strokeStyle = '#FFD700';\n        this.ctx.lineWidth = 3;\n        this.ctx.strokeRect(buttonX, buttonY, buttonWidth, buttonHeight);\n        this.ctx.fillStyle = '#FFFFFF';\n        this.ctx.font = `bold ${isCompactLayout ? 20 : 24}px Doto`;\n        this.ctx.textAlign = 'center';\n        this.ctx.fillText('Continue', screenWidth / 2, buttonY + (buttonHeight * 0.65));\n        this.ctx.textAlign = 'left';\n    }\n    /**\n     * Draw border fade effect - fades to black at map edges\n     */\n    drawBorderFade(mapSize) {\n        const dpr = window.devicePixelRatio || 1;\n        const screenWidth = this.canvas.width / dpr;\n        const screenHeight = this.canvas.height / dpr;\n        // Define fade zone width in world units\n        const fadeZoneWidth = 150;\n        // Calculate map boundaries in world coordinates\n        const halfMapSize = mapSize / 2;\n        // Convert map edges to screen coordinates\n        const topLeft = this.worldToScreen(new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(-halfMapSize, -halfMapSize));\n        const topRight = this.worldToScreen(new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(halfMapSize, -halfMapSize));\n        const bottomLeft = this.worldToScreen(new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(-halfMapSize, halfMapSize));\n        // Calculate fade start positions (inside the map boundary) in screen space\n        const fadeStartLeft = this.worldToScreen(new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(-halfMapSize + fadeZoneWidth, 0));\n        const fadeStartRight = this.worldToScreen(new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(halfMapSize - fadeZoneWidth, 0));\n        const fadeStartTop = this.worldToScreen(new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(0, -halfMapSize + fadeZoneWidth));\n        const fadeStartBottom = this.worldToScreen(new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(0, halfMapSize - fadeZoneWidth));\n        const fadeWidthX = Math.abs(fadeStartLeft.x - topLeft.x);\n        const fadeWidthY = Math.abs(fadeStartTop.y - topLeft.y);\n        // Save context state\n        this.ctx.save();\n        // Left edge fade\n        if (topLeft.x < screenWidth) {\n            const gradient = this.ctx.createLinearGradient(topLeft.x, 0, topLeft.x + fadeWidthX, 0);\n            gradient.addColorStop(0, 'rgba(0, 0, 0, 1)');\n            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');\n            this.ctx.fillStyle = gradient;\n            this.ctx.fillRect(0, 0, topLeft.x + fadeWidthX, screenHeight);\n        }\n        // Right edge fade\n        if (topRight.x > 0) {\n            const gradient = this.ctx.createLinearGradient(topRight.x, 0, topRight.x - fadeWidthX, 0);\n            gradient.addColorStop(0, 'rgba(0, 0, 0, 1)');\n            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');\n            this.ctx.fillStyle = gradient;\n            this.ctx.fillRect(topRight.x - fadeWidthX, 0, screenWidth - (topRight.x - fadeWidthX), screenHeight);\n        }\n        // Top edge fade\n        if (topLeft.y < screenHeight) {\n            const gradient = this.ctx.createLinearGradient(0, topLeft.y, 0, topLeft.y + fadeWidthY);\n            gradient.addColorStop(0, 'rgba(0, 0, 0, 1)');\n            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');\n            this.ctx.fillStyle = gradient;\n            this.ctx.fillRect(0, 0, screenWidth, topLeft.y + fadeWidthY);\n        }\n        // Bottom edge fade\n        if (bottomLeft.y > 0) {\n            const gradient = this.ctx.createLinearGradient(0, bottomLeft.y, 0, bottomLeft.y - fadeWidthY);\n            gradient.addColorStop(0, 'rgba(0, 0, 0, 1)');\n            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');\n            this.ctx.fillStyle = gradient;\n            this.ctx.fillRect(0, bottomLeft.y - fadeWidthY, screenWidth, screenHeight - (bottomLeft.y - fadeWidthY));\n        }\n        // Restore context state\n        this.ctx.restore();\n    }\n    /**\n     * Set camera zoom\n     */\n    setZoom(zoom) {\n        this.zoom = Math.max(0.5, Math.min(2.0, zoom));\n    }\n    /**\n     * Set camera position\n     */\n    setCameraPosition(pos) {\n        // Clamp camera position to level boundaries\n        const clampedPos = this.clampCameraToLevelBounds(pos);\n        this.camera = new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(clampedPos.x, clampedPos.y);\n        this.parallaxCamera = new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(clampedPos.x, clampedPos.y);\n    }\n    setCameraPositionWithoutParallax(pos) {\n        // Clamp camera position to level boundaries\n        const clampedPos = this.clampCameraToLevelBounds(pos);\n        this.camera = new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(clampedPos.x, clampedPos.y);\n    }\n    /**\n     * Clamp camera position to level boundaries\n     */\n    clampCameraToLevelBounds(pos) {\n        // Get device pixel ratio\n        const dpr = window.devicePixelRatio || 1;\n        // Calculate visible world dimensions based on canvas size and zoom\n        const viewWidth = (this.canvas.width / dpr) / this.zoom;\n        const viewHeight = (this.canvas.height / dpr) / this.zoom;\n        // Calculate max camera offset based on map size and view size\n        // The camera can move such that the view edges align with map boundaries\n        const halfMapSize = _constants__WEBPACK_IMPORTED_MODULE_1__.MAP_SIZE / 2;\n        const maxX = halfMapSize - viewWidth / 2;\n        const maxY = halfMapSize - viewHeight / 2;\n        const minX = -maxX;\n        const minY = -maxY;\n        // Clamp camera position\n        const clampedX = Math.max(minX, Math.min(maxX, pos.x));\n        const clampedY = Math.max(minY, Math.min(maxY, pos.y));\n        return new _game_core__WEBPACK_IMPORTED_MODULE_0__.Vector2D(clampedX, clampedY);\n    }\n    interpolateHexColor(startHex, endHex, t) {\n        const startValue = Number.parseInt(startHex.replace('#', ''), 16);\n        const endValue = Number.parseInt(endHex.replace('#', ''), 16);\n        const startR = (startValue >> 16) & 0xff;\n        const startG = (startValue >> 8) & 0xff;\n        const startB = startValue & 0xff;\n        const endR = (endValue >> 16) & 0xff;\n        const endG = (endValue >> 8) & 0xff;\n        const endB = endValue & 0xff;\n        const r = Math.round(startR + (endR - startR) * t);\n        const g = Math.round(startG + (endG - startG) * t);\n        const b = Math.round(startB + (endB - startB) * t);\n        return `#${((r << 16) | (g << 8) | b).toString(16).padStart(6, '0')}`;\n    }\n}\nGameRenderer.CONTROL_LINES_FULL = [\n    'Controls: Drag to select units',\n    'Pan: WASD/Arrows or mouse edge or two-finger drag',\n    'Zoom: Scroll/Pinch (zooms toward cursor)',\n    'Hold still 6 seconds in influence to open warp gate'\n];\nGameRenderer.CONTROL_LINES_COMPACT = [\n    'Controls: Drag to select units',\n    'Pan: WASD/Arrows or two-finger drag',\n    'Zoom: Scroll/Pinch toward cursor',\n    'Hold still 6s in influence to open warp gate'\n];\n\n\n//# sourceURL=webpack://sol/./src/renderer.ts?\n}");

/***/ }

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Check if module exists (development only)
/******/ 		if (__webpack_modules__[moduleId] === undefined) {
/******/ 			var e = new Error("Cannot find module '" + moduleId + "'");
/******/ 			e.code = 'MODULE_NOT_FOUND';
/******/ 			throw e;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.ts");
/******/ 	
/******/ })()
;